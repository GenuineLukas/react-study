# Java

Status: Done
Assign: GenuineLukas
subject: BackEnd

**writer: @GenuineLukas 

**This course credit (this page is based on the course below)

**[자바로 입력받는 방법](https://rhsalska55.tistory.com/6)

[](https://www.udemy.com/course/best-java-programming/)

[Data Types - in Depth](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Data%20Types%20-%20in%20Depth%204f3db54cce514172bea316b52c3e3e38.md)

[Java Design Patterns](https://www.notion.so/Java-Design-Patterns-63d24c66927a4535bb575e11d7dc095b?pvs=21)

- Compilation and Execution of a Java Program
    
    Java, being a platform-independent programming language, doesn’t work on the one-step compilation. Instead, it involves two-step execution, first through an OS-independent compiler; and second, in a virtual machine (JVM) which is custom-built for every operating system. 
    
    ![Untitled](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Untitled.png)
    
    **Principle 1: Compilation**
    
    First, the source ‘.java’ file is passed through the compiler, which then encodes the source code into a machine-independent encoding, known as Bytecode. The content of each class contained in the source file is stored in a sperate ‘.class’ file. To convert the source code into the bytecode, the compiler follows the following steps.
    
    1. Parse: Reads a set of *.java source files and maps the resulting token sequence into AST-Nodes.
    2. Enter: Enters symbols for the definitions into the symbol table.
    3. Attribute: Attributes the Syntax trees. This step includes name resolution, type checking and constant folding
    4. Flow: Performs dataflow analysis on the trees from the previous step. This includes checks for assignments and reachability.
    5. Desugar: Rewrites the AST and translates away some syntactic sugar.
    6. Generate: Generates ‘.class’ files.
    
    **Principle 2: Execution**
    
    The class files generated by the compiler are independent of the machine or the OS, which allows them to be run on any system. To run, the main class file (the class that contains the method main) is passed to the JVM and then goes through three main stages before the final machine code is executed. These stages include:
    
    1. ClassLoader
        
        The main class is loaded into the memory bypassing its’.class’ file to the JVM, through invoking the latter. All the other classes referenced in the program are loaded through the class loader. A class loader, itself an object, creates a flat namespace of class bodies that are referenced by a string name. The method definition is provided below illustration as follows:
        
        ```java
        //loadClass function prototype
        Class r = loadClass(String className, boolean resovIt);
        //className: name of the class to be loaded
        //resolveIt: flag to decide whether any referenced class should be loaded or not.
        ```
        
        There are two types of class loaders
        
        - primordial
        - non-primordial
        
        The primordial class loader is embedded into all JVMs and is the default class loader. A non-primordial class loader is a user-defined class loader, which can be coded in order to customize the class-loading process. Non-primordial class loader, if defined, is preferred over the default one, to load classes
        
    2. Bytecode Verifier
        
        After the bytecode of a class is loaded by the class loader, it has to be inspected by the bytecode verifier, whose job is to check that the instructions don’t perform damaging actions. The following are some of the checks carried out.
        
        - Variables are initialized before they are used.
        - Method calls match the types of object references.
        - Rules for accessing private data and methods are not violated.
        - Local variable accesses fall within the runtime stack.
        - The run-time stack does not overflow.
        - If any of the above checks fail, the verifier doesn’t allow the class to be loaded.
    3. Just-In-Time Compiler
        
        This is the final stage encountered by the java program, and its job is to convert the loaded bytecode into machine code. When using a JIT compiler, the hardware can execute the native code, as opposed to having the JVM interpret the same sequence of bytecode repeatedly and incurring the penalty of a relatively lengthy translation process. This can lead to performance gains in the execution speed unless methods are executed less frequently.
        
    
    ***Conclusion:** Due to the two-step execution process described above, a java program is independent of the target operating system. However, because of the same, the execution time is way more than a similar program written in a compiled platform-dependent program.*
    
- conditional statements
    - if
    - switch
        - A `switch`
        works with the `byte`, `short`, `char`, and `int` primitive data types. It also works with *enumerated types* (discussed in [Enum Types](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html)), the `[String](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html)` class, and a few special classes that wrap certain primitive types: `[Character](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html)`, `[Byte](https://docs.oracle.com/javase/8/docs/api/java/lang/Byte.html)`, `[Short](https://docs.oracle.com/javase/8/docs/api/java/lang/Short.html)`, and `[Integer](https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html)`(discussed in [Numbers and Strings](https://docs.oracle.com/javase/tutorial/java/data/index.html)).
        - this means `switch` doesn’t work with `long` or `double`.
        
        **Problem: Designing  a Menu**
        
    - Ask User for input
        - Enter two Numbers
        - Choose an Operation
            - add
            - multiply
            - divide
            - subtract
            - …
        - Publish Result
    
    ```jsx
    //how it should look in console
    Enter Number1:
    2
    
    Enter Number2:
    4
    
    1 - add
    2 - subtract
    3 - divide
    4 - multiply
    Choose Operation: 4
    
    Result is - 8
    ```
    
    ```java
    import java.io.BufferedReader;
    import java.io.InputStreamReader;
    import java.util.StringTokenizer;
    
    public class Main {
      public static void main(String[] args) throws Exception{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        boolean run = true;
        start:
        while(run){
             System.out.println("Enter Number1: ");
          StringTokenizer st = new StringTokenizer(br.readLine());//이거 만들 때 마다 한 줄 씩 읽음. 
          double result = 0;//a double type variable to store result val.
          double n = Double.parseDouble(st.nextToken());
          System.out.println();
          System.out.println("Enter Number2: ");
          st = new StringTokenizer(br.readLine());
          double m = Double.parseDouble(st.nextToken());
      
          System.out.println();
          System.out.println("Choices Available are ");
          System.out.println("  1 - add");
          System.out.println("  2 - subtract");
          System.out.println("  3 - divide");
          System.out.println("  4 - multiply");
          System.out.println("  Choose Operation:");
          st = new StringTokenizer(br.readLine());
        
          int choice = Integer.parseInt(st.nextToken());
    
          System.out.println();
          System.out.println("Your choices are");
          System.out.println("Number1 " + n);
          System.out.println("Number2 " + m);
          String strChoice;
          switch(choice){
            case 1:
              strChoice = "add"; break;
            case 2:
              strChoice = "subtract"; break;
            case 3:
              strChoice = "divide"; break;
            case 4: 
              strChoice = "multiply"; break;
            default:
              System.out.println("I told you to write either 1, 2, 3, or 4!!!");
              break start;
          }
          System.out.println("Choice " + choice + " - " + strChoice);
    
          switch(choice){
            case 1:
              result = add(n, m); break;
            case 2:
              result = subtract(n, m); break;
            case 3:
              result = divide(n, m); break;
            case 4:
              result = multiply(n, m); break;
            default:
              System.out.println("I told you to write either 1, 2, 3, or 4!!!");
              break start;
          }
        
          System.out.println();
          System.out.println("Result is " + result);
          System.out.println("Are you going to continue the program?");
          System.out.println("Choose Y/N");
          st = new StringTokenizer(br.readLine());
          String choice2 = st.nextToken();
          if(choice2.equals("Y") || choice2.equals("y")){
            run = true;
          }else if (choice2.equals("N") || choice2.equals("n")){
            run = false;
            break;
          }
        }
        System.out.println("Program quitted.");
      }
    
      public static double add(double n, double m){
        return n + m;
      }
      public static double subtract(double n, double m){
        return n - m;
      }
      public static double divide(double n, double m){
        return n / m;
      }
      public static double multiply(double n, double m){
        return n * m;
      }
    }
    ```
    
    **Switch Exercises**
    
    - `public static boolean isWeekDay(int dayNumber){`
        - input - number of day 0 (Sunday) to 6(Saturday)
        - return if the day is a Week Day
    - `public static String determineNameOfMonth(int monthNumber) {`
        - input - number of month 1(January) to 12 (December)
        - output - Name of month
    - `public static String determineNameOfDay(int dayNumber) {`
        - input - number of day 0(Sunday) to 6(Saturday)
        - Return the day of week in text
    
    ```jsx
    public class Main {
      public static void main(String[] args) throws Exception{
        //(blah blah)
      }
      public static boolean isWeekDay(int dayNumber){
        switch(dayNumber){
          // case 0, 6 -> return false
          case 1: 
          case 2: 
          case 3: 
          case 4: 
          case 5: return true;
        }
        return false;
      }
      public static String determineNameOfMonth(int monthNumber){
        switch(monthNumber){
          case 0: return "January";
          case 1: return "Febraury";
          case 2: return "March";
          case 3: return "April";
          case 4: return "May";
          case 5: return "June";
          case 6: return "July";
          case 7: return "August";
          case 8: return "September";
          case 9: return "October";
          case 10: return "November";
          case 11: return "December";
        }
        return "invalid month";
      }
      public static String determineNameOfDay(int dayNumber){
        switch(dayNumber){
          //when you use return, you do not need to break;
          case 0: return "sunday";
          case 1: return "monday";
          case 2: return "tuesday";
          case 3: return "wednesday";
          case 4: return "thursday";
          case 5: return "friday";
          case 6: return "saturday";
        }
        return "invalid day";
      }
    }
    ```
    
- loops
    1. **For loops**
    
    ```jsx
    for(int i = 0; i < 10; i++){
    System.out.print(i);
    }
    //output - 0123456789
    ```
    
    **Exercise**
    
    `MyNumber number = new MyNumber(9);`
    
    `number.isPrime()//Is a number prime?`
    
    `int sum = number.sumUptoN();//sum of numbers upto n?`
    
    `int sumOfDivisors = number.sumOfDivisors();`
    
    `number.printANumberTriangle();` 
    
    ```java
    //1
    //1 2
    //1 2 3
    //1 2 3 4
    //1 2 3 4 5
    
    //Main class 
    public class Main {
      public static void main(String[] args) throws Exception{
        MyNumber number = new MyNumber(9);
        boolean isPrime = number.isPrime();//false
        int sum = number.sumUptoN();//45
        int sumOfDivisors = number.sumOfDivisors();//13
    
        System.out.println(isPrime);
        System.out.println(sum);
        System.out.println(sumOfDivisors);
        number.printANumberTriangle();
    
        MyNumber num = new MyNumber(1);
        System.out.println(num.isPrime());//false
      }
    }
    
    //MyNumber class
    public class MyNumber{
      private int num;
      
      public MyNumber(int num)  {
        this.num = num;
      }
      public boolean isPrime(){
        //number is not divisible by more than its half.
        //prime number: 1과 자기자신으로밖에 나눌 수 없는 수.
        boolean flag = true;
        for(int i = 2; i <= num/2; i++){
          if(num%i == 0){
            flag = false;
            break;
          }
        } return flag;
      }
    
      public int sumUptoN(){
        int sum = 0;
        for(int i = 1; i <= num; i++){
          sum+=i;
        }
        return sum;
      }
    
      public int sumOfDivisors(){
        int sum = 0;
        for(int i = 1; i <= num;i++){
          if(num%i == 0){
            sum+=i;
          }
        } return sum;
      }
    
      public void printANumberTriangle(){
        for(int i = 1; i <= num; i++){
          for(int j = 1; j <= i; j++){
            System.out.print(j);
          } System.out.println();
        }
      }
    }
    ```
    
    1. **while loop**
    
    ```java
    int count = 0;
    while(count < 5){//while this condition is true, loop is executed.
    	Systerm.out.print(count);
    	count++;
    }
    //Output: 01234
    --------------------------------------------------------------
    int count = 5;
    while(count < 5){//condition is false, so code in while is not executed.
    	System.out.println(count);
    	count++;
    }//Noting is printed to output
    ```
    
    **Exercise**
    
    `WhileNumberPlayer player = new WhileNumberPlayer(10);`
    
    `player.printSquaresUptoLimit();`
    
    → for limit = 30, output would be 1 4 9 16 25
    
    `player.printCubesUptoLimit();`
    
    → for limit = 30, output would be 1 8 27
    
    ```java
    //Main class
    public class Main {
      public static void main(String[] args) throws Exception{
        WhileNumberPlayer player = new WhileNumberPlayer(10);
    
        player.printSquaresUptoLimit(); //1.0 4.0 9.0
        player.printCubesUptoLimit(); // 8.0
      }
    }
    
    //WhileNnumberPlayer class
    import java.lang.Math;
    
    public class WhileNumberPlayer{
      private int limit;
      
      public WhileNumberPlayer(int limit){
        this.limit = limit;
      }
      
      public void printSquaresUptoLimit(){
        int base = 1;
        while(Math.pow(base, 2) <= limit){
          System.out.print(Math.pow(base, 2) + " ");
          base++;
        }
      }
    
      public void printCubesUptoLimit(){
        int base = 1;
        while(Math.pow(base, 3) <= limit){
          System.out.println(Math.pow(base, 3) + " ");
          base++;
        }
      }
    }
    ```
    
    1. **Do while loop**
    
    ```java
    //basically you use do while loop when you want the code in
    //in 'do' {} to be executed at least once.
    do{
    //something
    } while(condition);
    ```
    
    **Exercise**
    
    - Ask user for a number.
    - Print the cube of the number.
    - Do this repeatedly until user enters a negative number.
    
    `Enter a number: 5`
    
    `Cube is 125`
    
    `Enter a number: 3`
    
    `Cube is 27`
    
    `Enter a number: -1`
    
    `Thank you! Have fun!`
    
    - below is the code I wrote.
    
    ```java
    //main class
    import java.io.BufferedReader;
    import java.io.InputStreamReader;
    import java.util.StringTokenizer;
    import java.lang.Math;
    
    public class Main {
      public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        double d = 0.0;
        do {
          System.out.println("Enter a number:");
          StringTokenizer st = new StringTokenizer(br.readLine());
          d = Double.parseDouble(st.nextToken());
          if(d >= 0.0){
           System.out.println("Cube is " + Math.pow(d, 3.0)); 
          }
        } while (d >= 0.0);
        System.out.println("Thank you! Have fun!");
      }
    }
    ```
    
    - below is the code the instructor wrote
    
    ```java
    //main class
    import java.util.Scanner;
    
    public class DoWhileRepeatedQuestionRunner {
    	public static void main(String[] args){
    		Scanner scanner = new Scanner(System.in);
    		int number = -1;
    		do{
    			if(number != -1){
    				System.out.println("Cube is " + (number*number*number));
    			}
    			System.out.println("Enter a number: ");
    			number = scanner.nextInt();
    		} while(number >= 0);
    		System.out.println("Thank You! Have Fun!);
    	}
    }	
    ```
    
    **reflection:** what’s better about the instructor’s code than mine was that the instructor put `System.out.println("Cube is " + (number*number*number));` line at the top of do while loop and above the `System.out.println("Enter a number: ");`  code so that he could end with “Thank you! Have Fun!” right after the user write any negative value. Also, he added if statement at for the code at the top of do while loop to avoid unnecessarily printing cubes of the initial value that wasn’t written by the user.
    
    1. break and continue
        
        break → breaks out of the loop (for loop, while loop, etc.)
        
        continue → neglects the next process and jump right to the loop
        
        ```java
        public class Main {
          public static void main(String[] args) {
            for (int i = 0; i < 10; i++) {
              if (i == 4) {
                continue;
              }
              System.out.print(i); //012356789
            }  
          }
        }
        ```
        
    2. choosing a loop
        - Do you know how many times to run?
            - For Loop
        - Do you know when to end the loop?
            - While
        - Do you want to execute the loop at least once?
            - Do While
        
        Actually, you can write code with any of the loops.
        
        > it’s readability that matters
        > 
        
        Thanking Exercise
        
        > What would you use for the Menu if you would want to run it again and again?
        > 
- Reference Types
    - Reference variables vs primitive Variables
        - memory
            
            ```java
            class Animal{
            	int id;
            	Animal(int id){
            		this.id = id;
            	}
            }
            
            //in main class
            int i = 5;
            Animal dog = new Animal(12);
            Animal cat = new Ainmal(15);
            ```
            
            <Stack>
            
            | Location | Value | variable-name |
            | --- | --- | --- |
            | A | 5 | i |
            | B |  |  |
            | c | 1A(reference to the location in HEAP) | dog |
            | D | 1C | cat |
            | E |  |  |
            | F |  |  |
            
            <Heap>
            
            | Location | Object |
            | --- | --- |
            | 1A | Animal12(not exactly this, but set it like this as a reference) |
            | 1B |  |
            | 1C | Animal15 |
            | 1D |  |
            | 1E |  |
            | 1F |  |
            
            in the case of reference variables, what they store in the value in stack is the memory location, therefore say you do Animal impala = cat; then the value of that reference variable would be pointing to the same memory location as cat in the heap. What’s important is that when you add some changes to impala variable, say you did impala.id = 10, then the cat.id  would be 10 as well, since both were pointing to the same location in the memory.
            
            in the case of primitive variables, however, changes between two values are independent, though they were assigned as the same number, meaning if I did int i = 1; then did int j = i; what’s stored as the value is not the reference of the location. It’s just a number. Although you changed the value of J to 2, the value of the i won’t get affected.
            
            - “==” in reference type
                
                “==” in reference type checks if the reference type values being compared are pointing to the same location.  when “new” keyword took into play making a new instance of a class, although the value(any value related to the those instances) might be the same, those two variables aren’t the same when compared by “==”. they are distinct, independent object in the heap.
                
                ```java
                Animal dog = new Animal(12);//Animal@4b952a2d
                Animal cat = new Animal(10);//Animal@3159c4b8
                Animal ref = cat;//Animal@3159c4b8
                Animal dog2 = new Animal(12);//Animal@29ca901e
                cat == dog //false
                cat == ref //true
                dog == dog2 //false
                ```
                
        - assignment
        - initialization(null)
    - Predefined Reference Types in Java
        - String
            
            String is one of the predefined reference types in Java.
            
            for normal reference types, you have to use constructor when creating objects. For example,
            
            `BigDecimal bd = new BigDecimal(”1.0”);`
            
            String objects, however, can be created by doing 
            
            `String str = “Test”;`
            
            You could do 
            
            `String str = new String(”Test”);` if you really wanted to.
            
            **useful built-in methods for string.**
            
            1. length( )
            2. charAt( ) //index
            3. substring( )
                
                
                | https://docs.oracle.com/javase/7/docs/api/java/lang/String.html | https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#substring(int)(int beginIndex)Returns a new string that is a substring of this string. |
                | --- | --- |
                | https://docs.oracle.com/javase/7/docs/api/java/lang/String.html | https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#substring(int,%20int)(int beginIndex, int endIndex)Returns a new string that is a substring of this string. |
            4. indexOf( ) //returns the first index of what’s inside the parenthesis.
            5. lastIndexOf( ) //returns the last index of what’s inside the parenthesis when it’s only one character. if what’s inside is the string, then indexOf( ) and LastIndexOf( ) might be returning the same index given that there are only one words being looked for in the given string.
                
                ```jsx
                public class Main{
                  public static void main(String[] args){
                    String str = "wtf wow this is crazy wtf";
                    System.out.println(str.lastIndexOf("wtf"));
                    System.out.println(str.indexOf("wtf"));
                    }
                  }
                ```
                
            6. contains( ) //return boolean value
            7. startsWith( ) //return boolean value
            8. endsWith( ) //return boolean value
            9. isEmpty( ) //return boolean value
            10. equals( ) // check if the string is the same (not the memory location, it’s the look)
            11. equalsIgnoreCase( ) //the same as equals( ) except that it ignores the uppercase or lowercase
            12. concat( )
                
                ```java
                public class Main {
                  public static void main(String[] args) {
                		String str = "in28minutes";
                		System.out.println(str.concat(" is awesome"));//in28minutes is awesome
                		System.out.println(str);//in28minutes
                  }
                }
                ```
                
            13. toUpperCase( )
            14. toLowercase( )
            15. trim( ) //Returns a copy of the string, with leading and trailing whitespace omitted.
            16. join( ) //static method
                
                ```java
                public class Main {
                  public static void main(String[] args) {
                		String str = String.join("," , " a", "b");
                    System.out.println(str);//a,b
                  }
                }
                ```
                
            17. replace( )
                
                ```java
                "abcd".replace('a', 'z'); //"zbcd"
                "abcd".replace("ab", "xyz");//"xyzcd"
                ```
                
            - if there is a string in the adding operations, from that point the operation become concatenation.
                
                ```java
                System.out.println("value is " + 20 + 20); //value is 2020
                System.out.println("value is " + (20 + 20));//value is 40
                ```
                
            
            fun thing
            
            ```java
            public class Main{
              public static void main(String[] args){
                String str = "This is a lof of string";
                for(int i = 0; i < str.length(); i++){
                  System.out.println(str.charAt(i));
                }
              }
            }
            ```
            
        - Wrapper Classes
        - LocalDate, LocalDateTime
    - StringBuffer and StringBuilder
        
        When you deal with String in java, the main classes that comes in handy would be String, StringBuffer, and StringBuilder. If there is not a lot of operations between strings are required, there should be no issue with using any of them. when the number of operations gets bigger(lots of objects created due to String’s immutability) or when you have to consider a multi-thread situation, however, you need to understand each class’s characteristic and use it at the right moment.
        
        In contrast to String, **StringBuffer/StringBuilder is mutable**, making it possible to change the String structure inside the same StringBuffer/StringBuilder object. Also keep in minde that StringBuffer/StringBuilder is not predefined in Java, therefore forcing you to utilize a “new” constructor when creating a new object of such a type.
        
        ```java
        //What you can't do 
        //StringBuffer sb = "wow";
        //StringBuilder sb = "wow";
        
        //What you should do
        StringBuffer sb = new Stringbuffer("wow");
        StringBuilder sb1 = new StringBuilder("wow");
        ```
        
        The main difference between StringBuffer and StringBuilder class is whether it provides the synchronization. StringBuffer does provide it while StringBuilder doesn’t. In conclusion, you should use StringBuffer in the multi-thread situation, but unless you are considering a multi-thread situation, StringBuilder would be much faster in that case.
        
    - Wrapper classes
        - Wrapper classes wrap(enclose) around a data type and gives it an object appearance
        - Wrapper classes are final and immutable
        - Wrapper: Boolean, Byte, Character, Double, Float, Integer, Long, Short
        
        **Why Wrapper classes?**
        
        Creation from other data types
        
        ```java
        Integer hundered = Integer.valueOf("100");
        Boolean value = Boolean.valueOf("True");
        ```
        
        Utility methods
        
        ```java
        //conversion
        Float floatWrapper = Float.valueOf(57.0f);
        int floatToInt = floatWrapper.intValue();//57
        
        Integer seven = Integer.("111", 2); //7
        String seven = Integer.toString(seven, 2); //111
        ```
        
        **Ways to create wrapper classes**
        
        ```java
        Integer integer = new Integer(5);
        Integer integer1 = new Integer(5);
        Integer integer2 = new Integer("5");
        
        //using static method in a wrapper class
        //all the wrapper classes have valueOf( ) static method
        Integer integer = Integer.valueOf(5);
        Integer integer1 = Integer.valueOf(5);
        ```
        
        given the choices between these two ways of creating wrapper classes, you might wonder, “which one should I choose to use?”
        
        1. when you create the wrapper objects with new constructor, you are creating multiple objects.
        2. when you create the wrapper objects with the static method valueOf( ), you create an object then the next time you create another wrapper variable having the same value as the one created before, the two objects share the same memory address.
        
        ```java
        public class Main {
          public static void main(String[] args) {
          Integer i1 = new Integer(5);
          Integer i2 = new Integer(5);
          Integer i3 = Integer.valueOf(5);
          Integer i4 = Integer.valueOf(5);
            System.out.println(i1 == i2);//false
            System.out.println(i3 == i4);//true;
          }
        }
        ```
        
        ```java
        Integer number = new Integer(55);//int
        Integer number2 = new Intger("55");//String
        
        Float number3 = new Float(55.0);//double argument
        Float number4 = new Float(55.0f);//float argument
        Float number5 = new Float("55.0f");//String
        
        Character c1 = new Character('C');//only char constructor
        //Character c2 = new Character(123);//complie error
        
        Boolean b = new Boolean(true);
        
        //"true" "True" "tRue" - all String Values give True
        //Anything else gives false
        Boolean b1 = new Boolean("true");//true
        Boolean b2 = new Boolean("True");//true
        Boolean b3 = new Boolean("False");//false
        Boolean b4 = new Boolean("someString");//false
        ```
        
        **Auto Boxing**
        
        ```java
        public class Main {
          public static void main(String[] args) {
          //the way via which we used to create a wrapper variable
            Integer seven = Integer.valueOf(7);
          //autoBoxing
            Integer seven1 = 7; //basically java does Integer.valueOf() thing for you.
            Integer seven2 = 7;
            System.out.println(seven1 == seven2);//true
          }
        }
        ```
        
    - Date
        
        ![Untitled](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Untitled%201.png)
        
        ```java
        package TimePackage;
        
        import javax.swing.text.DateFormatter;
        import java.time.LocalDate;
        import java.time.LocalTime;
        import java.time.Period;
        import java.time.format.DateTimeFormatter;
        import java.time.format.FormatStyle;
        import java.time.temporal.ChronoUnit;
        
        public class DurationCalc {
            public static void main(String[] args) {
                DateTimeFormatter newFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
                String myDate = newFormatter.format(LocalDate.now());
                System.out.println(myDate);
        
                //getting a period using "between."
                LocalDate today = LocalDate.now();
                LocalDate birthday  = LocalDate.of(2003, 02, 13);
                Period period = Period.between(birthday, today);
                System.out.println(period.getDays());
                System.out.println(period.getMonths());
                System.out.println(period.getYears());
        
                //getting the same period using "until."
                LocalDate birthDate = LocalDate.parse("2003-02-13");
                LocalDate currDate = LocalDate.now();
        
                System.out.println("Period in Year: " + birthDate.until(currDate, ChronoUnit.YEARS));
                System.out.println("Period in Month: " + birthDate.until(currDate, ChronoUnit.MONTHS));
                System.out.println("Period in Day: " + birthDate.until(currDate, ChronoUnit.DAYS));
            }
        }
        ```
        
        [https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html](https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html)
        
        ```java
        import java.time.LocalDate;
        
        public class Main {
          public static void main(String[] args) {
            LocalDate today = LocalDate.now();
            LocalDate yesterday = LocalDate.of(2022, 12, 19);
            System.out.println(yesterday.withYear(2040));
            System.out.println(yesterday.withDayOfMonth(27));
            System.out.println(yesterday.withDayOfYear(365));
            //check if LocalDate is immutable
            System.out.println(yesterday);
            System.out.println(today.isBefore(yesterday));//false
            System.out.println(today.isAfter(yesterday));//true
          }
        }
        ```
        
    - how to see the java api
        1. cmd + shift
        2. look for the things you are looking for 
        
        1. cmd + O →gets you the list of the methods
        
        1. cmd + click (when you have the object)
- Array and ArrayList
    - for array, length is a property, not a method.
        
        ex) arr.length
        
    - the elements of an array should be in consistent type.
    - if you want to print the while array, you should use toString( ) static method in Arrays class.
        
        ```java
        int[] marks = {1, 2, 3, 4, 5};
        System.out.println(marks);//[[I@6c49835d
        System.out.println(Arrays.toString(marks));//[1, 2, 3, 4, 5]
        ```
        
    - you can make an array with class objects.
        
        ```java
        //this is possible
        class Person {
        }//Person class created
        Person[] persons = new Person[5}];//default is null
        ```
        
    - fill( ) //static method in Array
        
        ```java
        import java.util.Arrays;
        
        public class Main {
          public static void main(String[] args) {
            int[] marks = new int[5];
            Arrays.fill(marks, 100);
            System.out.println(Arrays.toString(marks));//[100, 100, 100, 100, 100]
          }
        }
        ```
        
    - equals( ) //true if the length and each corresponding element is the same
        
        ```java
        import java.util.Arrays;
        
        public class Main {
          public static void main(String[] args) {
            int[] arr1 = {1, 2, 3};
            int[] arr2 = {1, 3, 2};
            int[] arr3 = {1, 2, 3};
            System.out.println(Arrays.equals(arr1, arr2));//false
            System.out.println(Arrays.equals(arr1, arr3));//true
          }
        }
        ```
        
    - sort( ) //in-position sorting
        
        ```java
        import java.util.Arrays;
        
        public class Main {
          public static void main(String[] args) {
            int[] arr1 = {1, 2, 3, 9, 8, 7, 6, 4, 5};
            Arrays.sort(arr1);
            System.out.println(Arrays.toString(arr1));//[1, 2,3, 4, 5, 6, 7, 8, 9]
          }
        }
        ```
        
    - what we want to perform
        
        ```java
        Student student = new Student(name, list of marks);
        int number = student.getNumberOfMarks();
        int sum = student.getTotalSumOfMarks();
        int maximumMark = student.getMaximumMark();
        int minimumMark = student.getMinimumMark();
        BigDecimal average = student.getAverageMarks();
        ```
        
    - codes are below
        
        ```java
        //main class
        import java.util.Arrays;
        import java.math.BigDecimal;
        
        public class Main {
          public static void main(String[] args) {
            int[] marks = {99, 98, 100, 97, 89};
        
            Student student = new Student("Ranga", marks);
        
            int number = student.getNumberOfMarks();
            System.out.println("number of marks : " + number);//5
        
            int sum = student.getTotalSumOfMarks();
            System.out.println("sum of marks : "+ sum);//483
        
            int maximumMark = student.getMaximumMark();
            System.out.println("maximum of marks : " + maximumMark);//100
        
            int minimumMark = student.getMinimumMark();
            System.out.println("minimum of marks : " + minimumMark);//89
        
            BigDecimal avg = student.getAverageMarks();
            System.out.println(avg);//96.6000
          }
        }
        ```
        
        ```java
        //Student class
        import java.math.BigDecimal;
        import java.math.RoundingMode;
        
        public class Student{
          private String name;
          private int[] marks;
        
          public Student(String name, int[] marks){
            this.name = name;
            this.marks = marks;
          }
        
          public int getNumberOfMarks(){
            return marks.length;
          }
        
          public int getTotalSumOfMarks(){
            int sum = 0;
            for(int mark : marks){
              sum+=mark;
            } return sum;
          }
        
          public int getMaximumMark(){
            int max = 0; //you could do max = Integer.MIN_VALUE
            for(int mark : marks){
              if(mark > max){
                max = mark;
              }
            } return max;
          }
        
          public int getMinimumMark(){
            int min = getMaximumMark(); //you could do min = Integer.MAX_VALUE
            for(int mark : marks){
              if(mark < min){
                min = mark;
              }
            } return min;
          }
        
          public BigDecimal getAverageMarks(){
            int sum = getTotalSumOfMarks();
            int number = getNumberOfMarks();
            return new BigDecimal(Integer.toString(sum)).divide(new BigDecimal(Integer.toString(number)), 4, RoundingMode.UP);
          }
        }
        ```
        
    - variable arguments
        - should always be the last argument inside the parenthesis.
        
        **basic structure**
        
        ```java
        //example
        public class Main {
          public static void main(String[] args) {
            print(1, 2, 3, 4);//[1, 2, 3, 4]
            System.out.println(sum(1, 2, 3, 4, 5));//15
          }
          public static void print(int...values) { //values(here it is a vraible works as an array)
          	System.out.println(Arrays.toString(values));
          }
        
          public static int sum(int...values) {
          	int sum = 0;
          	for(int value : values){
          		sum += value;
          	} return sum;
          }	
        }
        ```
        
        - take a look at the Student class. when you get the second parameter of the Student constructor, you basically got it in the form of int array. Now, since you learned what variable arguments are, you can change the code as suggested below:
        
        ```java
        //constructor of the Student class
        public Student(String name, int...marks){
            this.name = name;
            this.marks = marks;
          }
        
        //creating instances of the student class in the main class
        Student student = new Student("Ranga", 97, 98, 99, 100, 89);
        Student student1 = new Student("Elisa", 99, 88, 60, 79, 90);
        														.
        														.
        														.
        														.
        ```
        
        **Exercise**
        
        - Create a string array with days of the week
            - “Sunday”, “Monday”, “Tuesday”, “Wednesday”, “Thursday”, “Friday”, “Saturday”
        - Find the day with most number of letters in it
            - Longest String
        - Sort days of the week array backwards
        
        my code →
        
        ```java
        import java.util.Arrays;
        
        public class Main {
          public static void main(String[] args) {
          String[] daysOfWeek = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
        
            System.out.println(getLongestDay(daysOfWeek)); //Saturday
            System.out.println(Arrays.toString(descendingSort(daysOfWeek))); //[Saturday, Friday, Thursday, Wednesday, Tuesday, Monday, Sunday]
          }	
          public static String getLongestDay(String...days){
            String maxDay = "Sunday";
            for(String day : days){
              int maxLen = 0;
              if(day.length() > maxLen){
                maxLen = day.length();
                maxDay = day;
              }
            } return maxDay;
          }
        
          public static String[] descendingSort(String...days){
            int n = days.length;
            for(int i = 0; i < days.length/2 ; i++){
              String temp = days[i];
              
              days[i] = days[n - i - 1];
        
              days[n - i - 1] = temp;
            } return days;
          }
        }
        ```
        
    
    Look back at the Student class we generated. now we want to add more features(methods) to the students class for the sake of functionality. we want to add these methods.
    
    ```java
    student.addNewMark(35);
    student.removeMarkAtIndex(5);
    ```
    
    doing this kind of stuff is not easy with arrays. this is when the ArrayList comes in handy.
    
    ```java
    import java.util.ArrayList;
    
    public class Main {
      public static void main(String[] args) {
        ArrayList arrayList = new ArrayList();
        arrayList.add("apple");
        arrayList.add("pear");
        arrayList.add(3);//can add different type, but not encouraged
        System.out.println(arrayList); //[apple, pear, 3]
    
        //how to create an arrayList with type identified.
        ArrayList<String> arrayList1 = new ArrayList<String>();
        arrayList1.add("my");
        arrayList1.add("name");
        arrayList1.add("is");
        arrayList1.add("lukas");
        System.out.println(arrayList1);//[my, name, is, lukas]
    		//using index to remove item
    		arrayList1.remove(0);
    		//using name to remove item
    		arrayList1.remove("name");
    		System.out.println(arrayList1);//[is, Lukas]
      }
    }
    ```
    
    below is the refactored code after we knew the existence of the ArrayList.
    
    ```java
    //main class
    import java.math.BigDecimal;
    
    public class Main {
      public static void main(String[] args) {
        int[] marks = {99, 98, 100, 97, 89};
    
        Student student = new Student("Ranga", marks);
    
        int number = student.getNumberOfMarks();
        System.out.println("number of marks : " + number);//5
    
        int sum = student.getTotalSumOfMarks();
        System.out.println("sum of marks : "+ sum);//483
    
        int maximumMark = student.getMaximumMark();
        System.out.println("maximum of marks : " + maximumMark);//100
    
        int minimumMark = student.getMinimumMark();
        System.out.println("minimum of marks : " + minimumMark);//89
    
        BigDecimal avg = student.getAverageMarks();
        System.out.println(avg);//96.6000
    
        student.addNewMark(35);
        student.removeMarkAtIndex(1);
    
        System.out.println(student);//before redefining toString() method: Student@119d7047
        //after: Ranga [99, 100, 97, 89, 35]
      }
    }
    ```
    
    ```java
    //Student class
    import java.math.BigDecimal;
    import java.math.RoundingMode;
    import java.util.ArrayList;
    import java.util.Collections;
    
    public class Student{
      private String name;
      private ArrayList<Integer> marks = new ArrayList<Integer>();
    
      public Student(String name, int...marks){
        this.name = name;
    
        for(int mark : marks){
          this.marks.add(mark);
        }
      }
    
      public int getNumberOfMarks(){
        return marks.size();
      }
    
      public int getTotalSumOfMarks(){
        int sum = 0;
        for(int mark : marks){
          sum+=mark;
        } return sum;
      }
    
      public int getMaximumMark(){
        return Collections.max(marks);
      }
    
      public int getMinimumMark(){
        return Collections.min(marks);
      }
    	
    	//changing toString() method to change how it's printed originally
      public String toString() {
        return name + " " + marks;
      }
    
      public void addNewMark(int i){
        marks.add(i); //add at the end
      }
    
      public void removeMarkAtIndex(int index){
        marks.remove(index);
      }
    
      public BigDecimal getAverageMarks(){
        int sum = getTotalSumOfMarks();
        int number = getNumberOfMarks();
        return new BigDecimal(Integer.toString(sum)).divide(new BigDecimal(Integer.toString(number)), 4, RoundingMode.UP);
      }
    }
    ```
    
- Abstraction
    
    **ABSTRACTION**
    
    An Abstraction is a process of exposing all the necessary details and hiding the rest. In Java, **Data Abstraction** is defined as the process of reducing the object to its essence so that only the necessary characteristics are exposed to the users.
    
    In JAVA, there are two different ways to attain abstraction: Abstract class & interface.
    
- Abstract
    
    **ABSTRACT**
    
    1. The abstract class is a class that contains the abstract method.
    2. The abstract method does not have a body. What’s in the body is determined by the subclass( the method is overridden in the subclass).
        1. An instance cannot be created directly from the abstract class.
            1. Ex) if Animal was an abstract class, Animal doggie = new Animal(); isn’t possible.
        2. To use an abstract class, it should be inherited by another class (using the “extends” keyword).
        3. The abstract class can have both abstract and regular methods.
        
- Interfaces
    
    **INTERFACES**
    
    1. An interface is completely an "**abstract class**" that is used to group related methods with empty bodies
    2. Interface methods do not have bodies and the interface should be “implemented” by another class using the “implements” keyword.
    3. An interface contains only methods (without bodies) and the methods are overridden in the classes that implement the interface.
    4. As long as all the methods from interfaces are overridden, a class can implement multiple interfaces.
    
- Lambda Expression
    - expressing a method into a simple version of the expression.
        
        ```java
        //below is an example of a method.
        int max(int a, int b) {
        	return a > b  ? a : b;
        }
        
        //below is an example of a Lambda Expression.
        (a, b) -> a > b ? a : b
        ```
        
    - Lambda Expression is an anonymous function, to be exact, an object because a reference variable is needed to use the Lambda function.
    - How to make a Lambda Expression.
        1. remove the return type & the name of the function.
        2. put an arrow between (type parameters) and the “{.”
        3. if there is a return type, you can omit the “return” and ‘;’ at the end.
            
            ```java
            //below is an example of a method.
            int max(int a, int b) {
            	return a > b  ? a : b;
            }
            
            //below is an example of a Lambda Expression.
            (a, b) -> a > b ? a : b
            ```
            
        4. if the type of parameters is inferrable, you can omit the type.
            
            ```java
            //below is an example of a method.
            int max(int a, int b) {
            	return a > b  ? a : b;
            }
            
            //below is an example of a Lambda Expression.
            //omitted the types(int) before the a, b in the ().
            (a, b) -> a > b ? a : b
            ```
            
        5. if there is only one parameter, you can omit the parentheses.
            
            ```java
            //Before
            (a) -> a*a
            //After
            a -> a*a
            //However, you cannot omit paratheses when there is the return type.
            (int a) -> a * a 
            //the following is an error.
            int a -> a * a //error.
            ```
            
        6. if there is only one executable statement in {}, you can omit it. AND! You shouldn’t put ‘;’ at the end.
            
            ```java
            //before
            (int i) -> {
            	System.out.println(i);
            }
            //after
            (int i) -> System.out.println(i)
            ```
            
    - Quizzes (conversion from normal methods to the Lambda Expressions)
        
        ```java
        //1.
        int max(int a, int b) {
        	return a > b ? a : b;
        }
        //I can convert this into...
        (a, b) -> a > b ? a : b
        
        //2.
        int printVar(String name, int i) {
        	System.out.println(name+"="+i);
        }
        //I can convert this into...
        (name, i) -> System.out.println(name+"="+i)
        
        //3.
        int square(int x) {
        	return x * x;
        }
        //I can convert this into...
        x -> x*x
        
        //4.
        int roll() {
        	return (int)(Math.random()*6);
        }
        //I can convert this into...
        () -> (int)(Math.random()*6)
        ```
        
    
- Functional Interface
    - functional interface - an interface where only one abstract method is declared.
        
        ```java
        // it's good to make an annotation above to check if you wrote the functional interface correctly.
        @FunctionalInterface
        interface MyFunction {
        		public abstract int max(int a , int b);
        }
        ```
        
        ```java
        MyFunction f = new MyFunction() {
        	public int max(Int a, int b) {
        		return a > b ? a : b;
        	}
        };
        
        int value = f.max(3,5); //OK. MyFunction 에 max() 가 있음.
        ```
        
        ```java
        //함수형 인터페이스 타입의 참조변수로 람다식을 참조할 수 있음.
        //(단, 함수형 인터페이스의 메서드와 람다식의 매개변수 개수와 반환타임이 일치해야함)
        MyFunction f = (a, b) -> a > b ? a : b;
        int value = f.max(3, 4); //실제로는 람다식(익명 함수) 이 호출 됨.
        ```
        
- encapsulation
    
    encapsulation is a concept that the class containing a certain variable should be the only class that can directly access to the instance variable, meaning other classes should call a specific method() to get the value of the instance variable of another class.
    
    HOW TO DO 
    
    1) make the instance variables private (so other classes cannot access to the variables directly).
    
    2) make a setter method in the class to which the instance variables are belong
    
    3) use the method in other classes to access to the variable(s).
    
    Now… you might wonder what is the value of the variables that were set by the setter method.
    
    here’s how to deal with the situation.
    
    1) make a getter method()
    
    2) make sure the getter method() returns this.<variable>
    
    3) a getter method() 
    
    WHAT’S GOOD ABOUT IMPLEMENTING THE ENCAPSULATION
    
    1) you can add the logic to the setter method() to prevent certain things. For instance, you can add the logic to prevent the speed from being set as a negative value.
    
    EXAMPLES
    
    ```java
    public class Main{
    	
    	public static void main(String[] args){
    		MotorBike bugati = new MotorBike();
    		MotorBike honda = new MotorBike();
    		
    		bugati.start(bugati);
    		honda.start(honda);
    		/*you cannot do this when the variable(s) you are trying to access is private.
    		bugati.speed = 50
    		honda.speed = 20
    		*/
    	
    		//using the setter method.
    		bugati.setSpeed(50);
    		honda.setSpeed(20);
    		
    		System.out.println(bugati.getSpeed());
    		System.out.println(honda.getSpeed());
    
    		bugati.increaseSpeed(100);
    		honda.increaseSpeed(100);
    
    		System.out.println(bugati.getSpeed());
    		System.out.println(honda.getSpeed());
    
    		bugati.decreaseSpeed(50);
    		honda.decreaseSpeed(50);
    
    		System.out.println(bugati.getSpeed());
    		System.out.println(honda.getSpeed());
    	
        }
    }
    
    public class MotorBike{
    	//state
    	private int speed;//member variable
    	
    	//behavior
    	public void start(MotorBike motorbike){
    		System.out.println(motorbike + " started");
    	}
    	public void setSpeed(int speed){ //local variable
    		if(speed >= 0) 
    			this.speed = speed;
    	}
        public void increaseSpeed(int howMuch){
    		//since setSpeed() already has the validation part, you can call it
    		//inside the increaseSpeed() method to check if the speed > 0.
    		setSpeed(this.speed += howMuch);
        }
    	public void decreaseSpeed(int howMuch){
    		setSpeed(this.speed -= howMuch);
    	}
    	public int getSpeed(){
    		return this.speed;
        }
    }
    ```
    
- BufferedReader
    - a lot of people use scanner to read data in java, but using BufferedReader make your program much faster.
    - BufferedReader gets data as String, therefore you need to convert data into whatever the form you want to get.
    - to use BufferedReader you need to import the followings.
        
        ```java
        import java.io.BufferedReader;
        import java.io.BufferedWriter;
        import java.io.InputStreamReader;
        import java.io.OutputStreamWriter;
        ```
        
    - you must do the exception handling
        
        people could do the exception handling every time they do the readLine() thing, but people normally do it by throwing IOException.
        
        - when you use throws IOException
        1. import class
            
            *import java.io.IOException;*
            
        2. throw IOException next to the main method.
            
            *public static void main(String[] args) throws IOException {}*
            
    - declaration & reading
        
        when you read data **by line**, you use readLine() method. Since readLine() reads String by default, if you want to get different type of data, you have to store the parsed data into a variable.
        
        ```jsx
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); //declariation
        String s = bf.readLine(); //String
        int i = Integer.parseInt(bf.readLine()); //Int
        
        ```
        
        when you read data **by space**, you use StringTokenizer. if you use nextToken() method, you can read the data achieved by readLine() by space. second way is to use split() method. 
        
        ```jsx
        StringTokenizer st = new StringTokenizer(s); //StringTokenizer인자값에 입력 문자열 넣음
        int a = Integer.parseInt(st.nextToken()); //첫번째 호출
        int b = Integer.parseInt(st.nextToken()); //두번째 호출
        
        String array[] = s.split(" "); //공백마다 데이터 끊어서 배열에 넣음
        ```
        
- this() in constructor
    
    when you use this() in one constructor, you basically call the other constructor.
    
    ```java
    public class Main{
    	
    	public static void main(String[] args){
    		Constructor c1 = new Constructor();
        Constructor c2 = new Constructor(100);
      
        System.out.println(c1.variable); //prints 5
        System.out.println(c2.variable); 
      }
    }
    
    public class Constructor{
      int variable;
    
      //default constructor
      public Constructor(){
        this(5);
      }
    
      public Constructor(int variable){
        this.variable = variable;
      }
    }
    ```
    
- New thingz
    
    **NEW THINS I GOT TO KNOW (KEEP ADDING)**
    
    1. substring() method
        
        ```jsx
        String out = “<<>>”`
        
        out.substring(0, 2);`
        ```
        
    2. charAt() method
        
        ```
        String myStr = "Hello";
        char result = myStr.charAt(0);
        System.out.println(result); 
        //returns H
        ```
        
    3. String.valueOf() & toString()
        1. So basically this method converts other types to the String type
        2. what is funny about the example of toString() below is that  `System.out.println(someObject)` calls that object's `toString()`
         function to convert the object to a string representation. If your object defines its own `toString()` function, then that is what will be called. If you don't provide such a function, then your object will inherit `toString()` from one of its parent classes. In the worst case, it will inherit `[Object.toString()](http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#toString())`. That version of toString() is defined to return 
        
        > a string consisting of the name of the class of which the object is an instance, the at-sign character `@', and the unsigned hexadecimal representation of the hash code of the object.
        > 
        
        Or, in other words:
        
        ```
        getClass().getName() + '@' + Integer.toHexString(hashCode())
        
        ```
        
        So, when you call `System.out.println()` on an object that doesn't define its own version of toString(), you might get the `Object` version which looks like "classname@someHexNumber".
        
        ```java
        /* example of String.valueOf method*/
        public class StringValueOf {
            public static void main(String[] args) {
                int i = 120;
                int j = 150;
                String i2 = String.valueOf(i);
                System.out.println(i2 + j);
            }
        } // returns 120150
        
        /*example of toString() method*/
        /**
         * This program is used to show the use of toString() method.
         * @author w3spoint
         */
        class Student{
        	String name;
        	String rollNo;
         
        	//constructor
        	Student(String name, String rollNo){
        		this.name = name;
        		this.rollNo = rollNo;
        	}
        }
         
        public class ToStringExample1 {
        	public static void main(String args[]){
        		//creating Student class object
        		Student stu1 = new Student("Sunil", "MCA/07/15");
        		Student stu2 = new Student("Sandy", "MCA/07/19");
        		Student stu3 = new Student("Roxy", "MCA/07/32");
         
        		//println internally call toString method
        		System.out.println(stu1);
        		System.out.println(stu2);
        		System.out.println(stu3);
        	}
        }
        // WHAT THIS RETURNS
        com.w3spoint.business.Student@1888759
        com.w3spoint.business.Student@6e1408
        com.w3spoint.business.Student@e53108
        
        /*This is when you make a method that returns a String value using toString().*/
        /**
         * This program is used to show the use of override toString method.
         * @author w3spoint
         */
        class Student{
        	String name;
        	String rollNo;
         
        	//constructor
        	Student(String name, String rollNo){
        		this.name = name;
        		this.rollNo = rollNo;
        	}
         
        	//Override toString method to get customized results.
        	public String toString(){
        		return "Name:" + name + ", RollNo: " + rollNo;
        	}
        }
         
        public class ToStringExample2 {
        	public static void main(String args[]){
        		//creating Student class object
        		Student stu1 = new Student("Sunil", "MCA/07/15");
        		Student stu2 = new Student("Sandy", "MCA/07/19");
        		Student stu3 = new Student("Roxy", "MCA/07/32");
         
        		//println internally call toString method
        		System.out.println(stu1);
        		System.out.println(stu2);
        		System.out.println(stu3);
        	}
        }
        // WHAT THIS RETURNS
        Name:Sunil, RollNo: MCA/07/15
        Name:Sandy, RollNo: MCA/07/19
        Name:Roxy, RollNo: MCA/07/32
        ```
        
    4. For-each loop
    
    ![Untitled](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Untitled%202.png)
    
    1. Instanceof
        
        This method is related to classes and interfaces.
        
        The `instanceof`
         keyword checks whether an object is an instance of a specific class or an interface. The example is below.
        
        The instanceof keyword compares the instance with type. The return value is either `true`
         or `false.`
        
        ```
        public class Main {
          public static void main(String[] args) {
            Main myObj = new Main();
            System.out.println(myObj instanceof Main); // returns true
          }
        }
        ```
        
    
    1. escape sequences
        
        you can find information about “역슬래쉬,” \ 
        
        [here](https://www.educative.io/answers/what-are-escape-sequences-in-java).
        
        | escape types | usage |
        | --- | --- |
        | \t | indent tabs |
        | \n | next line |
        | \r |  |
        | \” | prints “ |
        | \’ | prints ‘  |
        | \\ | prints \ |
        | \u16진수 |  |
        
- OOP(1)
    
    **Objects have state and behavior**
    
    Fan Class
    
    - State (Member Variables)
        - make;
        - radius;
        - color;
        - isOn;
        - speed;
    - Consructors
        - Fan(String make, double radius, String color)
    - Behavior(Member Methods)
        - void switchOn( )
        - void switchOff( )
        - void setSpeed( )
        - String toString( ) using String.format method
    
    ```java
    
    //main class
    import java.math.BigDecimal;
    
    public class Main {
      public static void main(String[] args) {
        Fan fan = new Fan("Manufacturer 1", 0.34567, "Green");
        System.out.println(fan);
        /*
        make - Manufacturer 1, radius - 0.345670, color - Green, isOn - false, speed - 0.000000
        */
        fan.switchOn();
        System.out.println(fan);
        fan.setSpeed(5);
        System.out.println(fan);
        fan.switchOff();
        System.out.println(fan);
      }
    }
    
    //Fan class
    //Student class
    import java.math.BigDecimal;
    import java.math.RoundingMode;
    import java.util.ArrayList;
    import java.util.Collections;
    
    public class Fan{
      private String make; //manufacturer
      private double radius; //wing of a fan
      private String color;
      
      private boolean isOn;
      private double speed;//0 to 5
    
      public Fan(String make, double radius, String color){
        this.make = make;
        this.radius = radius;
        this.color = color;
      }
    
      public Fan(boolean isOn, double speed){
        this.isOn = isOn;
        this.speed = speed;
      }
      //return the state. 
      //if you override the toString() method in java, say you created a student object
      //when you print the student obj in the console it will be printed as indicated in toString() method.
      public String toString(){
        return String.format("make - %s, radius - %f, color - %s, isOn - %b, speed - %f", make, radius, color, isOn, speed);
      }
    
      public void switchOn(){
        this.isOn = true;
        setSpeed(3); // default speed when the fan's on.
        System.out.println("the fan made by " + make + " started to move.");
      }
    
      public void switchOff(){
        this.isOn = false;
        setSpeed(0);
        System.out.println("the fan is off.");
      }
    
      public void setSpeed(int speed){
        this.speed = speed;
      }
    }
    ```
    
    ![Untitled](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Untitled%203.png)
    
    Rectangle class
    
    ```java
    //main class
    public class Main{
      public static void main(String[] args){
        Rectangle rectangle = new Rectangle(12, 23);
        System.out.println(rectangle);
        rectangle.setWidth(25);
        System.out.println(rectangle);
      }
    }
    
    //Rectangle class
    public class Rectangle {
      // state
      private int length;
      private int width;
    
      // constructor
      public Rectangle(int length, int width) {
        this.length = length;
        this.width = width;
      }
    
      // operations
      public int getLength() {
        return this.length;
      }
    
      public void setLength(int length) {
        this.length = length;
      }
    
      public int getWidth() {
        return this.width;
      }
    
      public void setWidth(int width) {
        this.width = width;
      }
    
      public int area() {
        return length * width;
      }
    
      public int perimeter() {
        return 2 * (length + width);
      }
    
      public String toString() {
        return String.format("length - %d, width - %d, area - %d, perimeter - %d", length, width, area(), perimeter());
      }
    }
    
    ```
    
    ![Untitled](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Untitled%204.png)
    
- OOP(2)
    
    **Object composition**
    
    having another class’ type as variables
    
    ```java
    //main class
    public class Main {
      public static void main(String[] args) {
        Address homeAd;
        Address workAd;
    
        //String doorNo, String streetInfo, String city, String zipCode
        homeAd = new Address("door number 1", "3296 MATHIESON #B DRIVE NE", "Atlanta", "30305");
        workAd = new Address("door number 2", "200 17th St NW", "Atlanta", "30363 ");
        Customer customer = new Customer("lukas", homeAd);
        customer.setWorkAddress(workAd);
        System.out.println(customer);
      }
    }
    
    //Address class
    public class Address {
      //state
      private String doorNo;
      private String streetInfo;
      private String city;
      private String zipCode;
      //creation
      public Address(String doorNo, String streetInfo, String city, String zipCode) {
      super();
      this.doorNo = doorNo;
      this.streetInfo = streetInfo;
      this.city = city;
      this.zipCode = zipCode;
      }
      //behaviors
    	//both the Address class and the Customer class overrided toString() method.
      public String toString() {
      return doorNo + ", " + streetInfo + ", " + city + " - " + zipCode;
      }
    }
    
    //Customer class
    public class Customer {
      //state
      private String name;
      private Address homeAddress;
      private Address workAddress;
    
      //creation
      //workAddress not mandatory for creaation
      public Customer(String name, Address homeAddress){
        this.name = name;
        this.homeAddress = homeAddress;
      }
    
      //behaviors
      //certain components of homeAddress and workAddress can be modified, not the name
      public void setHomeAddress(Address homeAddress){
        this.homeAddress = homeAddress;
      }
    
      public void setWorkAddress(Address workAddress){
        this.workAddress = workAddress;
      }
    
      public Address getHomeAddress(){
        return homeAddress;
      }
    
      public Address getworkAddress(){
        return workAddress;
      }
    	//both the Address class and the Customer class overrided toString() method.
      public String toString(){
        return String.format("Customer [%s] lives at [%s], works at [%s]", 
                             name, 
                             homeAddress, 
                             workAddress);
      }
    }
    ```
    
    ![Untitled](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Untitled%205.png)
    
    **Book class**
    
    ```java
    /* 
     *COMMENTED OUT PARTS ARE INNTIAL PLANS
     *Book book = new Book(123, "Objected Oriented Programming with Java", "Ranga");
     *book.addReview(new Review(10, "Great Book", 5));
     *book.addReview(new Review(101, "Awesome", 5));
     *System.out.println(book);
     */
    
    //main class
    public class Main {
      public static void main(String[] args) {
        Book book = new Book(123, "Objected Oriented Programming with Java", "Ranga");
        Review review1 = new Review(1, 5);
        review1.setReviewComment("great book.");
        Review review2 = new Review(101, 5);
        review2.setReviewComment("awesome.");
        
        book.addReview(review1);
        book.addReview(review2);
        System.out.println(book);
      }
    }
    
    //Book class
    import java.util.ArrayList;
    
    public class Book {
      int bookNum;
      String bookName;
      String author;
    	//innitiation of the review arr is needed to do the operations
    	//in the method defined in the book class.
      ArrayList<Review> reviewArr = new ArrayList<Review>();
    
      public Book(int bookNum, String bookName, String author){
        this.bookNum = bookNum;
        this.bookName = bookName;
        this.author = author;
      }
    
      public void addReview(Review review){
        reviewArr.add(review);
      }
    
      public String toString(){
        return String.format(" book number : %d\n book name : %s\n author : %s\n reviews: \n %s", bookNum, bookName, author, reviewArr.toString());
      }
    }
    
    //Review class
    public class Review{
      private int reviewNo, stars;//stars are out of five
      private String reviewComment;
      
      public Review(int reviewNo, int stars){
      //review number and the stars can be created by calling Review constructor.
        this.reviewNo = reviewNo;
        this.stars = stars;
      }
      //a setter for the reviewComment.
      public void setReviewComment(String reviewComment){
        this.reviewComment = reviewComment;
      }
      //a getter for the reviewComment.
      public String getReviewComment(){
        return this.reviewComment;
      }
    
      public String toString(){
        return String.format("review Number : %d\n review comment : %s \n stars : %d/5", reviewNo, reviewComment, stars);
      }
    }
    ```
    
    ![Untitled](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Untitled%206.png)
    
    **Inheritance**
    
    why do we use inheritance?
    
    1. to avoid the code duplication → when we have a multiple similar classes like student class&person class, there might be a lot of duplicating codes that are unnecessarily redundant.
    2. to make it easier to change duplicating variables → there might be variables that are functionally and nominally the same. By just changing variables in the parent class, you can affect the student classes as well.
    - subclass gets all the features of the parent class.
    - what happens in the background of java for every single class created by you is that it extends Object, meaning they have some default implementations → predefined methods available. ex) toString( ), hashCode( ), notify( )……..and more. All objects, including Arrays, implement this Object class.
    - constructors in inheritance:
        - say you set Person’s constructor as below.
            
            ```java
            public class Person {
            	public Person(){
            		System.out.println("Person's constructor");
            	}
            }
            ```
            
        - say you make a child class of a person and call the constructor of that class as below
            
            ```java
            public class Employee {
            	public Employee(){
            		System.out.println("Employee's constructor");
            	}
            }
            ```
            
        - What it prints is…
            
            ![Untitled](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Untitled%207.png)
            
        - the reason why it does this although there was no explicit identification for the super constructor is because a child class’ constructor implicitly calls the super class’ constructor. In child class, the super class’ constructor ( super ( ) ) is hidden. **However,** When there is no default constructor, a constructor without any parameter in the parenthesis, you should explicitly call the constructor in the child class.
    
    **Inheritance basics**
    
    public class Person name, phone, email
    
    - Student
        - college
        - class
    - Employee
        - title
        - employer
        - employeeGrade
        - salary
        - toString(print all values including those of Person)
    
    ```java
    //main class
    public class Main {
      public static void main(String[] args) {
        /*
        Student student = new Student();
        student.setName("Lukas");
        student.setEmail("nubddak3@gmail.com");
        */
    
        /*
        Student lukas = new Student();
        lukas.setName("Lukas");
        lukas.setEmail("nubddak3@gmail.com");
        lukas.setPhoneNumber("010-xxxx-xxxx");
        String value = lukas.toString();
        System.out.println(value);
        System.out.println(lukas);
        */
    
        Employee employee = new Employee("Lukas", "Mark Zuckerberg");
        employee.setEmail("nubddak3@gmail.com");
        employee.setPhoneNumber("010-xxxx-xxxx");
        employee.setEmployeeGrade('A');
        employee.setTitle("Chief Technology Officer");
        employee.setSalary(222161);
        System.out.println(employee);
      }
    }
    
    //Person class
    //the super class for both student and employee classes
    //as aforementioned, all the objects extends Object class
    public class Person extends Object{
      private String name;
      private String email;
      private String phoneNumber;
    
      public Person(String name){
        this.name = name;
      }
    
      public String getName(){
        return name;
      }
    
      public void setEmail(String email){
        this.email = email;
      }
    
      public String getEmail(){
        return email;
      }
    
      public void setPhoneNumber(String phoneNumber){
        this.phoneNumber = phoneNumber;
      }
    
      public String getPhoneNumber(){
        return phoneNumber;
      }
    	
      @Override
      public String toString(){
        return String.format(" name : %s\n email : %s\n phone number : %s\n",name, email, phoneNumber);
      }
    }
    
    //Employee class
    import java.math.*;
    //Emplyee class is the child class of the Person class.
    public class Employee extends Person{
      private String title;
      private String employerName;
      private char employeeGrade;
      private BigDecimal salary;
    
      public Employee(String name, String employerName){
        super(name);
        this.employerName = employerName;
      }
    
      public void setTitle(String title){
        this.title = title;
      }
    
      public String getTitle(){
        return title;
      }
    
      public String getEmployer(){
      return employerName;
      }
      
      public void setEmployeeGrade(char employeeGrade){
        this.employeeGrade = employeeGrade;
      }
    
      public char getEmployeeGrade(){
        return employeeGrade;
      }
      
      public void setSalary(int salary){
        this.salary = new BigDecimal(salary);
      }
    
      public BigDecimal getSalary(){
        return salary;
      }
      //override toString() to print all the values present in the class and the subclass.
      //to get something from the super class, you could use "super" keyword
    	//called parent class' overriden toString() method
      @Override
      public String toString(){
        return super.toString() + String.format(" title : %s\n employer name : %s\n employee grade : %s\n salary : %s", title, employerName, employeeGrade, salary.toString());
      }
    }
    
    //Student class
    public class Student extends Person {
      private String collegeName;
      private int year;
    
      public Student(String name, String collegeName){
        super(name);
        this.collegeName = collegeName;
      }
    
      public String getCollegeName(){
        return collegeName;
      }
    
      public void setYear(int year){
        this.year = year;
      }
    
      public int getYear(){
        return year;
      }
    }
    ```
    
    - for the second indented part in main class
    
    ![Untitled](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Untitled%208.png)
    
    **extends hierarchy**
    
    in java, you cannot do such a thing like…
    
    **public class Dog extends Pet, Animal{**
    
    **}**
    
    because java doesn’t allow a class to extend multiple classes.
    
    However, what java can do is the following.
    
    **public class Dog extends Pet{}**
    
    **Public class Pet extends Animal{}**
    
    a dog class can extends a Pet class that extends the Animal class.
    
    ```java
    //main class
    public class Main {
      public static void main(String[] args) {
        Dog dog = new Dog();
        dog.setDogKind("Maltiz");
        dog.setKind("Dog");
        dog.setPetShop("Love Pets");
        System.out.println(dog instanceof Dog);//true
        System.out.println(dog instanceof Pet);//true
        System.out.println(dog instanceof Animal);//true
    
        /*
         * you cannot do this because by doing this you say the type of your dog is Animal, not Dog.
         * Animal dog = new Dog();
         * you cannot use the methods defined in the subclasses
         * WHAT YOU CANNOT DO (BELOW)  
         * dog.setPetShop();
         * dog.setDogKind();
         * WHAT YOU CAN DO (BELOW)
         * dog.setKind();
        */
      }
    }
    
    //Animal class
    public class Animal{
      private String kind;
    
      public void setKind(String kind){
        this.kind = kind;
      }
    
      public String getKind(){
        return kind;
      }
    }
    
    //Dog class
    public class Dog extends Pet{
      private String dogKind;
    
      public void setDogKind(String dogKind){
        this.dogKind = dogKind;
      }
    
      public String getDogKind(){
        return dogKind;
      }
    }
    
    //Pet class
    public class Pet extends Animal{
      private String petShop;
    
      public void setPetShop(String petShop){
        this.petShop = petShop;
      }
    
      public String getPetShop(){
        return petShop;
      }
    }
    ```
    
- OOP(3)
    
    **abstract class**
    
    abstract class contains abstract methods that are to be implemented by the sub classes. In the sub classes, the abstract methods made in the super class are overridden.
    
    - you cannot create instances of the abstract classes.
    - an abstract class can extend another abstract class.
    - you can have non abstract methods in your abstract class.
    
    ```java
    //main class
    public class Main {
      public static void main(String[] args) {
        Dog dog = new Dog();
        dog.bark(); //Bow Bow
      }
    }
    
    //DogAbstract class
    abstract class DogAbstract{
      public abstract void bark();
    }
    
    //Dog class
    public class Dog extends DogAbstract {
      public void bark() {
        System.out.println("Bow Bow");
      }
    }
    ```
    
    ```java
    //main class
    public class Main {
      public static void main(String[] args) {
        Recipe1 recipe = new Recipe1();
        recipe.execute();
        /*
         * prepare dishe.
         * get the utensils.
         * do the dish.
         * clean up the utensils.
         */
      }
    }
    
    //AbstractRecipe class
    public abstract class AbstractRecipe{
    
      public void execute() {
        getReady();
        doTheDish();
        cleanUp();
      }
    
      abstract void getReady();
      abstract void doTheDish();
      abstract void cleanUp();
    }
    
    //Recipe1 class
    public class Recipe1 extends AbstractRecipe {
      void getReady() {
        System.out.println("prepare dish.");
        System.out.println("get the utensils.");
      }
    
      void doTheDish() {
        System.out.println("do the dish.");
      }
    
      void cleanUp() {
        System.out.println("clean up the utensils.");
      }
    }
    ```
    
    **Interfaces**
    
    abstract classes and interfaces are very different. when you think about the interfaces, think about  a gaming console. the gaming console is connected to the screen and whatever you are playing in the screen each buttons has different functionalities for each game. This is exactly how interfaces work in java. all the methods in the interface are abstract. In other words, the interface contains only method declarations(this doesn’t mean it cannot have fields. It means all the methods declared in the interfaces are abstract). In java, interfaces don’t need to explicitly declare a method as abstract.
    
    ex) 
    
    ```java
    public interface MediaPlayer {
    	//these methods are automatically abstract.
    		void play(); 
    		void pause();
    }
    
    public class AudioMediaPlayer implements MediaPlayer {
        @Override
        public void play() {
            System.out.println("AudioMediaPlayer is Playing");
        }
        @Override
        public void pause() {
            System.out.println("AudioMediaPlayer is Paused");
        }
    }
    ```
    
    - polymorphism can be guaranteed by using interfaces.
    
    ```java
    //main class
    public class Main {
      public static void main(String[] args) {
        MarioGame game = new MarioGame();
        game.up();
        game.down();
        game.left();
        game.right();
    
        ChessGame game1 = new ChessGame();
        game1.up();
        game1.down();
        game1.left();
        game1.right();
      }
    }
    
    //GamingConsole interface
    public interface GamingConsole {
      public void up();
      public void down();
      public void left();
      public void right();
    }
    
    //chess game
    public class ChessGame implements GamingConsole{
      public void up() {
        System.out.println("move piece up.");
      }
      @Override
      public void down() {
        System.out.println("move piece up.");
      }
      @Override
      public void left() {
        System.out.println("move piece left.");
      }
      @Override
      public void right() {
        System.out.println("move piece right.");
      }
    }
    
    //mario game
    public class MarioGame implements GamingConsole{
      public void up() {
        System.out.println("Jump.");
      }
      @Override
      public void down() {
        System.out.println("Goes into a hole.");
      }
      @Override
      public void left() {
        System.out.println("Go left.");
      }
      @Override
      public void right() {
        System.out.println("Go right.");
      }
    }
    ```
    
    - the variables you define in the interface is not really “variables.” What you are defining is “constants.” **public static final** is the defined constant’s default type, meaning you can access to the constants everywhere without making a new object of a class.
    
    WHAT YOU CAN’T DO
    
    ```java
    public interface Interface1{
    //you cannot do this becasue you have to give a constant a value
    //that is immutable
    		String str;
    }
    ```
    
    - you can add an implementation to the method defined in the interface, making it a default method called before it is overridden in the sub classes. you cannot add implementations to the method inside the interface with the earlier version of java than java 8. When you do this, **you have to make sure you put the default access modifier!!!!**
    
    ```java
    interface Interface4 {
      **default** void print(){
        System.out.println("default");
      }
    }
    ```
    
    - this “adding default access modifier” technique can be effectively used when you do not want some of the sub classes of the interface to override all the methods from the super class. By defining a default method, you can open the door to two possibilities: **override it or nah.**
    
    **Using Interfaces To Design APIs**
    Consider a Software Development project, which involves programming a fairly large and complex application. Project team (Team A) decided to out-source part of this project to an external team (Team B). Let's say this external team needs to implement a fairly complex algorithm to achieve a specific task, and which needs to interface with the rest of the application. Work on both parts of the application needs to proceed simultaneously. Suppose the algorithm logic is implemented using a single method:
    `int complexAlgorithm(int number1, int number2);`
    
    How do we ensure that the work done by both the teams remains compatible? They start with defining interface. 
    
    ***ComplexAlgorithm.java***
    
    ```java
    public interface ComplexAlgorithm {
    	public int complexAlgorithm(int number1, int number2);
    }
    ```
    
    Now the teams can go on their merry way. Team A can create a stub for the interface `oneComplexAlgoritm` and start working on their project. 
    
     ***OneComplexAlgorithm.java***
    
    ```java
    public class OneComplexAlgorithm implements ComplexAlgorithm {
    	public int complexAlgorithm(int number1, int number2) {
    		return number1 + number2;
    	}
    }
    ```
    
    Team B can take time to implement the actual algorithm.
    
    ***ActualComplexAlgorithm.java***
    
    ```java
    public class ActualComplexAlgorithm implements ComplexAlgorithm {
    	public int complexAlgorithm(int number1, int number2) {
    		return number1*number2;
    	}
    }
    ```
    
    **tips to handle interface**
    
    - an interface can extend another interface.
    - a concrete class which implemented the interface that extended another interface has to override all the methods in both interfaces.
    - to prevent this, you could use a default access modifier as aforementioned.
    
    ```java
    //Interface one
    public interface InterfaceOne{
      void method1();
    }
    
    //Interface two
    public interface InterfaceTwo extends InterfaceOne{
      void method2();
    }
    
    //Concrete class
    public class ConcreteClass implements InterfaceTwo{
          @Override
        public void method1(){
          System.out.println("method1");
        }
      //also have to override method2 from the interface2 becasue the interface1 extends the interface 2.
        @Override
        public void method2(){
          System.out.println("method2");
        }
    }
    
    //ImplementationAbstract class
    abstract class ImplementationAbstract implements InterfaceTwo{
      //if you implement the interface that extends another interface to an ABSTRACT CLASS, you can override however many methods you want, but the sub classes of that abstract classes have to contain(override) every method defined in the higher hierarchy.
      
      @Override
      public void method1(){
        System.out.println("this method is from the interface1 which had gotten extended by the interface2 which had gotten implemented by an abstract class.");
      }
    }
    ```
    
- Interface v. Abstract class
    
    when we compare interfaces and abstract classes, we might say, “These two are so similar.” I would say, “Yes, they look similar when it comes to syntax, but they are different in functionality.”
    
    **when do I use interface?**
    
    → when I want to establish a **communication pattern** between two classes(systems, components, etc.)
    
    **When do I use Abstract classes?**
    
    → when we want to create an high-level structure, leaving the implementation details to the sub classes. When I want to ensure that all the sub classes meet the structure of a super class.
    
    - a class can implement a multiple interfaces.
        
        ```java
        public class ArrayLis<E> extends AbstractList<E> implements List<E>, 
        		RandomAcess, Cloneable, java.io.Serializable{ ....
        ```
        
- Exercises on Interface and Abstract Class
    
    **Interface**
    
    interface Flyable
    
    - void fly();
    - Bird “with wings”
    - Aeroplane “with fuel”
    - Flyable flyingObjects = {new Bird(), new Aeroplane()};
    - Loop and invoke fly method
    
    ```java
    //main class
    public class Main{
      public static void main(String[] args) {
      //you can do this!
      //Flyable aeroplane = new Aeroplane();
        Flyable[] flyingobjects = { new Bird(), new Aeroplane()};
        for(Flyable object : flyingobjects){
          object.fly();
          /*
          fly with wings.
          fly with fuel.
          */
        }
      }
    }
    
    //Aeroplane class
    public class Aeroplane implements Flyable{
      @Override
      public void fly(){
        System.out.println("fly with fuel.");
      }
    }
    
    //Bird class
    public class Bird implements Flyable{
      @Override
      public void fly(){
        System.out.println("fly with wings.");
      }  
    }
    
    //Flyable interface
    public interface Flyable{
      void fly();
    }
    ```
    
    **Abstract Class**
    
    - void bark()
    - Dog “Bow Bow”
    - Cat “Meow Meow”
    - Animal[] animals = {new Cat(), new Dog()};
    - Loop and invoke bark method
    
    ```java
    //main class
    public class Main{
      public static void main(String[] args) {
        Animal[] animals = { new Cat(), new Dog() };
        for(Animal animalObj : animals){
          animalObj.bark();
          /*
          Meow Meow
          Bow Bow
          */
        }
      }
    }
    
    //Animal class
    public abstract class Animal{
      private String kind;
    
      public void setKind(String kind){
        this.kind = kind;
      }
    
      public String getKind(){
        return kind;
      }
    
      public abstract void bark();
    }
    
    //Cat class
    public class Cat extends Animal{
      @Override
      public void bark(){
        System.out.println("Meow Meow.");
      }
    }
    
    //Dog class
    public class Dog extends Animal {
      @Override
      public void bark() {
        System.out.println("Bow Bow");
      }
    }
    ```
    
- Collections
    - The Collection Framework Hierarchy
        
        ![Untitled](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Untitled%209.png)
        
    - What is a collection framework?
        - a collection is an integration of the classes that deals with data and data structures.
        - the collection is very useful in that it provides classes and methods that are essential for dealing with data. You have to especially be good at this.
        - every class in the collection framework is a class or an interface that implements the Collection interface.
    - Collection interface and Data Structures
        
        The Collection interface is an interface that all the data structures implement. All the data structures below implement the collection.
        
        1. **List:** A List is a set of data that has a sequence/order in data and allows the overlaps between the data.
            
            → ArrayList, LinkedList, Stack. etc.
            
        2. **Set:** A Set is a set of data that does not have any sequence in them and does not allow overlaps between data.
            
            → HashSet, TreeSet, etc.
            
        3. **Map:** A Map is a set of data that has two values: “Key”&” Value.” The sequence is not consistent and the “key” does not allow an overlap, while “value” can be overlapped.
            
            → HashMap, TreeMap, etc.
            
        4. **Stack:** This data structure pulls out data starting from the last inputted datum from the stack. 마지막에 넣은 데이터를 먼저 꺼낸다. (LIFO - Last In First Out)
            
            → Stack, ArrayDeque, etc.
            
            ![Untitled](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Untitled%2010.png)
            
        5. **Queue:** This data structure pulls out data starting from the first inputted datum from the queue. 먼저 넣은 데이터를 먼저 꺼낸다. (FIFO - First In First Out)
            
            → Queue, ArrayDeque, etc.
            
            ![Untitled](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Untitled%2011.png)
            
        
    - List, Set, Map
        - 1) **List** Interface
            
            The List represents the listed data with the sequence in them.
            
            - the simplest way to make a List (this is available from java 9)
                
                ```java
                List<String> words = List.of("Apple", "Bat", "Cat");
                ```
                
            - ArrayList is an interface that contains data using the List.
            
            ```java
            public class Main {
                public static void main(String[] args) {
                    List list = new ArrayList(10);
                    list.add(1);
                    list.add(5);
                    list.add(4);
                    list.add(11);
                    list.add(10); // ArrayList에 값 한개씩 입력
            				/*List<Integer> = List.of(1, 5, 4, 11, 10);
            				  does the same thing*/
                    System.out.println(list); // [1,5,4,11,10]
            
                    Collections.sort(list); // list 정렬
                    System.out.println(list); // [1,4,5,10,11]
            
                    System.out.println(list.size()); // arrayList의 크기 출력
            
                    arrayList.remove(4); // 인덱스를 활용하여 해당하는 값 제거
                    System.out.println(list);
            				
            				System.out.println(list.contains(90)); //false
            
                    for (int i = 0; i < list.size(); i++) {
                        System.out.println(list.get(i)); // get을 이용하여 값 1개씩 출력
                    }
            				for (int current : list) {
            						System.out.println(current);
                    }
            
                }
            }
            ```
            
            - List created by of() function is immutable, meaning it cannot change.
            - if you want to create a list that is mutable, you have to create either ArrayList, LinkedList, or Vector
            
            ```java
            import java.util.ArrayList;
            import java.util.LinkedList;
            import java.util.Vector;
            import java.util.List;
            
            public class Main{
              public static void main(String[] args){
                List<String> words = List.of("dog", "cat", "lion"); //new 안 붙임.
                //you can make different kinds of Lists using a list created.
                List<String> wordsArrayList = new ArrayList<String>(words);
                List<String> wordsLinkedList = new LinkedList<String>(words);
                List<String> wordsVector = new Vector<String>(words);
                //if you make either ArrayList, LinkedList, or Vector, they are mutable.
                wordsVector.add("tiger");
                System.out.println(wordsVector);//[dog, cat, lion, tiger]
              }
            }
            ```
            
            - if we are wondering what to choose among ArrayList, LinkedList, and Vector, we need to see what operations(just like .add()) each type support.
            
            **ArrayList v. LinkedList**
            
            - Underneath ArrayList & Vector, the basic data structure used is an array. The LinkedList, however, has its basic data structure as LinkedList.
            - With an array, inserting and deleting elements is very time-consuming because you would have to move all the elements back or forward to do so. However, accessing a value from the array is very fast because of its index system.
            - In LinkedList, there is a header pointing(referring) to a node. Depending of the size of the list, each node has data and “pointer” that points to another node. This is how LinkedList is formed. When inserting and deleting values from the LinkedList, we can just change the links between nodes, which is very convenient. However, since LinkedList does not use the index system as ArrayList does, accessing a value from the List requires sequential search, meaning LinkedList is very slow when accessing a certain element of the List.
            
            ```java
            class ArrayList implements List<E>{
            	//insertion and deletion are slower compared to LinkedList
            	//almost constant time-access
            }
            
            class LinkedList implements List<E>{
            	//elements are doubly linked - forward and backward
            	//iteration is slower than ArrayList
            	//faster insertion and deletion
            }
            ```
            
            **ArrayList v. Vector**
            
            Vector is synchronized, meaning only one thread can access to the Vector at a time, while ArrayList is not synchronized, meaning multi-threads can access at the same time.
            
            Thread Safe → in multi-thread programming, although different kinds of thread access at a time, there’s no problem for the program to run.
            
            - Vector is thread safe
            - ArrayList is not thread safe
            
            ```java
            class ArrayList implements List<E>{
            	//insertion and deletion are slower compared to LinkedList
            	//almost constant time-access
            }
            
            class Vector implements List<E>{
            	//Thread Safe - Synchronized Methods
            	//almost constant time - access
            }
            ```
            
            **practice**
            
            | boolean | https://docs.oracle.com/javase/8/docs/api/java/util/List.html#add-E-(https://docs.oracle.com/javase/8/docs/api/java/util/List.html e)Appends the specified element to the end of this list (optional operation). |
            | --- | --- |
            | void | https://docs.oracle.com/javase/8/docs/api/java/util/List.html#add-int-E-(int index, https://docs.oracle.com/javase/8/docs/api/java/util/List.html element)Inserts the specified element at the specified position in this list (optional operation). |
            | boolean | https://docs.oracle.com/javase/8/docs/api/java/util/List.html#addAll-java.util.Collection-(https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html<? extends https://docs.oracle.com/javase/8/docs/api/java/util/List.html> c)Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection's iterator (optional operation). |
            | boolean | https://docs.oracle.com/javase/8/docs/api/java/util/List.html#addAll-int-java.util.Collection-(int index, https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html<? extends https://docs.oracle.com/javase/8/docs/api/java/util/List.html> c)Inserts all of the elements in the specified collection into this list at the specified position (optional operation). |
            | E | remove(int index)Removes the element at the specified position in this list (optional operation). |
            | boolean | remove(Object o)Removes the first occurrence of the specified element from this list, if it is present (optional operation). |
            | boolean | removeAll(Collection<?> c)Removes from this list all of its elements that are contained in the specified collection (optional operation). |
            | E | set(int index, E element)Replaces the element at the specified position in this list with the specified element (optional operation). |
            
            ```java
            import java.util.ArrayList;
            import java.util.LinkedList;
            import java.util.Vector;
            import java.util.List;
            
            public class Main{
              public static void main(String[] args){
                List<String> words = List.of("dog", "cat", "lion"); //new 안 붙임.
                //you can make different kinds of Lists using a list created.
                List<String> wordsArrayList = new ArrayList<String>(words);
                List<String> wordsLinkedList = new LinkedList<String>(words);
                List<String> wordsVector = new Vector<String>(words);
                //if you make either ArrayList, LinkedList, or Vector, they are mutable.
                wordsVector.add("tiger");
                System.out.println(wordsVector);//[dog, cat, lion, tiger]
                //some operations (doesn't really change among different kinds of lists.)
                wordsArrayList.add("elephant");
                System.out.println(wordsArrayList);//[dog, cat, lion, elephant]
                wordsArrayList.add(2, "ball"); //(index, "element")
                System.out.println(wordsArrayList);//[dog, cat, ball, lion, elephant]
                //list allows duplicates
                wordsArrayList.add("ball");
                System.out.println(wordsArrayList);//[dog, cat, ball, lion, elephant, ball]
                //adding a collection to the list
                List<String> newList = List.of("yak", "zebra");
                wordsArrayList.addAll(newList);//you can also specify the index with addAll()
                System.out.println(wordsArrayList);//[dog, cat, ball, lion, elephant, ball, tak, zebra]
                wordsArrayList.set(6, "fish");
                System.out.println(wordsArrayList);//[dog, cat, ball, lion, elephant, ball, fish, zebra]
                wordsArrayList.remove(2);
                System.out.println(wordsArrayList);//[dog, cat, lion, elephant, ball, fish, zebra]
                wordsArrayList.remove("dog");
                System.out.println(wordsArrayList);//[cat, lion, elephant, ball, fish, zebra]
              }
            }
            ```
            
            ```java
            import java.util.ArrayList;
            import java.util.LinkedList;
            import java.util.Vector;
            import java.util.List;
            
            public class Main{
              public static void main(String[] args){
                List<Integer> intList1 = List.of(1, 2, 3);
                List<Integer> intList2 = List.of(4, 5, 6);
                List<Integer> intList3 = List.of(7, 8, 9);
                List<Integer> mergeList = new ArrayList(intList1);
                mergeList.addAll(intList2);
                mergeList.addAll(intList3);
                System.out.println(mergeList);//[1, 2, 3, 4, 5, 6, 7, 8, 9]
              }
            }
            ```
            
            **iterating elements in List**
            
            ```java
            import java.util.List;
            import java.util.Iterator;
            
            public class Main {
              public static void main(String[] args) {
                List<String> words = List.of("Apple", "Bat", "Cat");
                //most normal for loop
                for(int i = 0; i < words.size(); i++){
                  System.out.println(words.get(i));
                }
                //inhanced for loop
                for(String word : words){
                  System.out.println(word);
                }
                //using Iterator
                Iterator wordsIterator = words.iterator();
                while(wordsIterator.hasNext()){
                  System.out.println(wordsIterator.next());
                }
              }
            }
            ```
            
            | boolean | https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#endsWith(java.lang.String)(https://docs.oracle.com/javase/7/docs/api/java/lang/String.html suffix)Tests if this string ends with the specified suffix. |
            | --- | --- |
            | boolean | startsWith(String prefix)Tests if this string starts with the specified prefix. |
            | boolean | startsWith(String prefix, int toffset)Tests if the substring of this string beginning at the specified index starts with the specified prefix. |
            | https://docs.oracle.com/javase/7/docs/api/java/lang/String.html |  |
            
            ```java
            import java.util.ArrayList;
            import java.util.List;
            import java.util.Iterator;
            
            public class Main {
              public static void main(String[] args) {
                List<String> words = List.of("Apple", "Bat", "Cat");
                List<String> wordsAl = new ArrayList<String>(words);
            
                for (String word : words) {
                  if (word.endsWith("at")) {
                    System.out.println(word);
                  }
                }
            
                for (String word : wordsAl) {
                  if (word.endsWith("at")) {
                    wordsAl.remove(word);
                  }
                }
                System.out.println(wordsAl);// [Apple, Cat]
                **/*
                 * we wanted to remove all the String elements
                 * thatends with "at", but it ended up not happening.
                 * that's becasue an inhanced for loop isn't recommended for
                 * being used when deleting elements. That's becasue deleting words
                 * results in the change in the process of iteration.
            		 * meaning the iteration might not happen as it should.
                 * in this case, you should use the iterator.
                 */**
            		Iterator<String> iterator = wordsAl.iterator();
                while(iterator.hasNext()){
                  if(iterator.next().endsWith("at")){
                    iterator.remove();
                  }
                }
                System.out.println(wordsAl);//[Apple]
              }
            }
            ```
            
            - **In a list, you cannot store primitives**
            - when we make a list of different data types, each elements are auto boxed into the wrapper class forms.
            - proof below
            
            ```java
            import java.util.ArrayList;
            import java.util.List;
            import java.util.Iterator;
            
            public class Main {
              public static void main(String[] args) {
                List value = List.of("A", 'A', 1, 1.0);
                System.out.println(value.get(0) instanceof String);//true
                System.out.println(value.get(1) instanceof Character);//true
                System.out.println(value.get(2) instanceof Integer);//true
                System.out.println(value.get(3) instanceof Double);//true
            		//if I want my List to have only a specific kind of values,
            		//the generalization is made between < and >.
            		List<String> textValues = List.of("only", "String", "is", "allowed");
            		List<Integer> numbers = List.of(101, 102, 103, 104);
            		System.out.println(numbers.indexOf(101));//0
            		//creating an ArrayList containing the numbers (list)
            		List<Integer> numbersAl = new ArrayList<>(numbers);
            		System.out.println(numbersAl.indexOf(101));//0
            		/*
            		numbersAl.remove(101); 
            		* this causes IndexOutOfBoundsException.
            		* that's because when a primitive type(int type)
            		* is used as the parameter, remove() method looks for the 
            		* position(index). To remove the specific element,
            		* you should use a wrapper class to remove it.
            		*/
            		numbersAl.remove(Integer.valueOf(101));
            		System.out.println(numbersAl);//[102, 103, 104]
            		//https://m.blog.naver.com/sthwin/221000179980
            		//above is the explanation of the difference
            		//between valueOf and parseInt.
              }
            }
            ```
            
            | https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html | https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#remove-int-(int index)Removes the element at the specified position in this list. |
            | --- | --- |
            | boolean | https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#remove-java.lang.Object-(https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html o)Removes the first occurrence of the specified element from this list, if it is present. |
            
            **sorting Lists**
            
            - the most common way to sort the array is to use Collections.sort() method. the method is static.
                
                ```java
                import java.util.ArrayList;
                import java.util.List;
                import java.util.Collections;
                import java.util.Iterator;
                
                public class Main {
                  public static void main(String[] args) {
                    List<Integer> list = List.of(101, 6, 3, 10, 9, 202, 5, 2, 2, 2);
                    //since the list generated above is immutable, we create the ArrayList
                    List<Integer> listAl = new ArrayList<>(list);
                    Collections.sort(listAl);
                    System.out.println(listAl);//[2, 2, 2, 3, 5, 6, 9, 10, 101, 202]
                  }
                }
                ```
                
                **in the Integer class**
                
                | static int | https://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#compare(int,%20int)(int x, int y)Compares two int values numerically. |
                | --- | --- |
                | int | https://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#compareTo(java.lang.Integer)(https://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html anotherInteger)Compares two Integer objects numerically. |
                
                **in the Collection class**
                
                | static <T extends https://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html<? super T>> void | https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#sort(java.util.List)(https://docs.oracle.com/javase/7/docs/api/java/util/List.html<T> list)Sorts the specified list into ascending order, according to the https://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html of its elements. |
                | --- | --- |
                
                ```java
                import java.util.ArrayList;
                
                public class Student implements Comparable<Student>{
                  private int id;
                  private String name;
                
                  public Student(int id, String name){
                    super();
                    this.id = id;
                    this.name = name;
                  }
                
                  public void setId(int id){
                    this.id = id;
                  }
                  public int getid(){
                    return id;
                  }
                  public void setName(String name){
                    this.name = name;
                  }
                  public String getName(){
                    return name;
                  }
                  @Override
                  public String toString(){
                    return String.format("stu id of %d & stu name of %s", id, name);
                  }
                  @Override
                  public int compareTo(Student that){
                    return Integer.compare(this.id, that.id);
                		//descending order
                		//return Integer.compare(that.id, this.id);
                  }
                }
                
                //main class
                import java.util.ArrayList;
                import java.util.List;
                import java.util.Collections;
                import java.util.Iterator;
                
                public class Main {
                  public static void main(String[] args) {
                    // creating a list of students
                    List<Student> listOfStu = List.of(new Student(202, "Lukas"), new Student(5, "James"), new Student(101, "Jay"));
                    System.out.println(listOfStu);
                    /*
                     * [stu id of 202 & stu name of Lukas,
                     * stu id of 5 & stu name of James,
                     * stu id of 101 & stu name of Jay]
                     */
                    // try to sort the student list
                    List<Student> listOfStuAl = new ArrayList<>(listOfStu);
                    Collections.sort(listOfStuAl);
                    System.out.println(listOfStuAl);
                		/*
                     * [stu id of 5 & stu name of James,
                     * stu id of 101 & stu name of Jay,
                     * stu id of 202 & stu name of Lukas]
                     */
                  }
                }
                ```
                
                - brief explanation of this code above:
                    
                    If we want to use sort method from the Collection class, we have to put a parameter as a list of “Comparable” values. That means we could implement the Comparable interface and override the method inside the interface inside the class (could be any class) that we want to make a list of and sort. In Comparable Interface, there is one abstract method called compareTo(), meaning we can sort the list of the intended Type by overriding the compareTo() method.
                    
                    **in** **Interface Comparable<T>**
                    
                    | int | https://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html#compareTo(T)(https://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html o)Compares this object with the specified object for order. |
                    | --- | --- |
                    - what you should do when you want to sort in the order of your appetite
                        
                        there is another sort() method defined in Collection class in java.
                        
                    
                    | public static <T> void | sort(List<T> list,  Comparator<? super T> c) sorts the specified list according to the order induced by the specified comparator. |
                    | --- | --- |
                    
                    Comparator Interface has two predefined methods, 
                    
                    **`[compare](https://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html#compare(T,%20T))**(**[T](https://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html)** o1, **[T](https://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html)** o2)` & `**[equals](https://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html#equals(java.lang.Object))**(**[Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html)** obj)` .
                    
                    equals() method, however, was implemented from the Object class which every possible class extends, therefore when you implement the Comparator Interface it will be implemented automatically. All you need to do is overriding compare() method.
                    
                    when you see the api of ArrayList, there is a sort() method defined like this.
                    
                    | void | sort(Comparator<? super E> c) sorts this list according to the order induced by the specified Comparator. |
                    | --- | --- |
                    
                    you can understand this api as you can sort the arraylist according to your favor by implementing a Comparator Interface to a class where you will override the compare(T o1, T o2) method. What’s inside the sort as a parameter is an object of a class that implemented the comparator interface.
                    
                    ```java
                    import java.util.ArrayList;
                    import java.util.List;
                    import java.util.Collections;
                    import java.util.Iterator;
                    
                    public class Main {
                      public static void main(String[] args) {
                        // creating a list of students
                        List<Student> listOfStu = List.of(new Student(202, "Lukas"), new Student(5, "James"), new Student(101, "Jay"));
                        System.out.println(listOfStu);
                        /*
                         * [stu id of 202 & stu name of Lukas,
                         * stu id of 5 & stu name of James,
                         * stu id of 101 & stu name of Jay]
                         */
                        // try to sort the student list
                        List<Student> listOfStuAl = new ArrayList<>(listOfStu);
                        Collections.sort(listOfStuAl);
                        System.out.println("ascending order: " + listOfStuAl);
                        /*
                         * [stu id of 5 & stu name of James,
                         * stu id of 101 & stu name of Jay,
                         * stu id of 202 & stu name of Lukas]
                         */
                        Collections.sort(listOfStuAl, new DescendingStudentComparator());
                        System.out.println("descending order: " +listOfStuAl);
                        /*
                         * [stu id of 202 & stu name of Lukas,
                         * stu id of 101 & stu name of Jay,
                         * stu id of 5 & stu name of James]
                         */
                        //YOU COULD DO THIS INSTEAD
                        listOfStuAl.sort(new DescendingStudentComparator());
                        System.out.println("descending order: " +listOfStuAl);
                        /*
                         * [stu id of 202 & stu name of Lukas,
                         * stu id of 101 & stu name of Jay,
                         * stu id of 5 & stu name of James]
                         */
                      }
                    }
                    ```
                    
        - HashTable(just a brief explanation)
            
            Hashtable takes a completely different approach on how it stores elements. It tries to combine the fixed positions similar to an Array and the advantages of the LinkedList. Let’s see the structure of the HashTable.
            
            ![Untitled](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Untitled%2012.png)
            
            here we have 7 different positions. we call it “buckets” and we get to store elements into each of these buckets. We store the values into the buckets by using hashing function. [explanation](https://www.geeksforgeeks.org/hashing-in-java/)
            
            Let’s say, we would want to decide where we want to store 15, which bucket do we want to store 15. what we would do is, we will evaluate the hashing function. the hashing function we are using here is Mod 7. we would divide by 7 and take the remainder and put the element in that bucket. ex) 15 Mod 7 is 1. Now we want to put 8 into the bucket. 8 Mod 7 is 1. There is already 15 present in the location of 1. So, what we would do is, we would attach 8 to this list.
            
            the deletion and search for a value will go through the same process (going through the hashing function).
            
            - the efficiency of the HashTable will always depend on the efficiency of the hashing function.
            
            In java, we would implement the hashing function using something called hashcode. If we look at the object class, there is a method called hashcode(). That hashcode is used to determine which bucket an object gets stored into. The Hashing function we aer using here, Mod 7, is just an example.
            
        - Tree (just a brief explanation)
            
            The awesome thing about tree is that it helps us store elements in a sorted order. A tree contains nodes and 2 pointers. These two pointers are the left child and the right child of the parent node. Let me understand the terms of tree in detail.
            
            ![Untitled](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Untitled%2013.png)
            
            - **Root:** The root of a tree is the topmost node of the tree that has no parent node. There is only one root node in every tree.
            - **Parent Node:** The node which is a predecessor of a node is called the parent node of that node.
            - **Child Node:** The node which is the immediate successor of a node is called the child node of that node.
            - **Sibling:** Children of the same parent node are called siblings.
            - **Edge:** Edge acts as a link between the parent node and the child node.
            - **Leaf:** A node that has no child is known as the leaf node. It is the last node of the tree. There can be multiple leaf nodes in a tree.
            - **Subtree:** The subtree of a node is the tree considering that particular node as the root node.
            - **Depth:** The depth of the node is the distance from the root node to that particular node.
            - **Height:** The height of the node is the distance from that node to the deepest node of that subtree.
            - **Height of tree:** The Height of the tree is the maximum height of any node. This is the same as the height of the root node.
            - **Level:** A level is the number of parent nodes corresponding to a given node of the tree.
            - **Degree of node:** The degree of a node is the number of its children.
            - **NULL:** The number of NULL nodes in a binary tree is (N+1), where N is the number of nodes in a binary tree.
            
            A tree helps in reducing the cost of search, delete, and also inserts, while keeping the data in a sorted way.
            
        - 2) **Set** Interface
            - A Set does not maintain the sequence and the overlaps among data.
            - with the Set, you will not be able to do add and remove data based on the position.
            - Set Interface
            
            ```java
            // Unique things only - Does not allow duplication
            // If obj1.equals(ob2) then only one of them can be in the Set
            interface Set<E> extends Collection<E> {
            
            }
            ```
            
            - Set, by default, is immutable. that’s why you create and utilize other mutable sets.
            
            ```java
            import java.util.Set;
            import java.util.HashSet;
            
            public class Main {
              public static void main(String[] args){
                Set<String> set = Set.of("Apple", "Banana", "Cat");
                Set<String> hashSet = new HashSet<>(set);
            		//now you can make changes to hashSet.
              }
            }
            ```
            
            - A HashSet is one of the most useful collections.
            
            ```java
            import java.util.ArrayList;
            import java.util.HashSet;
            import java.util.Set;
            
            public class Main {
                public static void main(String[] args) {
                    Set<Integer> integerSet = new HashSet<>(); // Collection의 자료형에는 primitive 타입은 올 수 없습니다. primitive 타입에 해당하는 class 가 존재하니 그것을 사용하세요.
                    integerSet.add(1);
                    integerSet.add(3);
                    integerSet.add(2);
                    integerSet.add(9);// 하나씩 값을 삽입합니다.
                    System.out.println(integerSet); // 출력을 해보면 순서가 지켜지지 않는 것을 알 수 있습니다.
            
                    Set<String> stringSet = new HashSet<>();
                    stringSet.add("LA");
                    stringSet.add("New York");
                    stringSet.add("LasVegas");
                    stringSet.add("San Francisco");
                    stringSet.add("Seoul");
                    System.out.println(stringSet);
            
                    stringSet.remove("Seoul"); //Seoul을 HashSet에서 제거해보겠습니다.
                    System.out.println(stringSet);
            
                    ArrayList<String> target = new ArrayList<String>();
                    target.add("New York");
                    target.add("LasVegas");//제거할 항목을 ArrayList에 삽입하겠습니다.
                    stringSet.removeAll(target);//제거항목에 삽입된 도시들을 삭제하겠습니다.
                    System.out.println(stringSet);
            
                    System.out.println("LA가 포함되어있나요? " + stringSet.contains("LA"));
                    System.out.println("LasVegas가 포함되어있나요? " + stringSet.contains("LasVegas"));
                    //HashSet에 포함되어있으면 true를, 그렇지 않으면 false를 반환합니다.
            
                    System.out.println("현재 HashSet의 크기는 : " + stringSet.size() + "입니다.");
                    //HashSet의 크기를 반환합니다.
            
                    stringSet.clear();//HashSet의 모든 아이템들을 삭제합니다.
                    System.out.println(stringSet);
                }
            }
            ```
            
            ```java
            import java.util.ArrayList;
            import java.util.HashSet;
            import java.util.Set;
            import java.util.List;
            
            public class Main{
              public static void main(String[] args){
                Set<String> food = new HashSet<String>();
                food.add("shabu shabu");
                food.add("bajirak calguksu");
                food.add("gamja jeon");
                food.add("haemul pajeon");
                food.add("dongtae jeon");
                food.add("sundae guk");
                System.out.println(food);
                /*
                [shabu shabu, sundae guk, gamja guk, gamja jeon, bajirak calguksu, haemul calguksu, haemul pajeon, dongtae jeon]
                */
                
                List<String> listFood = new ArrayList<String>();
                listFood.add("shabu shabu");
                listFood.add("gamja jeon");
                System.out.println(listFood);//[shabu shabu, gamja jeon]
                //removeAll gets a Collection as a parameter
                food.removeAll(listFood); 
                System.out.println(food);
                /*
                [sundae guk, bajirak calguksu, gamja jeon, bajirak calguksu, haemul pajeon, dongtae jeon]
                */
              }
            }
            ```
            
            **HashSet v. LinkedHashSet v. TreeSet**
            
            ```java
            import java.util.*;
            
            public class Main {
              public static void main(String[] args){
                List<Integer> list = List.of(9876, 987, 98, 9);
                //HashSet
                Set<Integer> hashSet = new HashSet<>(list);
                System.out.println(hashSet);//[98, 9876, 9, 987] -> randomly ordered
                
                //LinkedHashSet
                Set<Integer> linkedHashSet = new LinkedHashSet<>(list);
                System.out.println(linkedHashSet);//[9876, 987, 98, 9] -> sequentially ordered as we typed in
                
                //TreeSet
                Set<Integer> treeSet = new TreeSet<>(list);
                System.out.println(treeSet);//[9, 98, 987, 9876] -> naturally ordered
              }
            }
            ```
            
            ***puzzle: what if you want to print the unique element in the ascending order?***
            
            ```java
            import java.util.*;
            
            public class Main {
              public static void main(String[] args){
                List<Character> characters = List.of('A', 'Z', 'A', 'B', 'Z', 'F');
                //want to find a unique values
                Set<Character> charTreeSet = new TreeSet<>(characters);
                Iterator iterator = charTreeSet.iterator();
                while(iterator.hasNext()){
                  System.out.println(iterator.next());
            			/*
            			 * A
            			 * B
            			 * F
            			 * Z
            			 */
                }
              }
            }
            ```
            
            - TreeSet in Depth
                
                simple api of different kinds of Sets
                
                ```java
                class HashSet implements Sets {
                 //unordered, unsorted - iterates in random order
                 // uses hashcode()
                }
                
                class LinkedHashSet implements Set{
                	//ordered - iterates in orfer of insertion
                	//unsorted
                	//uses hashcode()
                }
                
                **class TreeSet implements Set, NavigableSet {
                	//3, 4, 7
                	//sorted - natural order
                	//implements NavigableSet
                }**
                ```
                
                Unlike other Sets, TreeSet implements NavigatableSet interface.
                
                ```java
                //floor()
                //lower()
                //ceiling()
                //higher()
                //subSet() -> lower limit: inclusive, upper limit: exclusive
                //subSet(E e, boolean b, E e, boolean b) -> you can define the inclusiveness
                //headSet()
                //tailSet()
                import java.util.*;
                
                public class Main {
                  public static void main(String[] args){
                    TreeSet<Integer> treeSet = new TreeSet<>(Set.of(1, 123, 12, 1234, 123456, 12345));
                    System.out.println(treeSet);//[1, 12, 123, 1234, 12345, 123456]
                    //floor: Returns the greatest element less than ot equal to e, or null if there is no such elelemt
                    System.out.println(treeSet.floor(12));//12
                    //lower: Returns the greatest element in this set strictly less than the given element, or null if there is no such element.
                    System.out.println(treeSet.lower(12));//1
                    //ceiling: Returns the least element in this set greater than or equal to the given element, or null if there is no such element.       
                    System.out.println(treeSet.ceiling(12));//12
                    //higher:Returns the least element in this set strictly greater than the given element, or null if there is no such element.
                    System.out.println(treeSet.higher(12));//123
                    //subset: Returns a view of the portion of this set whose elements range from fromElement to toElement
                    System.out.println(treeSet.subSet(100, 12345));//[123, 1234]
                    System.out.println(treeSet.subSet(100, true, 12345, true));//[123, 1234, 12345]
                    //headSet: Returns a view of the portion of this set whose elements are less than (or equal to, if inclusive is true) toElement.
                    System.out.println(treeSet.headSet(12345));//[1, 12, 123, 1234]
                    System.out.println(treeSet.headSet(12345, true));//[1, 12, 123, 1234, 12345]    
                    //tailSet: Returns a view of the portion of this set whose elements are greater than (or equal to, if inclusive is true) fromElement.
                    System.out.println(treeSet.tailSet(12));//[12, 123 , 1234, 12345, 123456]  
                    System.out.println(treeSet.tailSet(12, false));//[123, 1234, 12345, 123456]    
                  }
                }
                
                ```
                
        - 3) **Queue** Interface
            - Arranged in order of processing - A to-do list for example.
            - Queue interface extends Collection. So, it supports all Collection Methods
            
            ```java
            import java.util.*;
            
            public class Main {
              public static void main(String[] args){
                Queue<String> queue = new PriorityQueue<>();
                queue.offer("Apple");
                System.out.println(queue);//[Apple]
                queue.poll();
                System.out.println(queue);//[]
                List<String> list = List.of("Cat", "Zebra", "Monkey");
                queue.addAll(list);
                System.out.println(queue);//[Cat, Zebra, Monkey]
                queue.poll();
                System.out.println(queue);//[Monkey, Zebra]
              }
            }
            ```
            
            - what if we want the order of our favor
            
            ```java
            import java.util.*;
            
            public class StringLengthComparator implements Comparator<String> {
              @Override
              public int compare(String value1, String value2){
                return Integer.compare(value1.length(), value2.length());
              }
            }
            
            import java.util.*;
            
            public class Main {
              public static void main(String[] args){
                Queue<String> queue = new PriorityQueue<>(new StringLengthComparator());
                List<String> list = List.of("Lion", "Cat", "Armadillo", "Zebra", "Monkey");
                queue.addAll(list);
                System.out.println(queue.poll());//Cat
                System.out.println(queue.poll());//Lion
                System.out.println(queue.poll());//Zebra
                System.out.println(queue.poll());//Monkey
                System.out.println(queue.poll());//Armadillo
              }
            }
            ```
            
        - 4) **Map** Interface
            - The most important thing about a Map interface is, it does not extend Collection interface. Therefore, all the operations related to Collection do not really apply to Map.
            - Map is part of the collections framework, but it’s not really implementing Collection interface.
            - Map is used to store Key-Value pairs.
            - brief overview of the methods in Map interface
                
                ```java
                interface Map<K, V>{
                	int size();
                	boolean isEmpty();
                	boolean containsKey(Object paramObject);
                	boolean containsValue(Object paramObject);
                	V get(Object key);
                	V put(K key, V value);
                	V remove(Object key);
                	void putAll(Map<? extends K, ? extends V> paramMap);
                	void clear();
                	set<K> keySet();
                	Collection<V> values();
                	Set<Entry<K, v>> entrySet();
                	boolean equals(Object paramObject);
                ```
                
            - HashMap is very unique in that it contains “key” and “value” as a datum together, enabling “Hashing”, a very useful technique when searching data.
            
            ```java
            public class Main {
                public static void main(String[] args) {
            				Map<Integer, String> map = new HashMap<>();
                    map.put(1, "apple");
                    map.put(2, "berry");
                    map.put(3, "cherry");
            
                    System.out.println(map);
            
                    System.out.println("1st in map: " + map.get(1));
            
                    map.remove(2);
                    System.out.println(map);
                    System.out.println(map.containsKey(2));
                    System.out.println(map.containsValue("cherry"));
                    
                    map.clear();
                    System.out.println(map);
                }
            }
            ```
            
            - HashMap, Hashtable, LinkedHashMap, TreeMap
            
            ```java
            class HashMap implements Map {
            	//unsorted, unordered
            	//key's hashCode() is used
            }
            
            class Hashtale implements Map {
            	//Synchronized - Thread Safe - version of HashMap
            	//unsorted, unordered
            	//key's hashCode() is used
            	//HashMap allows a key with null value. Hashtable doesn't.
            }
            
            class LinkedHashMap implements Map {
            	//insertion orfer is maintained
            	//slower insertion and deletion
            	//faster iteration
            }
            
            class TreeMap implements Map, NavigableMap {
            	//sorted order is maintained
            	//implements NavigableMap
            }
            ```
            
            **HashMap v. HashTable**
            
            Both the HashMap and Hashtable store key and value pairs in a hash table. When using a Hashtable or HashMap, we specify an object that is used as a key and the value that you want to be linked to that key.
            
            - HashMap is non-synchronized. It is not thread-safe and can’t be shared between may threads without proper synchronization code whreas hashtable is synchronized. It is thread-safe and can be shared with many threads.
            - HashMap allows one null key and multiple null values whereas Hashtable doesn’t allow any null key or value.
            - HashMap is generally preferred over Hashtable if thread synchronization is not needed.
            
            **LinkedHashMap**
            
            the insertion order is maintained. However, it’s not sorted and because of the insertion order, it would have little slower insertion and deletion than the HashMap. But the iteration is much faster because all elements have links to each other.
            
            **TreeMap**
            
            the data is stored in a sorted order.  TreeMap implements NavigableMap in addition to Map interface.
            
            **Basic operations**
            
            ```java
            import java.util.*;
            
            public class Main {
              public static void main(String[] args){
                Map<String, Integer> map = Map.of("A", 3, "B", 5, "Z", 10);//immutable map
                System.out.println(map); //{B=5, A=3, Z=10}
                System.out.println(map.get("Z"));//10
                System.out.println(map.get("A"));//3
                System.out.println(map.get("C"));//null
                System.out.println(map.size());//3
                System.out.println(map.containsKey("A"));//true
                System.out.println(map.isEmpty());//false
                System.out.println(map.containsValue(3));//true
                System.out.println(map.keySet());//[Z, B, A]
                System.out.println(map.values());//[3, 5, 10]
              }
            }
            ---------------------------------------------------------
            import java.util.*;
            
            public class Main {
              public static void main(String[] args){
                Map<String, Integer> map = Map.of("A", 3, "B", 5, "Z", 10);//immutable map
                Map<String, Integer> hashMap = new HashMap<>(map);
                hashMap.put("F", 5);
                hashMap.put("Z", 11);
                System.out.println(hashMap);//{A=3, Z=11, B=5, F=5}
              }
            }
            -----------------------------------------------------
            import java.util.*;
            
            public class Main {
              public static void main(String[] args){
                HashMap<String, Integer> hashMap = new HashMap<>();
                hashMap.put("Z",5);
                hashMap.put("A",15);
                hashMap.put("F",25);
                hashMap.put("L",250);
                //hashMap does not care about sorting, does not care about the insertion either.
                //So, it's much more efficient than the other data structures which are related to Maps, when you don't really need to worry about which order your Keys are stored in.
                System.out.println(hashMap);//{A=15, F=25, Z=5, L=250}
            
                LinkedHashMap<String, Integer> linkedHashMap = new LinkedHashMap<>();
                linkedHashMap.put("L", 250);
                linkedHashMap.put("A", 15);
                linkedHashMap.put("Z", 5);
                linkedHashMap.put("F", 25);
                System.out.println(linkedHashMap);//{L=250, A=15, Z=5, F=25} -> the order is kept.
            
                TreeMap<String, Integer> treeMap = new TreeMap<>();
                treeMap.put("F", 25);
                treeMap.put("A", 15);
                treeMap.put("Z", 5);
                treeMap.put("L", 250);
                System.out.println(treeMap);//{A=15, F=25, L=250, Z=5}
              }
            }
            ----------------------------------------------------------------------------------
            import java.util.*;
            //the methods present in Navigable interface: unique to treemap
            public class Main {
              public static void main(String[] args){
                TreeMap<String, Integer> treemap = new TreeMap<>();
                treemap.put("F", 25);
                treemap.put("Z", 5);
                treemap.put("L", 250);
                treemap.put("A", 15);
                treemap.put("B", 25);
                treemap.put("G", 25);
                System.out.println(treemap);
                //{A=15, B=25, F=25, G=25, L=250, Z=5}
                System.out.println(treemap.higherKey("B"));//F
                System.out.println(treemap.higherKey("C"));//F
                System.out.println(treemap.higherKey("B"));//B
                System.out.println(treemap.lowerKey("B"));//A
                System.out.println(treemap.floorKey("B"));//B
                System.out.println(treemap.firstEntry());//A=15
                System.out.println(treemap.lastEntry());//Z=5
                System.out.println(treemap.subMap("B", "L"));//{B=25, F=25, G=25}
                System.out.println(treemap.subMap("B", true, "L", true));//{B=25, F=25, G=25, L=250}
              }
            }
            ```
            
            - puzzle
                
                my trial… took forever to compile
                
                ```java
                import java.util.*;
                
                public class Main {
                  public static void main(String[] args){
                    //given a string: "This is a great thing!"
                    //1.wants to see how make unique character appears
                    //2.wants to see how make unique words appears.
                    String str = "This is a great thing!";
                    //create an char array to store character individually
                    HashMap<Character, Integer> hashMap = new HashMap<>();
                    char[] charArr = str.toCharArray();
                    List<Character> charList = new ArrayList<>();
                    for(char character : charArr){
                      charList.add(character);
                    }
                    Collections.sort(charList);
                    for(int i = 0; i<charList.size()-1; i++){
                      int count = 1; 
                      char currKey = charList.get(i);
                      char nextKey = charList.get(i+1);
                      while(currKey == nextKey){
                        count++;
                      }if(currKey != charList.get(i+1)){
                        hashMap.put(currKey, count);
                      }
                    }
                    System.out.println(hashMap);
                  }
                }
                ```
                
                answer
                
                ```java
                import java.util.*;
                
                public class Main {
                  public static void main(String[] args){
                    String str = "This is an awesome occasion." +
                                "This has never happened before.";
                    Map<Character, Integer> occurances = new HashMap<>();
                
                    char[] characters = str.toCharArray();
                
                    for(char character:characters){
                      //get the character
                      Integer integer = occurances.get(character);
                      if(integer == null){
                        occurances.put(character, 1);
                      } else {
                        occurances.put(character, integer + 1);
                      }
                    }
                    System.out.println(occurances);
                  }
                }
                --------------------------------------------------------------------------------
                import java.util.*;
                
                public class Main {
                  public static void main(String[] args){
                     String str = "This is an awesome occasion." +
                                " This has never happened before.";
                    Map<String, Integer> occurances = new HashMap<>();
                    String[] wordArr = str.split(" ");
                    System.out.println(Arrays.toString(wordArr));
                    for(String string : wordArr){
                      Integer integer = occurances.get(string);
                      if(integer == null){
                        occurances.put(string, 1);
                      } else {
                        occurances.put(string, integer+1);
                      }
                    }
                    System.out.println(occurances);
                  }
                }
                ```
                
        - tips
            - whenever you see “Hash” in a collection’s name, it’s for sure unordered and unsorted.
            - whenever you see “Linked” in a collection’s name, it’s for sure maintaining the order in which the data is inserted.
            - whenever you see “Tree” in a collection’s name, it’s for sure stores data sorted in an underlying structure of Tree.
            - whenever you see “Tree” in a collection’s name, it implements either NavigableSet or NavigableMap interface.
    - Stack, Queue, ArrayDeque
        - 1) Stack
            - what is a stack?
                - A stack, one of the data structures, pulls out data starting from the lastly inputted value. (Last In First Out)
            - Examples of a stack
                - web browser’s change in previous and next page/stacking bowls.
            - In the picture below, 45, the lastly inputted value pops first.
            
            ![Untitled](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Untitled%2014.png)
            
            ```java
            public class Main {
                public static void main(String[] args) {
                    Stack<Integer> stack = new Stack<>();
                    stack.push(1);
                    stack.push(3);
                    stack.push(5);
                    stack.push(7);
                    System.out.println(stack); // Stack을 출력합니다
            
                    System.out.println(stack.peek()); // Stack의 가장 상단 값을 출력합니다.(삭제는 하지 않습니다.)
                    stack.pop(); // Stack의 가장 상단 값을 제거합니다.
                    System.out.println(stack);
                    System.out.println(stack.size()); // Stack의 크기를 반환합니다.
                    System.out.println(stack.contains(1)); // Stack에 1이라는 값이 있으면 true를, 그렇지 않으면 false를 반환합니다.
                    System.out.println(stack.empty()); // STack이 비어있으면 true를, 그렇지 않으면 false를 반환합니다.
                    System.out.println(stack);
                }
            }
            ```
            
        - 2) Queue
            - Queue
                - First In First Out
            - Examples of the Queue
                - line-up in the bank / 인쇄 작업 대기 목록 / 선착순..
            - As indicated below, Queue’s both ends are open. First In First Out!
            
            ![Untitled](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Untitled%2015.png)
            
            ```java
            public class Main {
                public static void main(String[] args) {
                    Queue<Integer> queue = new LinkedList<>();
                    queue.add(1);
                    queue.add(3);
                    queue.add(5);//Queue에 값 삽입합니다.
                    System.out.println(queue);//Queue 출력합니다.
                    System.out.println(queue.poll()); // Queue에서 객체를 꺼내서 반환합니다.
                    queue.add(7);
                    queue.add(11);
                    queue.add(9);
                    System.out.println(queue);
                    System.out.println(queue.peek()); //Queue에서 삭제 없이 요소를 반환합니다.
                    System.out.println(queue);
                }
            }
            ```
            
        - 3) ArrayDeque
            
            ![Untitled](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Untitled%2016.png)
            
            In Queue, we inserted a value and then “poll()” if from the other end. Unlike that, ArrayDeqeue allows us to add() and poll() from both sides.
            
            ```java
                public static void main(String[] args) {
                    ArrayDeque<Integer> arrayDeque = new ArrayDeque<>(); // ArrayDeque를 이용한 선언(제네릭스 이용)
                    arrayDeque.addFirst(1);
                    arrayDeque.addFirst(2);
                    arrayDeque.addFirst(3);
                    arrayDeque.addFirst(4); // arrayDeque의 앞에 값을 삽입
                    System.out.println(arrayDeque);
            
                    arrayDeque.addLast(0); // arrayDeque의 끝에 값을 삽입
                    System.out.println(arrayDeque);
            
                    arrayDeque.offerFirst(10); // addFirst와 비슷하지만 큐의 크기 문제가 생길 때, offerFirst는 false를,
                    // addFrist는 exception을 반환합니다.
                    System.out.println(arrayDeque);
            
                    arrayDeque.offerLast(-1); // arrayDeque의 끝에 값을 삽입
                    System.out.println(arrayDeque);
                    System.out.println(arrayDeque.size()); // 7
            
                    System.out.println(arrayDeque.removeFirst()); // 첫번째 값을 제거하면서 그 값을 리턴
                    System.out.println(arrayDeque.removeLast()); // 마지막 값을 제거하면서 그 값을 리턴
            		    System.out.println(arrayDeque);
            				System.out.println(arrayDeque.size()); // 5
            
                    System.out.println(arrayDeque.pollFirst()); // 첫번째 값을 반환 및 제거하면서 그 값을 리턴
                    System.out.println(arrayDeque);
            				System.out.println(arrayDeque.size()); // 4
            
                    System.out.println(arrayDeque.pollLast()); // 마지막 값을 반환 및 제거하면서 그 값을 리턴
                    System.out.println(arrayDeque);
            				System.out.println(arrayDeque.size()); // 3
            
                    System.out.println(arrayDeque.peekFirst()); // 첫번째 값을 반환, 제거하지 않음
                    System.out.println(arrayDeque.peekLast()); // 마지막 값을 반환, 제거하지 않음
            				System.out.println(arrayDeque.size()); // 3
                }
            }
            ```
            
- Generics
    - You want to implement a custom ArrayList for yourself. And you want the ArrayList to work with any data type as the elements of it.
    - how can we create a class which is not tied to one data type?→an exact problem Generics aim to solve.
    - how to make generics
        1. define a generic type in the angular brackets<> beside the class name. ex) `public class MyCustomList<T>`
        2. Specify the type you want when you create an instance of that class. 
        3. change any defined data type (especially as parameters) to T
            
            ```java
            ArrayList<T> list = new ArrayList<>();
            
            public void addElement(T element) {
            	list.add(element);
            }
            ```
            
        - some examples
            
            ```java
            import java.util.ArrayList;
            
            public class MyCustomList<T>{
            	ArrayList<T> list = new ArrayList<>();
            	
            	public void addElement(T element){
            		list.add(element);
            	}
            
            	public void removeElement(T element){
            		list.remove(element);
            	}
            
            	@Override
            	public String toString(){
            		return list.toString();
            	}
            }
            
            //Main class
            import ourpackage.src.*;
            
            public class Main{
              public static void main(String[] args){
                MyCustomList<String> list = new MyCustomList();
                list.addElement("Element 1");
                list.addElement("Element 2");
                System.out.println(list);//[Element 1, Element2]
            
                MyCustomList<Integer> list2 = new MyCustomList();
                list2.addElement(Integer.valueOf(5));
                list2.addElement(Integer.valueOf(7));
                System.out.println(list2);//[5, 7]
              }
            }
            
            /* it worked the same when I did this 
            
            import java.util.ArrayList;
            
            public class MyCustomList<T>{
              ArrayList<T> list;
              
              public MyCustomList(){
                this.list = new ArrayList<>();
              }
              
              public void addElement(T element){
                list.add(element);
              }
            
              public void removeElement(T element){
                list.remove(element);
              }
            
              @Override
              public String toString(){
                return list.toString();
              }
            }
            */
            ```
            
            adding method
            
            ```java
            import java.util.ArrayList;
            
            public class MyCustomList<T>{
              ArrayList<T> list;
              
              public MyCustomList(){
                this.list = new ArrayList<>();
              }
              
              public void addElement(T element){
                list.add(element);
              }
            
              public void removeElement(T element){
                list.remove(element);
              }
            
              public void printElement(){
                for(T element : list){
                  System.out.println(element);
                }
              }
            
              @Override
              public String toString(){
                return list.toString();
              }
            }
            
            //Main class
            import ourpackage.src.*;
            
            public class Main{
              public static void main(String[] args){
                MyCustomList<String> list = new MyCustomList();
                list.addElement("Element 1");
                list.addElement("Element 2");
                System.out.println(list);//[Element 1, Element2]
                list.printElement();
                //Element1
                //Element2
            
                MyCustomList<Integer> list2 = new MyCustomList();
                list2.addElement(Integer.valueOf(5));
                list2.addElement(Integer.valueOf(7));
                System.out.println(list2);//[5, 7]
                list2.printElement();
                //5
                //7
              }
            }
            ```
            
    - now you know how to make generics, you want to make constraints on the allowed types.
        1. equipped with the knowledge of abstraction of the classes.
        2. extends a class(that you want to make as a limit) to the Type parameter between angular bracket<> at the class level.
            
            ex) `public class MyCustomList<T extends Number>{`
            
        - some examples
            
            ```java
            import java.util.ArrayList;
            
            public class MyCustomList<T extends Number>{
              ArrayList<T> list;
              
              public MyCustomList(){
                this.list = new ArrayList<>();
              }
              
              public void addElement(T element){
                list.add(element);
              }
            
              public void removeElement(T element){
                list.remove(element);
              }
            
              public void printElement(){
                for(T element : list){
                  System.out.println(element);
                }
              }
            
              @Override
              public String toString(){
                return list.toString();
              }
            }
            
            //Main class
            import ourpackage.src.*;
            
            public class Main{
              public static void main(String[] args){
                MyCustomList<Long> list = new MyCustomList();
                list.addElement(7L);
                list.addElement(100000L);
                System.out.println(list);//[7, 100000]
                list.printElement();
                //7
                //100000
            
                MyCustomList<Integer> list2 = new MyCustomList();
                list2.addElement(Integer.valueOf(5));
                list2.addElement(Integer.valueOf(7));
                System.out.println(list2);//[5, 7]
                list2.printElement();
                //5
                //7
              }
            }
            ```
            
    - you can directly implement the concept of generics to a method.
        
        ex) 
        
        ```java
        static <X extends List> void duplicate(X list) {
        		list.addAll(list);
        }
        
        public static void main(String[] args){
        		ArrayList numbers = new ArrayList<>(List.of(1, 2, 3));
        		duplicate(numbers);
        		System.out.println(numbers);//[1, 2, 3, 1, 2, 3]
        }
        ```
        
        [wildcard-and-generics(YouTube)](https://www.youtube.com/watch?v=Xje5PIhys18)
        
- functional programming
    - we will be trying to pass functions to functions, and having return values as functions. → completely different from oop.
    - It’s all about giving the first-class status to functions.
    - with functional programming, we avoid mutation(change of objects) of variable, so we don’t really try to have variables whose values are changing.
    - with functional programming, we focus on telling what to do.   ex) for every pair of number, add them up.
    - imperative programming
    
    ```java
    import java.util.*;
    
    public class Main {
      public static void main(String[] args) {
        List<String> list = new ArrayList<String>();
        list.add("Dog");
        list.add("Cat");
        list.add("Tiger");
        printBasic(list);
        printWithFP(list);
      }
    
      private static void printBasic(List<String> list) {
        for (String str : list) {
          System.out.println(str);
        }
      }
    
      private static void printWithFP(List<String> list) {
        // think the list as a stream
        list.stream().forEach( // forEach() for "for each element"
            // we are sending action to forEach
            element -> System.out.println("element - " + element));
      }
    }
    ```
    
    - looping a list using the functional programming.
        
        ```java
        package project;
        
        import java.util.*;
        
        public class Main {
          public static void main(String[] args){
            List<Integer> numList = new ArrayList<>();
            numList.add(1);
            numList.add(2);
            numList.add(3);
            numList.add(4);
            numList.add(5);
            numList.add(6);
            numList.add(7);
            numList.add(8);
            
            //functional programming
            numList.stream().forEach(element -> System.out.println(element));
          }
        }
        ```
        
    - filtering in functional programming.
        
        filter() allows only the things specified to go in.
        
        ```java
        import java.util.*;
        
        public class Main {
          public static void main(String[] args) {
            List<String> list = new ArrayList<String>();
            list.add("Dog");
            list.add("Cat");
            list.add("Tiger");
            printWithFilter(list);//Cat
          }
          private static void printWithFilter(List<String> list){
              list.stream()
                  .filter(element -> element.endsWith("at"))
                  .forEach(element -> System.out.println(element));
          }    
        }
        ```
        
        - filtering odds and evens
            
            ```java
            package project;
            
            import java.util.*;
            import java.lang.Math;
            
            public class Main{
              public static void main(String[] args) {
                 ArrayList<Integer> list = new ArrayList<>(10);
                insertNum(list);
                System.out.println(list);
                System.out.println("------printing odd numbers------");
                printOdd(list);
                System.out.println("------printing even numbers------");
                printEven(list);
              }
                
              private static void insertNum(List list){
                int listSize = 10;
                for(int i = 0; i < listSize; i++){
                    list.add((int)(Math.random()*10));  
                  }
              }
              
              //filtering using the functional programming.
              private static void printOdd(List<Integer> list){
                  list.stream()
                      .filter(element -> element.intValue()%2 == 1)
                      .forEach(element -> System.out.println(element));
              }
             
               private static void printEven(List<Integer> list){
                  list.stream()
                      .filter(element -> element.intValue()%2 == 0)
                      .forEach(element -> System.out.println(element));
              }
            }
            ```
            
    - getting the sum of elements using the functional programming.
        
        `reduce()` accepts the BinaryOperator as parameters. BinaryOperator accepts two T-type parameters and return a T-type object. 
        
        Reducing is the repeated process of combining all elements. reduce operation applies a binary operator to each element in the stream where the first argument to the operator is the return value of the previous application and second argument is the current stream element.
        
        ```
        T reduce(T identity, BinaryOperator<T> accumulator);
        
        Where,identity is initial value
        of typeT andaccumulator is a
        function for combining two values.
        ```
        
        **summing up the elements**
        
        ```java
        import java.util.*;
        import java.lang.Math;
        
        public class Main{
        	public static void main(String[] args){
        		ArrayList<Integer> list = new ArrayList<>();
        		System.out.println("-----inserting random numbers to the list-----");
        		insertNum(list);
        		System.out.println("-----getting the sum of elements in the list-----");
        	}
        	private static void insertNum(List list){
        		final int listSize = 10;
        		for(int i = 0; i < listSize; i++){
        			list.add((int)(Math.random()*10));
        		}
        	}
        	private static double getSum(List<Integer> list){
               return list.stream()
                   .reduce(0, (number1, number2) -> number1 + number2);
           }
        }
        ```
        
    - intermediate and terminal operations in functional programming.
        
        Java 8 Stream has many operations which can be pipe lined together to get desired result. Some operations produce another stream as a result and some operations produce non-stream values as a result. The operations which return another stream as a result are called intermediate operations and the operations which return non-stream values like primitive or object or collection or return nothing are called terminal operations. In this post, we will see the differences between Java 8 Stream intermediate and terminal operations.
        
        # **Java 8 Stream Intermediate And Terminal Operations :**
        
        1) The main difference between intermediate and terminal operations is that intermediate operations return a stream as a result and terminal operations return non-stream values like primitive or object or collection or may not return anything.
        
        2) As intermediate operations return another stream as a result, they can be chained together to form a pipeline of operations. Terminal operations can not be chained together.
        
        3) Pipeline of operations may contain any number of intermediate operations, but there has to be only one terminal operation, that too at the end of pipeline.
        
        4) Intermediate operations are lazily loaded. When you call intermediate operations, they are actually not executed. They are just stored in the memory and executed when the terminal operation is called on the stream.
        
        5) As the names suggest, intermediate operations doesn’t give end result. They just transform one stream to another stream. On the other hand, terminal operations give end result.
        
        6) **Intermediate Operations :**
        
        `map()`, `filter()`, `distinct()`, `sorted()`, `limit()`, `skip()`
        
        **Terminal Operations :**
        
        `forEach()`, `toArray()`, `reduce()`, `collect()`, `min()`, `max()`, `count()`, `anyMatch()`, `allMatch()`, `noneMatch()`, `findFirst()`, `findAny()`
        
    - intermediate operations that can be performed on the streams().
        1. `sorted()`
            
            
            ```java
            List<Integer> numList = List.of(1, 2, 3, 4, 5);
            numList.stream().sorted()
            	.forEach(e -> System.out.println(e));
            /* 1
             * 2
             * 3
             * 4
             * 5
             */
            ```
            
        2. `distinct()`
            
            ```java
            List<Integer> numList = List.of(1, 2, 3, 4, 5, 5, 5);
            numList.stream().distinct()
            	.forEach(e -> System.out.println(e));
            /*
             * 1
             * 2
             * 3
             * 4
             * 5
             */
            ```
            
        3. `sorted()` and `distinct()` → you can combine and have multiple intermediate operations.
            
            ```java
            List<Integer> numList = List.of(1, 9, 3, 2, 5, 6, 7, 1 ,100, 1300, 2);
            numList.stream().sorted().distinct()
            	.forEach(e -> System.out.println(e));
            /*
             * 1
             * 2
             * 3
             * 5
             * 6
             * 7
             * 9
             * 100
             * 1300
             */
            ```
            
        4. `map()` → you want to change the form of elements into another form.
            
            ```java
            List<Integer> numList = List.of(1, 9, 3, 2, 5, 6, 7, 1 ,100, 1300, 2);
            numList.stream().sorted().distinct()
            	.map(e -> e*e).forEach(e -> System.out.println(e));
            /*
             * 1
             * 4
             * 9
             * 25
             * 36
             * 49
             * 81
             * 10000
             * 1690000
             */
            ```
            
        5. exercise
            
            ```java
            //Exercise - Print squares of the first 10 numbers!
            //Clue - IntStream.range(1, 10)
            IntStream.range(1, 11).map(e -> e*e)
            	.forEach(e -> System.out.println(e));
            
            //List.of("Apple", "Ant", "Bat").stream()
            //Map all of these to lowercase and print them
            List listOfStr = List.of("Apple", "Ant", "Bat");
            listOfStr.stream().map(e -> e.toString().toLowerCase())
            	.forEach(i -> System.out.println(i));
            
            //List.of("Apple", "Ant", "Bat").stream()
            //Print the length of each element
            List listOfStr1 = List.of("Apple", "Ant", "Bat");
            listOfStr1.stream().map(e -> e.toString().length())
            	.forEach(i -> System.out.println(i));
            ```
            
    - terminal operations that can be performed on the streams().
        
        The result of a terminal operation on a stream is typically one value.
        
        1. `reduce()`
            
            ```java
            System.out.println(numList.stream().reduce(0, (num1, num2) -> num1 + num2));//1436
            ```
            
        2. `max()`
            
            
            | https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html<https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html> | https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#max-java.util.Comparator-(https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html<? super https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html> comparator)Returns the maximum element of this stream according to the provided Comparator. |
            | --- | --- |
            
            ```java
            System.out.println(List.of(23, 12, 34, 53).stream().max((n1, n2) -> Integer.compare(n1, n2)).get());//53
            ```
            
        3. `min()`
            
            
            | https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html<https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html> | https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#min-java.util.Comparator-(https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html<? super https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html> comparator)Returns the minimum element of this stream according to the provided Comparator. |
            | --- | --- |
            
            ```java
            System.out.println(List.of(23, 12, 34, 53).stream().min((n1, n2) -> Integer.compare(n1, n2)).get());//12
            ```
            
        4. `filter()` and `collect()`
            
            ```java
            List<Integer> arrayList = new ArrayList<>();
            arrayList.add(12);
            arrayList.add(11);
            arrayList.add(23);
            arrayList.add(24);
            
            System.out.println(arrayList.stream().filter(e -> e%2 == 1)
            	.collect(Collectors.toList()));//[11, 23]
            ```
            
        
         5. Exercise
        
        ```java
        package project;
        
        import java.util.*;
        import java.lang.Math;
        import java.util.stream.*;
        import static java.util.stream.Collectors.*;
        
        public class Main {
            public static void main(String[] args){
                
            List<Integer> arrayList = new ArrayList<>();
            arrayList.add(12);
            arrayList.add(11);
            arrayList.add(23);
            arrayList.add(24);
            
            System.out.println(arrayList.stream().filter(e -> e%2 == 1).collect(Collectors.toList()));//[11, 23]
            
            //Exericise 
            //1. identify the even numbers and collect them into a list.
            System.out.println(arrayList.stream().filter(e -> 2%2 == 0).collect(Collectors.toList()));
            //2. get the square of the first 10 integers and get the list of them.
            System.out.println(arrayList.stream().map(e -> Math.pow(Integer.valueOf(e.toString()),2)).collect(Collectors.toList()));//[144.0, 121.0, 529.0, 576.0]
            System.out.println(IntStream.range(1, 11).map(e -> e * e).boxed().collect(Collectors.toList()));//[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
            }
        }
        ```
        
    - Optional in java 8
        
        Optional class is a class created to avoid null pointer exception. Optional<T> is a Wrapper class for the situation where NPE might happen. Optional is just a way to avoid returning nulls. Whenever you are returning something which might exist or might not exist, then you can return a optional back, and that’s what the most methods in the streams do.
        
        ```java
        import java.util.*;
        import java.lang.Math;
        import java.util.stream.*;
        import static java.util.stream.Collectors.*;
        
        public class Main {
            public static void main(String[] args){
                
            List<Integer> arrayList = new ArrayList<>();
            arrayList.add(23);
            arrayList.add(45);
            arrayList.add(67);
            
            System.out.println(arrayList.stream().filter(n -> n*2 == 0).max((n1, n2) -> Integer.compare(n1, n2)).orElse(0));
            
            }
        }
        ```
        
    - FUNCTIONAL PROGRAMMING behind the scenes!
        - what is happening behind  the scene is, you’re creating implementations of the functional interfaces and an instance of that implementation. And that is what is being passed out to the filter, forEach, and map methods.
        - what’s happening behind filter() method?
            
             code example
            
            ```java
            List<Integer> arrayList = new ArrayList<>();
            arrayList.add(23);
            arrayList.add(43);
            arrayList.add(34);
            arrayList.add(45);
            
            arrayList.stream().filter(n -> n%2 ==0 )
                    .forEach(e -> System.out.println(e));//34
            ```
            
            | https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html<https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html> | https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#filter-java.util.function.Predicate-(https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html<? super https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html> predicate)Returns a stream consisting of the elements of this stream that match the given predicate. |
            | --- | --- |
            
            Predicate<T> is a functional interface which has the method below.
            
            | boolean | https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html#test-T-(https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html t)Evaluates this predicate on the given argument. |
            | --- | --- |
            
             
            
            ```java
            package project;
            
            import java.util.function.Predicate;
            
            class EvenNumberPredicate implements Predicate<Integer> {
                
                @Override
                public boolean test(Integer num){
                    return num % 2 == 0;
                }
            }
            
            public class Main {
                public static void main(String[] args){
                    
                List<Integer> arrayList = new ArrayList<>();
                arrayList.add(23);
                arrayList.add(43);
                arrayList.add(34);
                arrayList.add(45);
                //THESE DO THE SAME THING
                arrayList.stream().filter(n -> n%2 ==0 )
                    .forEach(e -> System.out.println(e));//34
                  
                arrayList.stream().filter(new EvenNumberPredicate())
                    .forEach(e -> System.out.println(e));//34 
                }
            }
            ```
            
        - Now, what’s happening behind forEach() method?
            
            
            | void | https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#forEach-java.util.function.Consumer-(https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html<? super https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html> action)Performs an action for each element of this stream. |
            | --- | --- |
            
            Consumer<T> is a functional interface which has the method below.
            
            | void | https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html#accept-T-(https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html t)Performs this operation on the given argument. |
            | --- | --- |
            
            ```java
            package project;
            import java.util.function.Consumer;
            
            class SysoutConsumer implements Consumer<Integer>{
                
                @Override
                public void accept(Integer num){
                    System.out.println(num);
                }
            }
            
            package project;
            
            import java.util.*;
            import java.lang.Math;
            import java.util.stream.*;
            import static java.util.stream.Collectors.*;
            
            public class Main {
                public static void main(String[] args){
                    
                List<Integer> arrayList = new ArrayList<>();
                arrayList.add(23);
                arrayList.add(43);
                arrayList.add(34);
                arrayList.add(45);
                    
                arrayList.stream().filter(n -> n%2 == 1)
                    .forEach(new SysoutConsumer()); //23
                                                    //43
                                                    //45
                }
            }
            ```
            
        - Now, what’s happening behind map() method?
            
            
            | <R> https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html<R> | https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#map-java.util.function.Function-(https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html<? super https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html,? extends R> mapper)Returns a stream consisting of the results of applying the given function to the elements of this stream. |
            | --- | --- |
            
            Function<T, R> is a functional interface which has the method below.
            
            | https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html | https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html#apply-T-(https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html t)Applies this function to the given argument. |
            | --- | --- |
            
            ```java
            package project;
            
            import java.util.function.*;
            
            class PowerApplication implements Function<Integer, Integer>{
                
                @Override
                public Integer apply(Integer num){
                    return num*num;
                }
            }
            
            package project;
            
            import java.util.*;
            import java.lang.Math;
            import java.util.stream.*;
            import static java.util.stream.Collectors.*;
            
            public class Main {
                public static void main(String[] args){
                    
                List<Integer> arrayList = new ArrayList<>();
                arrayList.add(23);
                arrayList.add(43);
                arrayList.add(34);
                arrayList.add(45);
                
                arrayList.stream().map(new PowerApplication())
                    .forEach(e -> System.out.println(e));//529
                                                         //1849
                                                         //1156
                                                         //2025
                }
            }
            ```
            
    - method references in functional programming.
        
        it’s convenient to think that you write Class left to the :: and the method you want to perform right to the ::
        
        ```java
        package project;
        
        import java.util.*;
        import java.lang.Math;
        import java.util.stream.*;
        import static java.util.stream.Collectors.*;
        
        public class Main {
            
            public static void main(String[] args){
                
            List<String> strList = new ArrayList<>();
            strList.add("Ant");
            strList.add("Bat");
            strList.add("Cat");
            strList.add("Dog");
            strList.add("Elephant");
                
            strList.stream().map(s -> s.length())
        				.forEach(s -> System.out.println(s));
            /*
            3
            3
            3
            3
            8
            */
            strList.stream().map(s -> s.length())
        				.forEach(System.out::println);
            /*
            3
            3
            3
            3
            8
            */
            }
        }
        ```
        
        - since method referencing is literally referencing a method, the below will do the same. (I created a static method called print and referred to it in the main method).
        
        ```java
        package project;
        
        import java.util.*;
        import java.lang.Math;
        import java.util.stream.*;
        import static java.util.stream.Collectors.*;
        
        public class Main {
            
            public static void print(Integer num){
                System.out.println(num);
            }
            
            public static void main(String[] args){
                
            List<String> strList = new ArrayList<>();
            strList.add("Ant");
            strList.add("Bat");
            strList.add("Cat");
            strList.add("Dog");
            strList.add("Elephant");
        
            strList.stream().map(s -> s.length())
        			.forEach(System.out::print);
            /*
            3
            3
            3
            3
            8
            */
            }
        }
        ```
        
        - method references also work with a method which is being called on an instance.
        
        ```java
        public class MethodReferencesRunner {
        	public static void print(Integer number) {
        	System.out.println(number);
        	}
        	public static void main(String[] args) {
        		List.of("Ant", "Bat", "Cat", "Dog", "Elephant").stream()
        			.map(String::length)
        			.forEach(MethodReferencesRunner::print);
        	}
        }
        ```
        
        ```java
        package project;
        
        import java.util.*;
        import java.lang.Math;
        import java.util.stream.*;
        import static java.util.stream.Collectors.*;
        
        public class Main {
            public static void print(Integer num){
                System.out.println(num);
            }
            public static boolean isEven(Integer num){
                if(num%2 == 0){
                    return true;
                } return false;
            }
            public static void main(String[] args){
                List<Integer> arrayList = new ArrayList<>();
                arrayList.add(23);
                arrayList.add(45);
                arrayList.add(67);
                arrayList.add(34);
                arrayList.add(66);
                
                Integer max = arrayList.stream()
                    .filter(Main::isEven)
                    .max(Integer::compare)
                    .orElse(0);
                System.out.println(max);//66
            }
        }
        ```
        
        - storing function in variables
        
        ```java
        package project;
        
        import java.util.*;
        import java.lang.Math;
        import java.util.stream.*;
        import static java.util.stream.Collectors.*;
        import java.util.function.*;
        
        public class Main {
            public static void print(Integer num){
                System.out.println(num);
            }
            public static void main(String[] args){
                List<Integer> arrayList = new ArrayList<>();
                arrayList.add(23);
                arrayList.add(45);
                arrayList.add(67);
                arrayList.add(34);
                arrayList.add(66);
                
            //1.Storing functions in variables
                Predicate<? super Integer> evenPredicate = n -> n%2 == 0;
                Predicate<? super Integer> oddPredicate = n -> n%2 == 1;
                Consumer<? super Integer> printConsumer = Main::print;
                
                arrayList.stream().filter(evenPredicate).forEach(printConsumer);
                //34
                //66
        ```
        
        - setting the function as a return type
        
        ```java
        private static Predicate<? super Integer> createEvenPredicate() {
            return n -> n%2 == 0;
        }
        ```
        
- Introduction to Threads and Concurrency
    - This is what a normal programming would look like.
        
        ```java
        package project;
        
        public class Main {
            public static void main(String[] args){
                   //Task1
                for(int i = 101; i <= 199; i++)
                    System.out.print(i + " ");
                System.out.println("\ntask 1 is done");
                //Task2
                for(int i = 201; i <= 299; i++)
                    System.out.print(i + " ");
                System.out.println("\ntask 2 is done");
                //Task3
                for(int i = 301; i <= 399; i++)
                    System.out.print(i + " ");
                System.out.println("\ntask 3 is done");
                System.out.println("\nmain mehtod is done");
            }
        }
        /*
        6 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 2
        69 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291
        292 293 294 295 296 297 298 299
        task 2 is done
        301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323
         324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 34
        6 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 3
        69 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391
        392 393 394 395 396 397 398 399
        task 3 is done
        
        main mehtod is done
        */
        ```
        
    - Typically, in a lot of scenarios, you might have situations with Task1, Task2, and Task3 are independent of each other. And some of these tasks might be dependent on external services.
    - In these cases, you will be not using your CPU very effectively. Task2 has to wait until the Task1 is done, and it’s the same for the Task3. When these tasks could be executed in parallel, your CPU doesn’t know that. By using threads, the optimal use of CPU is guaranteed.
    - You can have multiple threads running different codes simultaneously.
    - There are two main ways to create threads.
        1. extending Thread class.
        2. implementing Runnable interface.
        - extending Thread class
            
            I will show the example of the thread by using aforementioned Main class above that contains task1, 2, and 3.
            
            ```java
            package project;
            
            public class Task1 extends Thread {
                public void run() { //SIGNATURE
                    System.out.println("\nTask1 Started");
                    for(int i = 101; i<=199; i++)
                        System.out.print(i + " ");
                    System.out.println("\nTask1 Done");
                }
            }
            
            package project;
            
            import java.util.*;
            import java.lang.Math;
            import java.util.stream.*;
            import static java.util.stream.Collectors.*;
            import java.util.function.*;
            
            public class Main {
                public static void main(String[] args){
                    //Task1
                    System.out.println("Task1 kicked off");
                    Task1 task1 = new Task1(); //make an instance of Task1
                    task1.start(); //if we do the task.run() it won't run in parallel with other threads, it will work as if it was a normal method, typical execution.
                                           
                    //Task2
                    System.out.println("Task2 kicked off");
                    for(int i = 201; i <= 299; i++)
                        System.out.print(i + " ");
                    System.out.println("\ntask 2 is done");
                    //Task3
                    System.out.println("Task3 kicked off");
                    for(int i = 301; i <= 399; i++)
                        System.out.print(i + " ");
                    System.out.println("\ntask 3 is done");
                    System.out.println("\nmain mehtod is done");
                }
            }
            
            /*
            OUTPUT
            
            Task1 kicked off
            Task2 kicked off
            201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223
             224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 24
            6 247 248 249 250 251 252 253 254
            Task1 Started
            101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 255 256 257 258 259 260 261
             262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 28
            4 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299
            task 2 is done
            Task3 kicked off
            301 302 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137
             138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 16
            0 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 1
            83 184 185 186 187 188 189 190 191 192 193 194 195 196 197 303 304 305 306 307 308 309 310
            311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333
             334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 198 199
            Task1 Done
            354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376
             377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 39
            9
            task 3 is done
            
            main mehtod is done
            */
            ```
            
            when you see what’s printed on the console, you can tell that the task1 is being executed with the rest of the code in the Main class simultaneously.
            
        - implementing Runnable interface
            
            we will show the thread implementation of Task2 by implementing the Runnable interface.
            
            ```java
            package project;
            
            import java.util.*;
            import java.lang.Math;
            import java.util.stream.*;
            import static java.util.stream.Collectors.*;
            import java.util.function.*;
            
            public class Main {
                public static void main(String[] args){
                    //Task1
                    System.out.println("Task1 kicked off");
                    Task1 task1 = new Task1();
                    task1.start(); //if we do the task.run() it won't run in parallel with other threads, it will work as if it was a normal method, typical execution.
                                           
                    //Task2
                    System.out.println("Task2 kicked off");
                    Task2 task2 = new Task2(); //make an instance of Task2
                    Thread task2Thread = new Thread(task2); //make an instance of Thread class that is of task2 instance we created.
                    task2Thread.start();
                    
                    //Task3
                    System.out.println("Task3 kicked off");
                    for(int i = 301; i <= 399; i++)
                        System.out.print(i + " ");
                    System.out.println("\ntask 3 is done");
                    System.out.println("\nmain mehtod is done");
                }
            }
            
            class Task1 extends Thread {
            		@Override
                public void run() { //SIGNATURE
                    System.out.println("\nTask1 Started");
                    for(int i = 101; i<=199; i++)
                        System.out.print(i + " ");
                    System.out.println("\nTask1 Done");
                }
            }
            
            class Task2 implements Runnable {
                @Override
                public void run() {
                    System.out.println("\nTask2 Started");
                    
                    for(int i = 101; i<=299; i++)
                        System.out.print(i + " ");
                    System.out.print("\nTask2 Done");
                }
            }
            /*
            OUTPUT
            Task1 kicked off
            Task2 kicked off
            
            Task1 Started
            101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123
             124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 14
            6 147 148 149 Task3 kicked off
            301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323
             324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 34
            6 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364
            Task2 Started
            201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223
             224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 24
            6 247 248 249 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 1
            69 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191
            192 193 194 195 196 197 198 199
            Task1 Done
            365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387
             388 389 390 391 392 393 394 395 396 397 398 399
            task 3 is done
             main mehtod is done
            250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272
             273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 29
            5 296 297 298 299
            Task2
            */
            ```
            
            Now you see Task1 and Task2 and other codes in Main method are being executed simultaneously. Just focus on the fact that they are executed at the same time.
            
    - Theory - the states of threads
        1. NEW
            - explanation
                
                a thread is NEW when it’s ready to run but nobody has told it to start running. Thus, before the execution of the start method, the thread is in a state called NEW. 
                
                - basically the thread is new when it’s created.
                    
                    ```java
                    Task1 task1 = new Task1();
                    ```
                    
        2. RUNNABLE
            - explanation
                
                a thread is RUNNABLE when the content of other threads (that is simultaneously being executed) is executed.
                
                ex) for the Task1, when 201~299 are printed on console.
                
        3. RUNNING
            - explanation
                
                a thread is RUNNING when the content of its own is being executed.
                
                ex) for the Task1, when 101~199 are printed on console.
                
        4. BLOCKED/WAITING
            - explanation
                1. a thread is BLOCKED/WAITING, when let’s say, you’re waiting for an external service to respond or you’re talking to the database and the database is slow, then you’re being blocked because, you cannot execute, because you’re still waiting for some data to come back from an external source.
                2. a thread is also BLOCKED/WAITING, when you’re waiting for some other Threads to provide some data that you would need. So, let’s say, Thread3 is waiting for Thread1 to complete processing. In that kind of situation, you would be in a blocked state. 
        5.  TERMINATED/DEAD
            - explanation
                
                a thread is terminated when it is done executing. Thus, NEW is when you have not even started executing, while TERMINATED or DEAD is when you completed execution.
                
                the underlined part below is when the thread is TERMINATED/DEAD.
                
                ```java
                
                /*
                Task2 Started
                101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123
                 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 14
                6 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 1
                69 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191
                192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 197 198 199
                **Task1 Done**
                210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232
                 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 25
                5 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 2
                78 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299
                **Task2 Done**
                ```
                
    - Giving Priorities to Threads
        
        this is from the class Thread API
        
        | void | https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html#setPriority(int)(int newPriority)Changes the priority of this thread. |
        | --- | --- |
        
        the newPriority should be in the range of MIN_PRIORITY, NORM_PRIORITY, AND MAX_PRIORITY. And the below is the oracle api.
        
        | static int | https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html#MAX_PRIORITYThe maximum priority that a thread can have. |
        | --- | --- |
        | static int | https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html#MIN_PRIORITYThe minimum priority that a thread can have. |
        | static int | https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html#NORM_PRIORITYThe default priority that is assigned to a thread. |
        
        ```java
        package project;
        
        import java.util.*;
        import java.lang.Math;
        import java.util.stream.*;
        import static java.util.stream.Collectors.*;
        import java.util.function.*;
        
        public class Main {
            public static void main(String[] args){
                   //Task1
                System.out.println("Task1 kicked off");
                Task1 task1 = new Task1();
                task1.setPriority(10);//setting a high priority to task1.
                task1.start(); //if we do the task.run() it won't run in parallel with other threads, it will work as if it was a normal method, typical execution.
                                       
                //Task2
                System.out.println("Task2 kicked off");
                Task2 task2 = new Task2(); //make an instance of Task2
                Thread task2Thread = new Thread(task2); //make an instance of Thread class that is of task2 instance we created.
                task2Thread.setPriority(1);//setting a low priority to task2.
                task2Thread.start();
                
                //Task3
                System.out.println("Task3 kicked off");
                for(int i = 301; i <= 399; i++)
                    System.out.print(i + " ");
                System.out.println("\ntask 3 is done");
                System.out.println("\nmain mehtod is done");
            }
        }
        
        class Task1 extends Thread {
            public void run() { //SIGNATURE
                System.out.println("\nTask1 Started");
                for(int i = 101; i<=199; i++)
                    System.out.print(i + " ");
                System.out.println("\nTask1 Done");
            }
        }
        
        class Task2 implements Runnable {
            @Override
            public void run() {
                System.out.println("\nTask2 Started");
                
                for(int i = 201; i<=299; i++)
                    System.out.print(i + " ");
                System.out.print("\nTask2 Done");
            }
        }
        /*
        OUTPUT
        Task1 kicked off
        Task2 kicked off
        
        Task1 Started
        101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123
         124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 14
        6 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 1
        69 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191
        192 193 194 195 196 197 198 199
        Task1 Done
        Task3 kicked off
        301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323
         324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 34
        6 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 3
        69 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391
        392 393 394 395 396 397 398 399
        task 3 is done
        
        main mehtod is done
        
        Task2 Started
        201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223
         224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 24
        6 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 2
        69 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291
        292 293 294 295 296 297 298 299
        Task2 Done
        */
        ```
        
        you can see that task1 is completed before the task2 is completed. **YOU NEED TO KNOW** this: when you set the priority, it’s just a request. It does not mean that always that thread would get neither the highest priority nor the lowest. The request might be honored or might not be honored as well.
        
    - communication between threads
        - join() method
            
            join() method in java is provided by the java.lang.Thread class that permits one thread to wait until the other thread to finish its execution.
            
            `join()`: When the join() method is invoked, the current thread stops execution and the thread goes into the wait state. The current thread remains in the wait state until the thread on which the join() method is invoked has achieved its dead state. If interruption of the thread occurs, then it throws the InterruptedException.
            
            - code example
                
                ```java
                import java.util.*;
                import java.lang.Math;
                import java.util.stream.*;
                import static java.util.stream.Collectors.*;
                import java.util.function.*;
                
                public class Main {
                    public static void main(String[] args) throws InterruptedException {
                        //Task1
                        System.out.println("Task1 kicked off");
                        Task1 task1 = new Task1();
                        task1.setPriority(10);//setting a high priority to task1.
                        task1.start(); //if we do the task.run() it won't run in parallel with other threads, it will work as if it was a normal method, typical execution.
                
                        //Task2
                        System.out.println("Task2 kicked off");
                        Task2 task2 = new Task2(); //make an instance of Task2
                        Thread task2Thread = new Thread(task2); //make an instance of Thread class that is of task2 instance we created.
                        task2Thread.setPriority(1);//setting a low priority to task2.
                        task2Thread.start();
                
                        //wait for task1 to complete
                        task1.join(); //before the task3 kicked off, task1 had completed its execution.
                        task2Thread.join(); // only when both task1 and task2 is completed, the task3 will get kicked off.
                        //Task3
                        System.out.println("Task3 kicked off");
                        for(int i = 301; i <= 399; i++)
                            System.out.print(i + " ");
                        System.out.println("\ntask 3 is done");
                        System.out.println("\nmain mehtod is done");
                    }
                }
                
                class Task1 extends Thread {
                    public void run() { //SIGNATURE
                        System.out.println("\nTask1 Started");
                        for(int i = 101; i<=199; i++)
                            System.out.print(i + " ");
                        System.out.println("\nTask1 Done");
                    }
                }
                
                class Task2 implements Runnable {
                    @Override
                    public void run() {
                        System.out.println("\nTask2 Started");
                
                        for(int i = 201; i<=299; i++)
                            System.out.print(i + " ");
                        System.out.print("\nTask2 Done");
                    }
                }
                ```
                
    - keywords - sleep, yield
        
        [a-very-good-explanation](https://www.youtube.com/watch?v=_c784Dgj39o)
        
        ### Sleep()
        
        In java if a thread doesn’t want to perform any operation for a particular amount of time then we should go for the sleep() method, which causes the currently executing tread to stop for the specified number of milliseconds.
        
        **Syntax :**
        
        ```java
        public static native void sleep( long ms) throws InterruptedException ;
        // The above method put the thread in sleep for a specified number of millisecond
        ```
        
        ```java
        public static void sleep(long ms , int ns) throws InterruptedException
        // The above method also put the thread in sleep for a specified number of milliseconds
        // plus specified number of nanoseconds
        ```
        
        - code example
            
            ```java
            // Java Program to illustrate sleep method
            
            // Importing all input output classes
            import java.io.*;
            // Importing all utility classes from
            // java.util package
            import java.util.*;
            
            // Main class
            class GFG {
            
            	// Main driver method
            	public static void main(String[] args)
            		throws InterruptedException
            	{
            
            		// Iterating using simple for loops
            		for (int i = 0; i <= 10; i++) {
            
            			// Printing the current thread slide
            			System.out.println("slide-" + i);
            
            			// Putting the main thread to sleep for 5 second
            			Thread.sleep(5000);
            		}
            
            		// Here after every 5 seconds a slide will be
            		// printed
            	}
            }
            ```
            
        
        ### Yield()
        
        If a thread wants to pause its execution to give chance for the remaining thread of the same priority then we should go for the yield method.
        
        It’s basically a request or a hint to a scheduler. Te scheduler might ignore the request.
        
        Situation: 
        
        → request: I had enough time in the limelight. I have enough CPU. SO, I’m okay to give up CPU. But the scheduler can tell back saying no, no, no. You should have the CPU, take it. 
        
        **Syntax:**
        
        ```
        public static native void yield( );
        ```
        
        - code example
            
            ```java
            // Java Program to illustrate yield() method
            
            // Importing input output classes
            import java.io.*;
            // Importing all utility classes
            import java.util.*;
            
            // Class 1
            // Helper class extending Thread class
            
            // Creating a thread in our myThread class
            // by extending the Thread class
            
            class myThread extends Thread {
            
            	// Method in helper class
            	// Declaring run method
            	public void run()
            	{
            
            		// Displaying the message
            		System.out.println("Child Thread");
            
            		// Calling yield() method
            		Thread.yield();
            	}
            }
            
            // Class 2
            // Main class
            class GFG {
            
            	// Main driver method
            	public static void main(String[] args)
            		throws InterruptedException
            	{
            
            		// Creating a thread object in the main() method
            		// of our helper class above
            		myThread t = new myThread();
            
            		// Starting the above thread created
            		// using the start() method
            		t.start();
            
            		// Iterating using for loop
            		// over custom taken size equals 5
            		for (int i = 0; i < 5; i++) {
            			// Display message
            			System.out.println("Main Thread");
            		}
            	}
            }
            ```
            
    - keyword - synchronized
        
        in [oracle java api doc](https://docs.oracle.com/javase/8/docs/api/java/util/Hashtable.html), it says, “`Hashtable` is synchronized. If a thread-safe implementation is not needed, it is recommended to use `[HashMap](https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html)` in place of `Hashtable`. If a thread-safe highly-concurrent implementation is desired, then it is recommended to use `[ConcurrentHashMap](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html)` in place of `Hashtable`.”
        
        most of the methods in hashTable have a synchronized keyword. Now, what does the synchronized mean? Lets say, there is a piece of data that is shared between the two threads. Let’s say these two threads share an instance of a HashTable. When you put a synchronized on here, then only one of these two Threads, either the Task1 or Task2 , will be able to execute the code in any of the synchronized methods. Let’ say you have 50 synchronized methods that  have 1000 lines of synchronized code and only one of the Threads would be able to execute any of these 1000 lines of code. If one thread’s already executing any of these 1000 lines of code, then the other Thread has to wait for the first Thread to complete execution of the synchronized code and come out of it before it can get the access to execute the method.   
        
    - Executor Service
        
        The ExecutorSerive interface extends Executor by adding methods that help manage and control the execution of threads. It is defined in **[java.util.concurrent package](https://www.geeksforgeeks.org/tag/java-concurrent-package/).** It defines methods that execute the threads that return results, a set of threads that determine the shutdown status. The ExecutorService interface is implemented in a utility class called Executors. It defines methods that provide an implementation of the ExecutorService interface and many other interfaces, with some default settings.
        
        The class hierarchy is as follows:****
        
        ```
        --> java.util.concurrent **Package**
            --> Interface ExecutorService **Class**
        ```
        
        - code example (single thread)
            
            ```java
            import java.util.concurrent.ExecutorService;
            import java.util.concurrent.Executors;
            
            public class Main{
              public static void main(String[] args){
                ExecutorService executorService = Executors.newSingleThreadExecutor();//executes a thread at a time.
                // both way work the same.
                executorService.execute(new Task1());
                executorService.execute(new Thread(new Task2())); 
            
                //Task3
                System.out.println("Task3 kicked off");
                for(int i = 301; i <= 399; i++)
                    System.out.print(i + " ");
                System.out.println("\ntask 3 is done");
                System.out.println("\nmain mehtod is done");
            
                executorService.shutdown();//if you don't do this, the program will still be running.
              }
            }
            
            import java.util.*;
            import java.lang.Math;
            import java.util.stream.*;
            import static java.util.stream.Collectors.*;
            import java.util.function.*;
            
            class Task1 extends Thread {
                public void run() { //SIGNATURE
                    System.out.println("\nTask1 Started");
                    for(int i = 101; i<=199; i++)
                        System.out.print(i + " ");
                    System.out.println("\nTask1 Done");
                }
            }
            
            class Task2 implements Runnable {
                @Override
                public void run() {
                    System.out.println("\nTask2 Started");
                    
                    for(int i = 101; i<=299; i++)
                        System.out.print(i + " ");
                    System.out.print("\nTask2 Done");
                }
            }
            ```
            
            OUTPUT:
            
            ![Untitled](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Untitled%2017.png)
            
            explanation: you can see that the task1 is executed simultaneously with the task3. since we executed the task1 and task2 with the singlethread executor, the task2 was executed after the task1 had done being executed. This is when we used only one thread.
            
        - code example (multi thread)
            
            one thing that we changed from the previous code example is that we not use `newFixedThreadPool()` method to create multi thread, instead of a single thread. Inside the parenthesis, you should put the number of threads you want to create.
            
            ```java
            import java.util.concurrent.ExecutorService;
            import java.util.concurrent.Executors;
            
            public class Main {
              public static void main(String[] args) {
                ExecutorService executorService = Executors.newFixedThreadPool(2);//use this when you want the program have multiple threads. in the parenthesis, put the number of threads you want to create.
                // both way work the same.
                executorService.execute(new Task1());
                executorService.execute(new Thread(new Task2()));
            
                // Task3
                System.out.println("Task3 kicked off");
                for (int i = 301; i <= 399; i++)
                  System.out.print(i + " ");
                System.out.println("\ntask 3 is done");
                System.out.println("\nmain mehtod is done");
            
                executorService.shutdown();// if you don't do this, the program will still be running.
              }
            }
            class Task1 extends Thread {
              public void run() { // SIGNATURE
                System.out.println("\nTask1 Started");
                for (int i = 101; i <= 199; i++)
                  System.out.print(i + " ");
                System.out.println("\nTask1 Done");
              }
            }
            
            class Task2 implements Runnable {
              @Override
              public void run() {
                System.out.println("\nTask2 Started");
            
                for (int i = 101; i <= 299; i++)
                  System.out.print(i + " ");
                System.out.print("\nTask2 Done");
              }
            }
            ```
            
            OUTPUT:
            
            ![Untitled](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Untitled%2018.png)
            
            explanation: the tasks2 started even before the task1 is done, since there are two threads now.
            
        - code example (multi thread with the Task class)
            
            Here, I made the Task class which contains the constructor of the task instances and kept the number of threads as 2. This means only two threads can be active at the same time, meaning two thread can start almost simultaneously and once one of the two is done being executed, another thread could come in and occupy the empty spot.
            
            ```java
            import java.util.concurrent.ExecutorService;
            import java.util.concurrent.Executors;
            
            class Task extends Thread{
            
              private int number;
            
              public Task(int number){
                this.number = number;
              }
            
              public void run() {
                System.out.println("Task " + number + " Started." );
            
                for(int i=number*100; i<=number*100+99; i++)
                  System.out.print(i + " ");
                System.out.println("Task " + number + " Done.");
              }
            }
            
            public class Main {
              public static void main(String[] args) {
                ExecutorService executorService = Executors.newFixedThreadPool(2);// use this when you want the program have
                                                                                  // multiple threads. in the parenthesis, put the
                                                                                  // number of threads you want to create.
                // both way work the same.
                executorService.execute(new Task(1));
                executorService.execute(new Task(2));
                executorService.execute(new Task(3));
                executorService.execute(new Task(4));
            
                executorService.shutdown();// if you don't do this, the program will still be running.
              }
            }
            ```
            
            ![Untitled](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Untitled%2019.png)
            
            explanation: at the beginning, there were two tasks executed, since there were two threads. As soon as the task1 was done being executed, the task3 came in and started executing. Once the task1 was done being executed, the task4 came to occuy the vacancy, and so on and so forth.
            
        - code Example (creating task which returns a value)
            
            Until now, to create Threads, we were implementing a Runnable interface. But for implementing a task which returns value, we have to implement a Callable interface.
            
            ```java
            package project2;
            
            import java.util.concurrent.Callable;
            import java.util.concurrent.ExecutorService;
            import java.util.concurrent.Executors;
            import java.util.concurrent.*;
            
            class CallableTask implements Callable<String> {
            
              private String name;
              
              public CallableTask(String name){
                this.name = name;
              }
              
              @Override
              public String call() throws Exception {
                Thread.sleep(1000); //typically when you are executing a Thread, you would do a  lot of processing in it. 
                //What we are doing in here is, doing a lot of processing and then finally returning a value.
                return "Hello " + name;
              }
            }
            
            // want to create a task that return a value back
            public class CallableRunner {
              public static void main(String[] args)  throws InterruptedException, ExecutionException {
            
                ExecutorService executorService = Executors.newFixedThreadPool(1);
                Future<String> welcomeFuture = executorService.submit(new CallableTask("Lukas"));//if you are about to execute a task that returns a certain value, you have to use submit(), not the execute().
                //Future is not really a result, it's a promise that there will be a result.
                //Once I call a get() method on the Future, then this would wait for the task to complete execution.
                System.out.println("new CallableTask Lukas executed.");
                
                String welcomeMessage = welcomeFuture.get();//getting the return value. This creates some Exceptions.
            
                System.out.println(welcomeMessage);
            
                System.out.println("Main Completed.");}
            }
            ```
            
            ![Untitled](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Untitled%2020.png)
            
        - code example (Waiting for completion of multiple tasks using invo)
            
            ***CallableTask.java***
            
            ```java
            package project2;
            
            import java.util.concurrent.Callable;
            import java.util.concurrent.ExecutorService;
            import java.util.concurrent.Executors;
            import java.util.concurrent.*;
            
            public class CallableTask implements Callable<String> {
            
              private String name;
              
              public CallableTask(String name){
                this.name = name;
              }
              
              @Override
              public String call() throws Exception {
                Thread.sleep(1000); //typically when you are executing a Thread, you would do a  lot of processing in it. 
                //What we are doing in here is, doing a lot of processing and then finally returning a value.
                return "Hello " + name;
              }
            ```
            
            ***MultiCallableRunner.java***
            
            ```java
            package project2;
            
            import java.util.concurrent.*;
            import java.util.*;
            
            public class MutipleCallableRunner {
                public static void main(String[] args) throws InterruptedException, ExecutionException{
                    
                    ExecutorService executorService = Executors.newFixedThreadPool(3);
                    
                    List<CallableTask> tasks = new ArrayList<>();
                    tasks.add(new CallableTask("Lukas"));
                    tasks.add(new CallableTask("James"));
                    tasks.add(new CallableTask("Christina"));
                    
                    List<Future<String>> results = executorService.invokeAll(tasks);
                    
                    for(Future<String> result : results){
                        System.out.println(result.get());
                    }
                    executorService.shutdown();
                }
            }
            ```
            
            ![Untitled](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Untitled%2021.png)
            
        - code example(Wait for only the fastest task using invokeAny)
            
            In the previous step, we executed multiple tasks and we waited for all of them to complete execution. However, some of the times you would want to wait for only one of them to complete execution and take the result of the one which completes first. ExecutorService also allows us to do that.
            
            ***CallableTask.java***
            
            ```java
            package project2;
            
            import java.util.concurrent.Callable;
            import java.util.concurrent.ExecutorService;
            import java.util.concurrent.Executors;
            import java.util.concurrent.*;
            
            public class CallableTask implements Callable<String> {
            
              private String name;
              
              public CallableTask(String name){
                this.name = name;
              }
              
              @Override
              public String call() throws Exception {
                Thread.sleep(1000); //typically when you are executing a Thread, you would do a  lot of processing in it. 
                //What we are doing in here is, doing a lot of processing and then finally returning a value.
                return "Hello " + name;
              }
            }
            ```
            
            ***MultipleAnyCallableRunner.java***
            
            ```java
            package project2;
            
            import java.util.concurrent.ExecutorService;
            import java.util.concurrent.Executors;
            import java.util.*;
            import java.util.concurrent.*;
            
            public class MultipleAnyCallableRunner {
                
                public static void main(String[] args) throws InterruptedException, ExecutionException{
                    
                    ExecutorService executorService = Executors.newFixedThreadPool(1);
                    
                    List<CallableTask> tasks = new ArrayList<>();
                    tasks.add(new CallableTask("Lukas"));
                    tasks.add(new CallableTask("James"));
                    tasks.add(new CallableTask("Christina"));
                    
                    String result = executorService.invokeAny(tasks);
                    
                    System.out.println(result); //could be Hello James | Hello Lukas | Hello Christina
                                                //if there was only one thread pool, only Hello Lukas will be printed.
                    
                    executorService.shutdown();
                }
            }
            ```
            
            OUTPUT INCLUDED IN THE COMMENT
            
        - review
            
            In the multithreading section, we started with the basics of how to create a Thread. We looked at two ways of creating a Thread: extending a Thread and implementing Runnable interface.
            
            We also looked at the different states that a Thread can be in, other than trying to set different properties for different Threads and waiting for Threads to complete execution, trying to establish communication between the Threads. We understood that execution of Threads, in the most basic way, is not very easy and that’s where we introduced ExecutorService and ExecutorService provides options for you to decide how many Threads would be processing the tasks.
            
            We saw that ExecutorSerive also provides a way where you can get the results from a Thread and this was done using something called a Future.
            
            And when we invoke the get method on the Future, we would wait for the result to come back and at the end of this section, we looked at executing multiple tasks at the same time and waiting for all of them to complete using invokeAll().
            
            We also looked at how to wait for one of the tasks to complete, take the result, and use it in the step where we discussed about invokeAny(). Multithreading is always a very, very interesting concept because we always want to do things fast, we would want to run as many task as possible in parallel. So, you’d want to create a number of Threads to process tasks and that’s where EcxecutorSerive makes things very, very easy.
            
- Exception handling
    
    **EXCEPTION/ERROR HANDLING**
    
    - what is an Exception handing
        
        exception and error are like destiny vs fatality.
        
        The main difference between the two is that **error** happens regardless of your code, what you intended, etc. Errors are usually related to the coding environment. Examples of errors include memory shortage, errors in OS, or even blackout of your computers. You cannot handle errors.
        
        **Exception**, however, is when you confront an unforeseen situation. For instance, you try to call a file you thought existed. 
        
        In Java, when an exception happens, the code doesn’t proceed anymore.
        
        ```java
        Public class ExceptionApp {
        	public static void main(String[] args) {
        		System.out.println(1);
        		System.out.println(2/0);// not divisible by 0
        		System.out.println(3);
        	}
        }
        /*
        1
        Exception in thread "main" java.lang.ArithmeticException: / by zero
        	at ExceptionApp.main(ExceptionApp.java:4)
        */
        ```
        
        However, if we want to do something when a certain error happens corresponding to our intention in executing the whole codes, exception handling should come in handy.
        
        ```java
        package Exception;
        
        public class ExceptionApp {
            public static void main(String[] args) {
                int[] intArr = {1, 2, 3, 4, 5};
                try {
                    System.out.println(intArr[5]);
                } catch(ArrayIndexOutOfBoundsException e) {
                    //getMessage() shows you the reason for exception.
                    System.out.println("The array is too short for your value " + "... reason: " + e.getMessage());
                    //printStackTrace() shows you the original error message you would have gotten without the try-catch.
                    //this is important because it makes it easier for you to realize there was an error by popping up with red color.
                    e.printStackTrace();
                }
                System.out.println(1);
                try {
                    System.out.println(2/0);
                } catch (ArithmeticException e) {
                    System.out.println("Any number is indivisible by 0 " + "...reason: "  + e.getMessage());
                    e.printStackTrace();
                }
                // When you use try-catch, the next code will be executed.
                System.out.println(3);
            }
        }
        
        //WHAT THIS RETURNS
        /*
        The array is too short for your value ... reason: Index 5 out of bounds for length 5
        1
        Any number is indivisible by 0 ...reason: / by zero
        3
        */
        ```
        
         Exception follows the pattern of inheritance. “Exception” being the parent exception for all sub-exceptions, there are many more exceptions as you can check via the picture below. The sub-classes of Exception can be found [here](https://docs.oracle.com/javase/7/docs/api/java/lang/Exception.html).
        
        It will be smart if you sequentially write different try-catch statements from the most narrow one to the most broad one.
        
        ![Untitled](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Untitled%2022.png)
        
        **Unchecked Exception vs Checked Exception** 
        
        ## UnChecked Exceptions (Runtime exceptions and its children)
        
        These are the exceptions that are optional to be handled during the time of coding. It’s up to us whether we handle them or not. In case if we fail to handle them, There is a chance of getting runtime errors during the execution. For ex: We have something called NullPointerException, ArithemeticException, NosSuchElementFoundException and so on. These are like optional things we don’t even have to handle them. Moreover, even jvm or compiler will not recommend us to handle them.**
        
        ## *Checked Exceptions (Non - runtime exceptions)
        
        Exceptions which are to be checked or handled or should be taken care during the time of writing the code are called as checked exceptions. For eg: 1. we have FileNotFoundException --> which will be occured when we are writing some code related to file classes. There will be posibility of non existence of file. In such case, in order to handle them, we are forced to handle those exception. 2. one more example is ParseException ,which will be occured when we are dealing with date functions.
        
        one example of checked exceptions
        
        ```java
        import java.io.IOException;
        
        public class CheckedExceptionApp {
        	public static void main(String[] args) {
        		try {
        				FileWriter f = new FileWriter("data.txt");
        				f.write("Hello");
        				f.close();
        				} catch(IOException e){
        						e.printStackTrace();
        				}
        		}
        }
        ```
        
        **Java Resources** 
        
        Java can access the outternal data like DB, Newtwork, or Files. We call it RESOURCE. 
        
    - two keys in the Exception handling
        
        **REMEMBER**
        
        > Both good and bad programmers cause Exceptions
        > 
        
        **TWO KEYS**
        
        - Friendly message to end user.
        - Enough information to debug the problem.
    - Basics of Exceptions
        
        **NullpointerException and StackTrace**
        
        [StackTrace explanation](https://rollbar.com/blog/java-stack-trace/) → you can simply say that StackTrace is a line pops up in the console when exception happens.
        
        code that generates the NullpointerException
        
        ```java
        package project;
        
        public class ExceptionHandlingRunner {
            public static void main(String[] args){
                method1();
                System.out.println("Main Ended");
            }
            private static void method1() {
                method2();
                System.out.println("Method1 Ended");
            }
            private static void method2() {
                String str = null;
                str.length();
                System.out.println("Method2 Ended");
            }
        }
        ```
        
        ![Untitled](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Untitled%2023.png)
        
        In this code example, method2() is where the exception occurs. And the exceptions go up the call chain. Here, method2() causes the exception and it’s called from method1(). So, it goes to method1 which is called from main() method. And if at the end, main is the final authority and it’s not being able to handle it, then it would throw it out. → This is what we see in the output(console) when we execute the program. 
        
        - try&catch
            - you can have multiple catch  blocks, you can have different strategies to handle different kinds of exceptions. When exception happens, the most specific of those exceptions is the one that matches.
        - finally
            
            **one of the things about a Scanner is, after using a Scanner, You should call scanner.close(); If you don’t call it, there might be some resource leakage. So, there might be some memory leaks. To ensure the scanner object is closed, you can use finally statement.
            
            ```java
            package project;
            
            import java.util.Scanner;
            
            public class FinallyRunner {
                public static void main(String[] args){
                    Scanner scanner = new Scanner(System.in);
                    try {
                        int[] numbers = {1, 2, 3, 4, 5};
                        int number = numbers[5];
                    } catch(Exception e){
                        e.printStackTrace();
                    } finally {
                       //how we can ensure the scanner is closed even if the exeception is generated. 
                      System.out.println("Before Scanner Close.");
                        if(scanner != null){
                         scanner.close();   
                        }
                    }
                }
            }
            ```
            
            OUTPUT:
            
            ![Untitled](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Untitled%2024.png)
            
            ***Puzzle 1.***
            
            ```java
            //Will finally be executed in the program below?
                private static void method2(){
                    Connection connection = new Connection();
                    connection.open();
                    try {
                        //Logic
                        String str = null;
                        str.toString();
                        return;
                    } catch (Exception e) {
                    }finally {
                        connection.close();
                    }
                }
            ```
            
            In this case, finally statement will be executed no matter whether there is an exception of return.
            
            ***Puzzle 2. When is the finally statement not executed?***
            
            [Is finally block always get executed in Java?](https://www.tutorialspoint.com/is-finally-block-always-get-executed-in-java)
            
        - Checked & Unchecked Exceptions
            
            ```java
            public class CheckedExceptionRunner {
                public static void main(String[] args){
                    //just by saying Thread.sleep(2000),
                    // it generates the unhandled Exception, InterruptedException
            
                    //first way to handle (use try catch)
                    try {
                        Thread.sleep(2000);
                    } catch(InterruptedException e) {
                        e.printStackTrace();
                    }
                    //call someOtherMethod
                    **someOtherMethod();** // the ide tells us to still handle the exception, while
                    someOtherMethod2();// this doesn't tell us to.
                }
                //second way to handle the exception: throwing
                private static void someOtherMethod() throws InterruptedException {
                    Thread.sleep(2000);
                }
                private static void someOtherMethod2() throws RuntimeException {
                    
                }
            }
            ```
            
            explanation: in this example, we handled the InterruptedException by using two methods: using try & catch and using the throws. when we used the throws for the other methods (not the main one) and called both methods in main, the method that threw the InterruptedException generated the exception in the main, while the one that threw RuntimeException didn’t. Then, what is the difference between two exceptions? 
            
            **What you can guess:** when certain exceptions happen , you are forced to handle them, while the other exceptions happen, you aren’t.
            
            - Exception Hierarchy
                
                ```java
                //Pre-defined Java Classes
                class Error extends Throwable{}
                class Exception extends Throwable{}
                class InterruptedException extends Exception{}
                class RuntimeException extends Exception{}
                class NullPointerException extends RuntimeException{}
                ```
                
                The super class of all Exception is Throwable class that has two sub-classes, Error and Exception, right under it.
                
                Error is something a programmer cannot handle, while the Exception can be handled by the programmer.
                
                Among the Exceptions, there are two kinds of Exceptions typically generated. One is UnChecked Exception and the other is Checked Exception. The UnChecked Exceptions means RuntimeException and its child and they don’t generate a message on ide to force programmers to handle them. The Checked Exceptions are the Exceptions other than UnCheckedException and they generate the message on ide.
                
        - Throwing Exceptions
            
            ```java
            class Amount {
                private String currency;
                private int amount;
            
                public Amount(String currency, int amount0) {
                    this.currency = currency;
                    this.amount = amount;
                }
                public void add(Amount other){
                    if(this.currency.equals(other.currency)){this.amount += other.amount;}
                    //throwing an Exception if the currencies don't match.
            				else{throw new RuntimeException("Currencies Don't match");}
                }
                public String toString(){
                    return amount + " " + currency;
                }
            }
            public class ThrowingExceptionRunner {
                public static void main(String[] args) {
                    Amount amount1 = new Amount("USD", 10);
                    Amount amount2 = new Amount("EUR", 20);
                    amount1.add(amount2);
                    System.out.println(amount1);
                }
            }
            ```
            
            OUTPUT:
            
            ![Untitled](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Untitled%2025.png)
            
            explanation: here we threw the RuntimException because when we throw just normal Exceptoin which has two possibilities: checked/unchecked, we would be forced to handle the exception. 
            
            ***when we throw the normal Exception.***
            
            ```java
            class Amount {
                private String currency;
                private int amount;
            
                public Amount(String currency, int amount0) {
                    this.currency = currency;
                    this.amount = amount;
                }
                public void add(Amount other) throws Exception{
                    if(this.currency.equals(other.currency)){this.amount += other.amount;}
                    else{throw new Exception("Currencies Don't match " + this.currency +
                            " " + other.currency);}
                }
            
                public String toString(){
                    return amount + " " + currency;
                }
            
            }
            public class ThrowingExceptionRunner {
                public static void main(String[] args) throws Exception{
                    Amount amount1 = new Amount("USD", 10);
                    Amount amount2 = new Amount("EUR", 20);
                    amount1.add(amount2); // this line will force you to handle the exception.
                    System.out.println(amount1);
                }
            }
            ```
            
            OUTPUT:
            
            ![Untitled](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Untitled%2026.png)
            
        - Throwing Custom Exceptions
            
            you create a custom exception class that extends an exception. Depending on what kind of exception you are extending, you might be forced to throw exceptions.
            
            ```java
            class Amount {
                private String currency;
                private int amount;
            
                public Amount(String currency, int amount) {
                    this.currency = currency;
                    this.amount = amount;
                }
                public void add(Amount other) throws CurrenciesDoNotMatchException{
                    if(this.currency.equals(other.currency)){this.amount += other.amount;}
                    else{throw new CurrenciesDoNotMatchException("Currencies do not match " +
                            this.currency + " & " + other.currency);}
                }
            
                public String toString(){
                    return amount + " " + currency;
                }
            }
            
            //making a custom exception
            class CurrenciesDoNotMatchException extends Exception{
                //adding message as a body
                public CurrenciesDoNotMatchException(String msg){
                    super(msg);
                }
            }
            public class ThrowingExceptionRunner {
                public static void main(String[] args) throws CurrenciesDoNotMatchException{
                    Amount amount1 = new Amount("USD", 10);
                    Amount amount2 = new Amount("EUR", 20);
                    amount1.add(amount2); // this line will force you to handle the exception.
                    System.out.println(amount1);
                }
            }
            ```
            
            OUTPUT:
            
            ![Untitled](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Untitled%2027.png)
            
        - Write less code with Try with Resources - new feature in Java 7
            
            In Java, the Try-with-resources statements is a try statement that declares one or more resources in it. A resource is an object that must be **closed** once your program is done using it. For example, a File resource or a Socket connection resource. The try-with-resources statement ensures that each resource is closed at the end of the statement execution. If we don’t close the resources, it may constitute a resource leak and also the program could exhaust the resources available to it.
            
            You can pass any object as a resource that implements *java.lang.Autocloseable*, which includes all objects which implement java.io.Closeable.
            
            by this, now wer don’t need to add an extra finally block for just passing the closing statements of the resources. The resources will be closed as soon as the try block is executed.
            
            **Syntax: Try-with-resources**
            
            ```java
            try(declare resources here) {
            	//use resources
            }
            catch(FileNotFoundException e){
            	//exception handling
            }
            ```
            
            **Exceptions:**
            
            when it comes to exceptions, there is a difference in try-catch-finally block and try-with-resources block. If an exception is thrown in both try block and finally block, the method returns the exception thrown in finally block.
            
            For try-with-resources, if an exception is thrown in a try block and in a try-with-resources statement, then the method returns the exception thrown in the try block. The exceptions thrown by try-with-resources are suppressed, i.e. we can say that try-with-resources block throws suppressed exceptions.
            
            **examples**
            
            ```java
            package project1;
            
            import java.util.Scanner;
            
            public class TrywithResource {
            
            	public static void main(String[] args) {
            		try(Scanner scanner = new Scanner(System.in)){
            			int[] numbers = {12, 3, 4, 5};
            			int number = numbers[21]; // generates the exception.
            		}
            	}
            }
            ```
            
            ```java
            package project1;
            
            import java.io.*;
            //SINGLE RESOURCE
            public class TrywithResource {
            
            	public static void main(String[] args) {
            		try(FileOutputStream fos = new FileOutputStream("textfile.txt")){
            			String text = "Hello World. This is my java program.";
            			byte arr[] = text.getBytes();
            			fos.write(arr);
            		} catch (Exception e) {
            			System.out.println(e);
            		}
            		System.out.println("Resource are closed and message "
            				+ "has been written into the textfile.txt");
            	}
            }
            /* OUTPUT
            Resource are closed and messagehas been written into the textfile.txt
            */
            ```
            
            ```java
            package project1;
            
            import java.io.*;
            
            public class TrywithResource {
            
            	public static void main(String[] args) {
            		try(FileOutputStream fos = new FileOutputStream("outputfile.txt");
            			BufferedReader br = new BufferedReader(new FileReader("textfile.txt"))){
            			String text;
            			while((text = br.readLine()) != null) {
            				byte arr[] = text.getBytes();
            				fos.write(arr);
            			}
            			System.out.println("file content copied to another one.");
            		}catch(Exception e) {
            			System.out.println(e);
            		}
            		System.out.println("Resources are closed an message has been written "
            				+ "into the textfile.txt");
            	}
            }
            /*output
            file content copied to another one.
            Resources are closed an message has been written into the textfile.txt
            */
            ```
            
        - things
            
            ```java
            package project1;
            
            class Amount {
                private String currency;
                private int amount;
            
                public int getAmount() {
            		return amount;
            	}
            	public void setAmount(int amount) {
            		this.amount = amount;
            	}
            	public Amount(String currency, int amount) {
                    this.currency = currency;
                    this.amount = amount;
                }
                public void add(Amount other) throws CurrenciesDoNotMatchException{
                    if(this.currency.equals(other.currency)){this.amount += other.amount;}
                    else{throw new CurrenciesDoNotMatchException("Currencies do not match " +
                            this.currency + " & " + other.currency);}
                }
            
                public String toString(){
                    return amount + " " + currency;
                }
            }
            
            class AmountAdder {
            	void addAmounts(Amount am, int num) {
            		am.setAmount(am.getAmount() + num);
            	}
            }
            
            //making a custom exception
            class CurrenciesDoNotMatchException extends Exception{
                //adding message as a body
                public CurrenciesDoNotMatchException(String msg){
                    super(msg);
                }
            }
            
            public class ThrowingExceptionRunner {
                public static void main(String[] args) {
                    Amount amount1 = new Amount("USD", 10);
                    Amount amount2 = new Amount("EUR", 20);
                    amount1.add(amount2); // this line will force you to handle the exception.
                    System.out.println(amount1);
                   try { 
                    AmountAdder amAdder = new AmountAdder();
                    amAdder.addAmounts(amount1, 5);
                    String str = null;
                    str.toString();
                   } **catch (Exception e) {
                	   System.out.println("Handled exception");
                   } catch (CurrenciesDoNotMatchException e) {
                	   System.out.println("Handled CurrenciesDoNotMatch exception.");
                   }**
                }
            }
            ```
            
            the underlined part generates an error because the hierarchy is not right. error message is below.
            
            *Unreachable catch block for CurrenciesDoNotMatchException. It is already handled by the catch block for Exception*
            
            - handling multiple exceptions
                
                **syntax**
                
                ```java
                try {
                	//code
                } catch (IOException | SQLExceptino ex) {
                		ex.printStackTrace();
                }
                ```
                
- files and directory
    - Listing files&directories in a directory
        
        we will learn how to list files in a directory and how to search for the files. Also, we will learn how to read texts from a file and how to write on the file.
        
        1. created a project and under the project, created a folder called resources.
        2. under the src, created a class called DirectoryScanRunner w/ the main method in it.
        
        to list the files in the current directory, we would do this.
        
        ```java
        package project;
        
        import java.io.IOException;
        import java.nio.file.Files;
        import java.nio.file.Path;
        import java.nio.file.Paths;
        
        public class DirectoryScanRunner {
        
        	public static void main(String[] args) throws IOException {
        		// want to find out whatever is present in the current directory.
        		Files.list(Paths.get(".")).forEach(System.out::println); //currDirectory = "." usually means the root package
        	}
        }
        ```
        
        what this prints is below. 
        
        ```java
        /*
        .\.classpath
        .\.project
        .\.settings
        .\bin
        .\resources
        .\src
        */
        ```
        
        ![Untitled](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Untitled%2028.png)
        
        as you can see, under the project package, there are the files printed in the console. So this worked.
        
        Now let’s look at how we printed like that. The concept of functional programming also comes in here. the `list()` method under the Files class returns Stream<Path> and gets Path as a parameter. When getting the current directory path by doing `Paths.get(”.”)`, “.” means current directory, here it refers to the root package.
        
        ```java
        **public** **static** Stream<Path> list(Path dir) **throws** IOException {
        ```
        
        so for the stream that had been returned, we used `forEach()` method that you can recollect from the functional programming section.
        
    - Recursively List and Filter all files and folders in Directory
        - `Files.walk()`
            
            In the previous step, we wrote simple code to try and list all the files which are present in a specific folder. So, we listed both files and directories which are present in there. But sometimes, you would want to search the entire directory. So, you’d want to do it recursively. In those kind of situations, you can go for something called `Files.walk()`.
            
            ```java
            package project;
            
            import java.io.IOException;
            import java.nio.file.Files;
            import java.nio.file.Path;
            import java.nio.file.Paths;
            
            public class DirectoryScanRunner {
            
            	public static void main(String[] args) throws IOException {
            		// want to find out whatever is present in the current directory.
            		Path currentDirectory = Paths.get("."); //currDirectory = "." usually means the root package
            		//Files.list(currentDirectory).forEach(System.out::println); 
            		Files.walk(currentDirectory, 1).forEach(System.out::println);
            	}
            }
            ```
            
            this code’s output is the basically same output as that of previous step because the level is 1. (level is the 2nd parameter of the `walk()` method. It determines how deep you would want to search.) 
            
            ```java
            /*
            .\.project
            .\.settings
            .\bin
            .\resources
            .\src
            */
            ```
            
            when you do the level 4, it definitely prints more because it prints all the files&directories present in level 1, 2, 3, and 4.
            
            ```java
            package project;
            
            import java.io.IOException;
            import java.nio.file.Files;
            import java.nio.file.Path;
            import java.nio.file.Paths;
            
            public class DirectoryScanRunner {
            
            	public static void main(String[] args) throws IOException {
            		// want to find out whatever is present in the current directory.
            		Path currentDirectory = Paths.get("."); //currDirectory = "." usually means the root package
            		//Files.list(currentDirectory).forEach(System.out::println); 
            		Files.walk(currentDirectory, 4).forEach(System.out::println);
            	}
            }
            ```
            
            output is below.
            
            ```java
            /*
            .
            .\.classpath
            .\.project
            .\.settings
            .\.settings\org.eclipse.core.resources.prefs
            .\.settings\org.eclipse.jdt.core.prefs
            .\bin
            .\bin\module-info.class
            .\bin\project
            .\bin\project\DirectoryScanRunner.class
            .\resources
            .\src
            .\src\module-info.java
            .\src\project
            .\src\project\DirectoryScanRunner.java
            */
            ```
            
            Now you can try to filter out some files from here. The example below is an example where you use filter() method and inside the filter method, the predicate goes in.
            
            ```java
            import java.io.IOException;
            import java.nio.file.*;
            import java.util.function.Predicate;
            
            public class DirectoryScanerRunner{
                public static void main(String[] args) throws IOException {
                    Path currentDir = Paths.get(".");
                    //Files.walk(currentDir, 4).forEach(System.out::println);
                    Predicate predicate = path -> String.valueOf(path).endsWith(".java");
                    Files.walk(currentDir, 4).filter(predicate).forEach(System.out::println);
                }
            }
            
            //OUTPUT
            /*
            .\project\src\DirectoryScanerRunner.java
            .\src\DirectoryScanerRunner.java
            */
            ```
            
        - `Files.find()`
            
            in addition to the functionality of `Files.walk()`, Files.find() takes in a BiPredicate that is for condition checking and filtering. [some good explanations](https://mkyong.com/java/java-files-find-examples/)
            
            ```java
            import java.io.IOException;
            import java.nio.file.*;
            import java.nio.file.attribute.BasicFileAttributes;
            import java.util.function.BiPredicate;
            import java.util.function.Predicate;
            
            public class DirectoryScanerRunner{
                public static void main(String[] args) throws IOException {
                    Path currentDir = Paths.get(".");
                    BiPredicate<Path, BasicFileAttributes> javaMatcher =
                    (path, attributes) -> String.valueOf(path).contains(".java");
                    BiPredicate<Path, BasicFileAttributes> directoryMatcher =
                            (path, attributes) -> attributes.isDirectory();
                    Files.find(currentDir, 4, directoryMatcher)
                            .forEach(System.out::println);
                }
            }
            
            //OUPUT
            /*
            .
            .\.idea
            .\out
            .\out\production
            .\out\production\project
            .\out\production\untitled
            .\project
            .\project\src
            .\src
            */
            ```
            
- read from a file
    
    under the project, I made a folder called resources where I would store text files. And I made a text file called data.txt under the resources folder. the text file is as the following.
    
    ```
    123, 122
    afslkdjhad
    Apple
    Bat
    Cat
    ```
    
    ***FileReadRunner class***
    
    ```java
    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;
    import java.util.List;
    
    public class FileReadRunner{
        public static void main(String[] args) throws IOException {
    
            Path pathFileToRead = Paths.get("project/resources/data.txt");
            List<String> lines = Files.readAllLines(pathFileToRead);
            System.out.println(lines);
        }
    }
    
    //OUTPUT
    /*
    [123, 122, afslkdjhad, Apple, Bat, Cat]
    */
    ```
    
    reading file using a functional programming
    
    ```java
    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;
    import java.util.List;
    
    public class FileReadRunner{
        public static void main(String[] args) throws IOException {
    
            Path pathFileToRead = Paths.get("project/resources/data.txt");
            List<String> lines = Files.readAllLines(pathFileToRead);
            System.out.println(lines);
    
            //reading lines using functional programming
            Files.lines(pathFileToRead)
                    .map(String::toLowerCase)
                    .filter(str -> str.contains("a"))
                    .forEach(System.out::println);
    				//OUTPUT
    				/*
    				afslkdjhad
    				apple
    				bat
    				cat
    				*/
        }
    }
    ```
    
- write content to a file
    
    under the resources folder, I will create a file that has written contents by me.
    
    ```java
    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;
    import java.util.List;
    
    public class FileWriteRunner {
        public static void main(String[] args) throws IOException {
            Path pathFileToWrite = Paths.get("project/resources/file-write.txt");
            List<String> list = List.of("Apple", "Boy", "Cat", "Dog", "Elephant");
            Files.write(pathFileToWrite, list);
        }
    }
    ```
    
    Once you do this, There will be a file generated at the path you indicated with the indicated name also.
    
    ![Untitled](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Untitled%2029.png)
    
- 

[more concurrency with concurrent collections and atomic operations](Java%201b54d6a344e54c2fb43fa9388b6e93d8/more%20concurrency%20with%20concurrent%20collections%20and%20a%200213c2518ecc401abcc18f41529880e7.md)

- code generating (automatically) → Cmd + Option + S || Alt +Shift + S

[Email Application](Java%201b54d6a344e54c2fb43fa9388b6e93d8/Email%20Application%2076458dcbd52e4f6b93fc77294ddfdcd6.md)

- [97 things every programmer should know](https://www.notion.so/Programming-d89543ae8de74c34a2b5a59a13186545?pvs=21)

[https://www.abdulbari.in/courses](https://www.abdulbari.in/courses)

[https://quizlet.com/kr/668243802/백엔드-개발자-면접학습내용-flash-cards/?x=1jqt](https://quizlet.com/kr/668243802/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%A9%B4%EC%A0%91%ED%95%99%EC%8A%B5%EB%82%B4%EC%9A%A9-flash-cards/?x=1jqt)

[coding interview](https://www.techinterviewhandbook.org/coding-interview-prep/)

[teach yourself programming in ten years](https://norvig.com/21-days.html)

[pramp.com](http://pramp.com) 

[스터디](https://okky.kr/)

[jobreadyprogrammer.com](https://www.jobreadyprogrammer.com/)

[oop-projects(YouTube)](https://www.youtube.com/watch?v=qgqzq8tUoYY&list=PL78sHffDjI75_EK-m6CO6kc3NCyR6kKkX&index=19)

[java-challenges(YouTube)](https://www.youtube.com/watch?v=1T1KYNM9TTk&list=PLvQSG8B7sh6lJEXbVQMpQUX39NHtry0hi)

[java-tutorials](https://www.tutorialspoint.com/java/java_sending_email.htm)

[java-oop-projects](https://www.youtube.com/watch?v=U3Ibvu0htNs&list=PLMJlRf5sZ0zTN_ocpWCsWqaj02N4DVifM)

- object oriented programming
    - [OOP-basics to advance](https://www.udemy.com/course/oop-learnit/)