# 상속 관계에서 객체 생성 방법

- 퀴즈
    1. 상속관계에 있는 클래스를 객체생성 할 때 하위클래스의 객체를 생성 할 때 사용하는 메서드를 쓰시오.
        - answer
            
            super()
            
    2. Dog 클래스와 Animal 클래스가 상속관계일 때 Animal x = new Dog(); 처럼 객체를 생성하는 방법을 무엇이라고 하는가?
        - answer
            
            업캐스팅
            
    3. 상속관계에서 객체가 생성될 때 맨 위 부모클래스 부터 객체가 생성되어 자식까지 연결되는 구조를 무엇이라고 하는가?
        - answer
            
            상속 체이닝
            
    4. 실행시점에서 사용될 메서드가 결정되는 바인딩을 무엇이라고 하는가
        - answer
            
            동적 바인딩
            
    5. 상속관계에서 하위클래스가 상위클래스의 동작을 변경이나 추가하는 것을 무엇이라고 하는가?
        - answer
            
            오버라이딩
            

어떤 한 사람이 일반적으로 API를 배포할 때 소스코드를 올리지는 않는다. 그는 소스코드가 감춰져있는 클래스를 작동시킬 수 있는 실행코드를 배포한다. 이는 내부 정보를 은닉하는데 효과적이고 우리는 상속을 함으로써 그 효과를 얻을 수 있다.

Dog가 Animal을 상속한다고 가정해보자.

```tsx
Dog x = new Dog(); 
x.eat()
```

이런식으로 코드를 썼다고 가정해보면 우리는 Dog 클래스에 eat() 메서드가 존재한다는 것을 알아야 한다. 그런데 만약 웹상의 API같이 우리가 사용하고자 하는 클래스의 메서드 정보가 은닉되어 있다면 해당 방식은 무효하다.

```tsx
Animal x = new Dog();
x.eat() //만약 Dog에서 재정의를 안했으면 그냥 부모에 있는 eat()이 실행됨.
```

위와 같은 방식을 Upcasting이라고 부르는데 부모가 자식을 가리키는 객체생성 방법이다. 위 방식은 우리가 Dog class의 내부 구현을 몰라도(즉 Dog.java를 가지고 있는게 아니라 Dog.class를 가지고 있다면) 유효한 방식이므로 훨씬 효과적이고 지향해야될 방식이다.

![Untitled](%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%E1%84%8B%E1%85%A6%E1%84%89%E1%85%A5%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%89%E1%85%A2%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC%20%E1%84%87%E1%85%A1%E1%86%BC%E1%84%87%E1%85%A5%E1%86%B8%2008be7237b76b4cfdae3d4e1da662e70d/Untitled.png)

이것은 Animal x = new Dog()로 객체 생성을 했을 때의 메모리 구조인데, x의 궁극적인 타입이 Animal이므로 entry point가 Animal이 차지하고 있는 메모리의 시작점이면서 직접적으로 사용할 수 있는 메서드의 범위는Animal 상에 존재하는 메서드들이다. 그렇지만 x.eat()을 했을 때 Dog클래스 안에 선언된 메서드를 직접적으로 사용하는 것처럼 보이는 이유는 두 클래스가 상속 관계에 있을 때 부모 클래스의 메서드를 호출하면 자식 클래스에서 부모 클래스에 선언된 메서드를 override 했는지 안했는지를 살피게 된다. 만약 오버라이드를 했다면 동적 바인딩을 통해 컴파일 타임이 아닌 “런타임”시에 어떤 메서드가 불릴지 결정된다.

1. 컴파일시 eat() → 누구껀지 모름
2. 런타임시 eat() → 자식의 것

![Untitled](%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%E1%84%8B%E1%85%A6%E1%84%89%E1%85%A5%20%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%89%E1%85%A2%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC%20%E1%84%87%E1%85%A1%E1%86%BC%E1%84%87%E1%85%A5%E1%86%B8%2008be7237b76b4cfdae3d4e1da662e70d/Untitled%201.png)

**super()

상위 클래스의 생성자를 호출하는 메서드. 생성자 메서드에서 가장 첫 문장에 사용해야 한다. 한 클래스의 객체(인스턴스)가 생성되기 위해서는 그 클래스의 부모의 인스턴스가 먼저 메모리에 로드 되어야 하기 때문이다.

**override

자식이 메서드를 재정의함에 있어서 부모의 메서드가 무시당하는(shadowing) 것.

이렇게 상속을 해서 여러객체를 생성하면 설계간에 매우 유연해지는 결과를 낳을 수 있다.

예)

```tsx
public class OverrideTest {
	Animal ani = new Dog();
	ani.eat(); //개가 밥을 먹는다.
	ani = new Cat();
	ani.eat(); //고양이가 밥을 먹는다.
}
```