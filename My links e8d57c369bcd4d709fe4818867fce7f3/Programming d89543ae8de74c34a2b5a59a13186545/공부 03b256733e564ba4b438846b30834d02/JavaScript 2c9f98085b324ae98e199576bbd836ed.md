# JavaScript

Status: Done
Assign: GenuineLukas
subject: FrontEnd

JavaScript is the only programming language in the front end. when was the last time you had to install JavaScript on your computer? You DON’T Remember because JavaScript is implemented(preinstalled) in your browser!

- JS history
    
    자바 스크립트의 탄생 배경은…
    
    초창기 웹은 html과 css로만 이루어진 간단한 웹 문서였다. 하지만 위는 사용자와 인터렉션 할 수 있는 프로그래밍 언어(어떤 행동을 지시할 수 있는 명령어)가 필요했다. → 사용자의 이벤트에 반응하여 상호작용 할 수 있는 웹 → Netscape 의  LiveScript가 개발됨. → LiveScript는 넷스케이프사에서 개발한 Netscape Navigator 라는 브라우저 위에서 작동하는 언어 → 자세히 말하면 이 브라우저안에는 LiveScript를 해서할 수 있는 엔진이 있고 그 엔진이 LiveScript를 해석함으로써 HTML을 조작할 수 있다. → 개발자들의 HTML, CSS, LiveScript를 통해 웹 문서를 만들고, 이 웹문서를 Netscape Navigator 라는 브라우저에서 열면 사용자의 이벤트에 반응할 수 있는 웹을 만들 수 있었다. → 당시 인기있는 프로그래밍 언어인 Java의 이름을 착안해 LiveScript에서 JavaScript로 바꿨음. 이 때 웹 개발 언어로써 성공을 거둔 JavaScript에 감명을 받은 Microsoft사는 비슷한 언어인 JScript를 만들고 이 언어를 해석할 수 있는 엔진을 장착한 Internet Explorer 브라우저를 출시함. → 인터넷 익스플로러에서의 자바스크립트의 사용은 실레로는 JScript의 사용을 의미하는 것이다. JavaScript와 JScript는 서로 다른 언어이기 때문에 개발자들은 넷스케이프 네비게이터와 인터넷 익스플로러 각각 생각하면서 개발을 해야하는 번거로움이 발생하게 되었고 넷스케이프사는 웹 상에서 동작하는 언어를 표준화하기 위해 자바스크립트 기술 규격을 Ecma international 이라는 단체에 제출하였고 이 때 표준 명세인 ECMA Script가 나오게 됐다. → 하지만 점차 인터넷 익스플로러의 시장 점유율이 증가하고 Internet Explorer는 이 웹 표준을 지키지 않았다. 또한 firefox같은 더 많은 웹 브라우저들의 출현으로 개발자들의 번걷로움은 이루 말할 수 없이 커지게 되었다.→ JQuery 의 등장. → JQuery에서 모든 브라우저에 대한 대응을 한꺼번에 해주기 떄문에 개발을 편리하게 진행할 수 잇었다. →2008년 강력한 자바스크립트 엔진을 탑제한 Chrome이 나오게 되었고 개발자들이 ECMAScript표준화에 힘쓰게 되었다. ECMAScript 의 발전으로 더 이상 JQuery의 사용빈도도 줄어들었다. 
    
    우리가 JavaScript로 HTML을 조작할 수 있는 이유는 각 브라우저에서 Web API를 지원하기 떄문에 자바스크립트라는 언어로 이 Web API를 사용하여 HTML 요소를 조작할 수 있다.
    
- VS code
    - view → terminal : bring the terminal up.
    - extensions to download:
        - Korean language pack for visual studio code (if you want your VS code to be Korean)
        - Bracket Pair Colorizer
        - indent-rainbow
        - auto rename tag
        - css peak
        - HTML to CSS autocompletion
        - HTML CSS support
        - live server
        - prettier
            - in mac press cmd + comma(,) / in window ctrl + comma(,) to open up the settings.
            - in the search bar, search “format on save.” fill out the checkbox.
            - in the search bar, search “default format.” set the default formatter as “the prettier” we installed.
            - in the search, search “tab width”, and change the width to 2.
            - in the search bar, search “tab size.” set the size as 2.
            - in the search bar, search “quote.” set all the quote style as single.
- number
    
    ```jsx
    Math.ronud(); //반올림
    Math.ceil(); //올림
    Math.floor(); //내림
    Math.pow(a, b); //a의b승
    Math.random() //1보다 작은 랜덤 수
    //ex) Math.round(100&Math.random());
    ```
    
- string
    
    String goes in “”.
    
    ```jsx
    //syntax errors*******
    alert('coding everybody");
    alert("coding everybody');
    alert('everybody's coding');
    
    //good syntax
    alert("coding everybody");
    alert("coding everybody'");
    alert('everybody\'s coding'); //escape
    
    1 and "1" are different
    typeof 1 // "number"
    typeof "1" // "string"
    
    //줄바꿈
    alert("hey bro \nwhat's up"); // \n
    //문자열 더하기
    "coding" + " everybody";
    //더하기의 결과
    "1" + "1" // "11"
    1 + 1 // 2
    
    //string.length
    alert("hello everyone".length); //14
    //string.indexOf()
    alert("hello everyone".indexOf("e")); //1
    ```
    
- variable
    
    In JavaScript, a variable starts with var. you could exclude the var when declaring the variable, but until you know how removing var affects the “effective range”, you are encouraged to add var at front. 
    
    *** when you declare (making the variable), you should put var. Afterwards, however, you don’t need to.
    
    ```jsx
    const a = 1;
    const b = 3;
    alert(a + b); //4
    
    const c = "coding",
    const d = " everybody";
    alert(c + d); //coding everybody
    
    alert(a + b + c + b + a); //4coding31 <- 자바랑똑같
    ```
    
- boolean
    
    ```jsx
    const amIFat = true;
    console.log(amIFat);
    ```
    
- const and let
    
    `const`는 상수(const)이고 그 값이 정의된 이상 바뀔 수 없다.
    
    만약 변수를 선언해놓고 나중에 그 값을 업데이트 한다던지 하고 싶다면 `let`으로 선언을 하는것이 용이하고, 나중에 업데이트 시에 중복으로 let을 사용하지 않고 let 없이 업데이트 한다.
    
    기본적으로는 const를 사용하고, 필요할 때만 let을 사용하는게 좋다.
    
    there is an old-fashioned way to create variable using `var`. This way of creating variable isn’t recommended because the value can be updated in any moment/point of the code, therefore not informing us about the unprotected parts and errors. AGAIN, 기본적으로는 const를 사용하고, 필요할 때만 let을 사용하는게 좋다. Never use var!
    
- comment
    
    ```jsx
    //something
    /*
    여러줄
    여러줄
    여러줄
    */
    ```
    
- undefined v.null
    
    undefined → 그냥 진짜 값이 안 정해진거. 타입이 아님. 어떤 variable이 메모리에는 있는데, 값이 없는 거.
    
    ```jsx
    let something;
    console.log(something); //undefined
    ```
    
    null → 아무것도 없는 거. 아무것도 없는 상태가 정해진 것 → null도 하나의 타입임. null does not happen automatically. null은 우리가 variable 안에 어떤 것이 없다는 것을 확실히 하기 위해 쓰는 것.  
    
- arrays
    
    one of the data structure.
    
    ```jsx
    const daysOfWeek = ["mon", "tue", "wed", "thu", "fri", "sat"];
    //getting friday
    console.log(daysOfWeek[4]);
     //add one more day to the array
    daysOfWeek.push("sun");
    ```
    
    now you can wonder, “I thought variables defined with const cannot change. How did the content of the array change?”
    
    변수를 선언하면 주소값이 매핑되고 매핑된 주소부터 데이터가 표시됩니다. const는 선언한 주소를 바꿀수 없다고 보시면됩니다. const a = '111'; a는 111이라는 문자열정보가들어있는 메모리 주소를 가리키는거죠. 케비넷 위치라고할까. a = '222'; 는 222 가들어있는 데이터의 주소로 매핑정보를 바꾸는거라 보시면 됩니다. 배열에 요소를 추가하는건 주소를 바꾸는게 아니라 해당 주소의 데이터를 변경하는 거라 변수에 매핑된 메모리주소는 그대로여서 const 로 선언한 상태에서도 배열의 요소를 변경하는것이 가능하다고 이해하면 편할겁니다.
    
- Objects
    
    when adding a property using a string, [] is the only way to do so
    
    ```jsx
    const obj = {}
    // obj."a" = 1 Uncaught SyntaxError: Unexpected string
    obj.a = 1
    ```
    
    ```jsx
    const player = {
    	name : "nico",
    	points: 10,
    	fat: true,
    };
    console.log(player); //{name: "nico", points: 10, fat: true}
    console.log(player.name);//nico
    //another way to bring the property
    console.log(player["name"]);
    //updating the content
    player.fat = false;
    //adding content
    player.lastName = "potato";
    //you can also get something from the existing object to update the property
    player.points = player.points + 15; //now 25
    ```
    
    here we created out own object and called one of the properties by using the dot(.). Similarly, when you think of the console.log(), you can think of it as calling one property of the object “console.”
    
- function
    - Basic structure
        
        ```jsx
        funtion 함수명(인자...[,인자]]){
        	코드
        	return 반환값
        }
        ```
        
    - example 1
        
        ```jsx
        <!DOCTYPE html>
        <html>
          <head>
            <title>Parcel Sandbox</title>
            <meta charset="UTF-8" />
          </head>
        
          <body>
            <div id="app"></div>
            <script type="text/javascript">
              function numbering() {
                document.write(1);
              }
              numbering(); //함수 호출
              numbering();
              numbering();
              numbering();
            </script>
          </body>
        </html>
        ```
        
        ![Untitled](JavaScript%202c9f98085b324ae98e199576bbd836ed/Untitled.png)
        
    - example 2
        
        ```jsx
        <!DOCTYPE html>
        <html>
          <head>
            <title>Parcel Sandbox</title>
            <meta charset="UTF-8" />
          </head>
        
          <body>
            <div id="app"></div>
            <script type="text/javascript">
              function numbering() {
                let i = 0;
                while (i < 10) {
                  document.write(i);
                  i += 1;
                }
              }
              numbering();
              numbering();
            </script>
          </body>
        </html>
        ```
        
        ![Untitled](JavaScript%202c9f98085b324ae98e199576bbd836ed/Untitled%201.png)
        
    - input
        
        ```jsx
        <!DOCTYPE html>
        <html>
          <head>
            <title>Parcel Sandbox</title>
            <meta charset="UTF-8" />
          </head>
        
          <body>
            <div id="app"></div>
            <script type="text/javascript">
              function get_argument(arg) {
                return arg * 1000;
              }
              function get_arguments(arg1, arg2) {
                return arg1 + arg2;
              }
              alert(get_argument(1));
              alert(get_argument(2));
              document.write(get_arguments(1, 2));
            </script>
          </body>
        </html>
        ```
        
    - different ways to define functions
        - calling by name
            
            ```jsx
            <!DOCTYPE html>
            <html>
              <head>
                <title>Parcel Sandbox</title>
                <meta charset="UTF-8" />
              </head>
            
              <body>
                <div id="app"></div>
                <script type="text/javascript">
                  numbering = function () {
                    i = 0;
                    while (i < 10) {
                      document.write(i);
                      i += 1;
                    }
                  };
                  numbering();
                  //same thing as below
                  /* 
                  function numbering(){
                    i = 0;
                    while(i < 10){
                      document.write(i);
                      i+=1;
                    }
                  }
                  */
                </script>
              </body>
            </html>
            ```
            
        - anonymous function (일회성)
            
            ```jsx
            <!DOCTYPE html>
            <html>
              <head>
                <title>Parcel Sandbox</title>
                <meta charset="UTF-8" />
              </head>
            
              <body>
                <div id="app"></div>
                <script type="text/javascript">
                  (function () {
                    i = 0;
                    while (i < 10) {
                      document.write(i);
                      i++;
                    }
                  })();
            			//익명함수를 괄호로 감싸주고 ()을 붙이면서 호출
                </script>
              </body>
            </html>
            ```
            
            - 정의와 호출을 동시에, 대신 일회성
- == and ===
    
    ```jsx
    alert(1 === "1"); //false
    alert(1 == "1"); //true
    
    alert(undefined == null); //true
    alert(undefined === null); //false
    
    // == 는 숫자 1 이나 '1'을 true로 간주한다.
    // === 는 안함.
    alert(true == 1); //true
    alert(true === 1); //false
    alert(true == '1'); //true
    alert(true === '1') //false
    
    alert(0 === -0); //true
    alert(NaN === Nan); //false
    ```
    
    [JS comparison table](https://dorey.github.io/JavaScript-Equality-Table/)
    
- != and !==
    
    ```jsx
    //!=
    alert(1 != 2); //true
    alert(1 != 1); //false
    alert("one"!="two") //true
    alert("one"!="one") //false
    
    //!==
    // '!=='는 '!='와 '=='의 관계와 같다. 정확하게 같지 않다는 의미다. 예제는 생략한다.
    ```
    
- casting
    
    how to check a type of a variable.
    
    ```jsx
    console.log(typeof age); //checking the type of variable age
    ```
    
    how to cast string to int
    
    ```jsx
    value = parseInt("15");
    ```
    
    if we ask the user for the number value by using `prompt()`which takes a string value and the user gives us something like “assaasas”,
    
    when we parseInt that, the stored value to the variable would be NaN(not a number)
    
- conditional statements
    - if, else, else if
        
        ```jsx
        //실행됨
        if(true){
        	alert('result:true');
        }
        //실행안됨
        if(false){
        	alert('result:true');
        }
        //아래 예제 결과는 1
        if(true){
        	alert(1);
        } else {
        	alert(2);
        }
        //아래 예제 결과는 2
        if(false){
        	alert(1);
        } else {
        	alert(2);
        }
        //아래 예제 결과는 2
        if(false) {
        	alert(1);
        } else if(true) {
        	alert(2);
        } else if(true) {
        	alert(3);
        } else {
        	alert(4);
        }
        //아래 예제 결과는 3
        if(false) {
        	alert(1);
        } else if(false) {
        	alert(2);
        } else if(true) {
        	alert(3);
        } else {
        	alert(4);
        }
        ```
        
    - how to get date form the user
        
        ```jsx
        prompt("what is your age?");
        //generates the picture below
        //you can get the result of what the user typed in.
        //it's like Sacnner in Java.
        ```
        
        ![Untitled](JavaScript%202c9f98085b324ae98e199576bbd836ed/Untitled%202.png)
        
        ```jsx
        alert(prompt("what is your age?"));
        ```
        
    - simple login code sample
        
        ```jsx
        const id = prompt("type in your id.");
        if (id === "lukas") {
        	let password = prompt("enter your password");
        	if(password === "111111"){
        			alert("logged in successfully.");
        	} else {
        			alert("password doesn't match.");
        	}
        } else {
          alert("id doesn't match.");
        }
        ```
        
    - substitutes for boolean
        
        
        | true | 1 | string | !undefined | !null | !NaN |
        | --- | --- | --- | --- | --- | --- |
        | false  | 0 | empty string | undefined | null | NaN |
    - another conditional example
        
        `isNaN()`: tells us if the variable that we are sending is not a number or a number.
        
        ```jsx
        if(isNaN(age) || age < 0) {
        	console.log("Please wrtie a real positive number");
        } else if (age < 18) {
        	console.log("You are too young.");
        } else if (age >= 18 && age <= 50) {
        	console.log("You can drink");
        } else {
        	console.log("You can't drink");
        }
        ```
        
- how to write one the web page using JavaScript
    
    In html body section, you could write anything to show the content on the web page. How can you do it in script way?
    
    - you can use `document.write()` inside the script tag
    
    ```jsx
    <!DOCTYPE html>
    <html>
      <head>
        <title>Parcel Sandbox</title>
        <meta charset="UTF-8" />
      </head>
    
      <body>
        <div id="app"></div>
        Hello world; <br />
        Hello world; <br />
        Hello world; <br />
        <script type="text/javascript">
          document.write("coing everybody <br />");
        </script>
      </body>
    </html>
    ```
    
    ![Untitled](JavaScript%202c9f98085b324ae98e199576bbd836ed/Untitled%203.png)
    
- loops
    - while
        
         if the boolean value inside the parenthesis next to the while loop is fixed to true, the while loop isn’t going to end and cause repercussions. → need to change the boolean value to false at some point.
        
        ```jsx
        <!DOCTYPE html>
        <html>
          <head>
            <title>Parcel Sandbox</title>
            <meta charset="UTF-8" />
          </head>
        
          <body>
            <div id="app"></div>
            <script type="text/javascript">
              var i = 0;
              while (i < 10) {
                document.write("coing everybody " + i + "<br />");
                i++;
              }
            </script>
          </body>
        </html>
        ```
        
        ![Untitled](JavaScript%202c9f98085b324ae98e199576bbd836ed/Untitled%204.png)
        
    - for
        
        ```jsx
        <!DOCTYPE html>
        <html>
          <head>
            <title>Parcel Sandbox</title>
            <meta charset="UTF-8" />
          </head>
        
          <body>
            <div id="app"></div>
            <script type="text/javascript">
              for (i = 0; i < 10; i++) {
                document.write("coding everybody " + i + "<br />");
              }
            </script>
          </body>
        </html>
        ```
        
        ![Untitled](JavaScript%202c9f98085b324ae98e199576bbd836ed/Untitled%205.png)
        
    - controlling loops
        - break
            
            ```jsx
            <!DOCTYPE html>
            <html>
              <head>
                <title>Parcel Sandbox</title>
                <meta charset="UTF-8" />
              </head>
            
              <body>
                <div id="app"></div>
                <script type="text/javascript">
                  for (i = 0; i < 10; i++) {
                    if (i === 5) {
                      break;
                    }
                    document.write("coding everybody " + i + "<br />");
                  }
                </script>
              </body>
            </html>
            ```
            
            ![Untitled](JavaScript%202c9f98085b324ae98e199576bbd836ed/Untitled%206.png)
            
        - continue
            
            ```jsx
            <!DOCTYPE html>
            <html>
              <head>
                <title>Parcel Sandbox</title>
                <meta charset="UTF-8" />
              </head>
            
              <body>
                <div id="app"></div>
                <script type="text/javascript">
                  for (i = 0; i < 10; i++) {
                    if (i === 5) {
                      continue;
                    }
                    document.write("coding everybody " + i + "<br />");
                  }
                </script>
              </body>
            </html>
            ```
            
            ![Untitled](JavaScript%202c9f98085b324ae98e199576bbd836ed/Untitled%207.png)
            
        - nested for loops
            
            ```jsx
            <!DOCTYPE html>
            <html>
              <head>
                <title>Parcel Sandbox</title>
                <meta charset="UTF-8" />
              </head>
            
              <body>
                <div id="app"></div>
                <script type="text/javascript">
                  for (let i = 0; i < 10; i++) {
                    for (let j = 0; j < 10; j++) {
                      document.write("" + i + j + "<br />");
                      //since you put the string at front,
                      //the numerical addition after that point works
                      //as if the numbers were strings.
                    }
                  }
                </script>
              </body>
            </html>
            ```
            
            ```jsx
            00
            01
            02
            03
            04
            05
            06
            07
            08
            09
            10
            11
            12
            13
            14
            15
            16
            17
            18
            19
            20
            21
            22
            23
            24
            25
            26
            27
            28
            29
            30
            31
            32
            33
            34
            35
            36
            37
            38
            39
            40
            41
            42
            43
            44
            45
            46
            47
            48
            49
            50
            51
            52
            53
            54
            55
            56
            57
            58
            59
            60
            61
            62
            63
            64
            65
            66
            67
            68
            69
            70
            71
            72
            73
            74
            75
            76
            77
            78
            79
            80
            81
            82
            83
            84
            85
            86
            87
            88
            89
            90
            91
            92
            93
            94
            95
            96
            97
            98
            99
            ```
            
    - for…of        for…in
        
        출처: [kkd972](https://itstory.tk/entry/Javascript-for-in-vs-for-of-%EB%B0%98%EB%B3%B5%EB%AC%B8)
        
        # foreach 반복문
        
        `foreach` 반복문은 오직 Array 객체에서만 사용가능한 메서드입니다.(ES6부터는 Map, Set 등에서도 지원됩니다) 배열의 요소들을 반복하여 작업을 수행할 수 있습니다. `foreach` 구문의 인자로 callback 함수를 등록할 수 있고, 배열의 각 요소들이 반복될 때 이 callback 함수가 호출됩니다. callback 함수에서 배열 요소의 인덱스와 값에 접근할 수 있습니다.
        
        ```
        var items = ['item1', 'item2', 'item3'];
        
        items.forEach(function(item) {
            console.log(item);
        });
        // 출력 결과: item, item2, item3
        ```
        
        # for …in 반복문
        
        `for in` 반복문은 객체의 속성들을 반복하여 작업을 수행할 수 있습니다. 모든 객체에서 사용이 가능합니다. `for in` 구문은 객체의 key 값에 접근할 수 있지만, value 값에 접근하는 방법은 제공하지 않습니다. 자바스크립트에서 객체 속성들은 내부적으로 사용하는 숨겨진 속성들을 가지고 있습니다. 그 중 하나가 `[[Enumerable]]`이며, `for in` 구문은 이 값이 `true`로 셋팅되어 속성들만 반복할 수 있습니다. 이러한 속성들을 열거형 속성이라고 부르며, 객체의 모든 내장 메서드를 비롯해 각종 내장 프로퍼티 같은 비열거형 속성은 반복되지 않습니다.
        
        ```
        var obj = {
            a: 1,
            b: 2,
            c: 3
        };
        
        for (var prop in obj) {
            console.log(prop, obj[prop]); // a 1, b 2, c 3
        }
        ```
        
        # for …of 반복문
        
        `for of` 반복문은 ES6에 추가된 새로운 컬렉션 전용 반복 구문입니다. `for of` 구문을 사용하기 위해선 컬렉션 객체가 `[Symbol.iterator]` 속성을 가지고 있어야만 합니다(직접 명시 가능).
        
        ```
        var iterable = [10, 20, 30];
        
        for (var value of iterable) {
          console.log(value); // 10, 20, 30
        }
        ```
        
        # for in 반복문과 for of 반복문의 차이점
        
        - for in 반복문 : 객체의 모든 열거 가능한 속성에 대해 반복
        - for of 반복문 : `[Symbol.iterator]` 속성을 가지는 컬렉션 전용
        
        ```
        Object.prototype.objCustom = function () {};
        Array.prototype.arrCustom = function () {};
        
        var iterable = [3, 5, 7];
        iterable.foo = "hello";
        
        for (var key in iterable) {
          console.log(key); // 0, 1, 2, "foo", "arrCustom", "objCustom"
        }
        
        for (var value of iterable) {
          console.log(value); // 3, 5, 7
        }
        ```
        

- Searching For Elements
    - `getElementById()`
    - `getElementsByClassName()` → array 로 return 그리고 인덱스로 탐색.
    
    document 객체를 콘솔에 띄워보면 html 코드가 나오는데 이는 document 객체 자체가 유저들이 접근할 수 있는 HTML을 가리키는 객체이기 때문이다. → when the html structure pops up on the console, it appears as an object and this also allows the user to access and change the properties of the object as well.
    
    JS is already configured to load and access to html. → if you `document.title` on the console, you will get the title of the html file.
    
    - html code 1
        
        ```html
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="UTF-8" />
            <meta http-equiv="X-UA-Compatible" content="IE=edge" />
            <meta name="viewport" content="width=device-width, initial-scale=1.0" />
            <script src="1_selector.js" defer></script>
            <title>Selector</title>
          </head>
          <body>
            <section>
              <h2 id="title">운동</h2>
              <form action="myForm">
                <input type="text" name="myText" />
                <button>추가</button>
              </form>
              <ul class="list">
                <li class="item">스쿼트</li>
                <li class="item">벤치프레스</li>
                <li class="item">데드리프트</li>
              </ul>
              <p class="hello">안녕하세요</p>
            </section>
          </body>
        </html>
        ```
        
    - js code 1
        
        ```jsx
        //html 요소 얻기 (get 방식)
        document.getElementById("title");
        console.log(title);
        title.textContent = "헬스3대운동";
        
        let items = document.getElementsByClassName("item");
        console.log("스쿼트: ", items[0]);
        console.log("벤치프레스: ", items[1]);
        console.log("데드리프트: ", items[2]);
        
        let liList = document.getElementsByTagName("li");
        console.log(liList);
        
        //html 요소 얻기 (query 방식)
        //css 태그로 얻음
        let h2 = document.querySelector("#title");
        console.log("h2: ", h2);
        
        let item = document.querySelectorAll(".item");
        console.log(item);
        ```
        
    
    say in the html the h1 tag says below.
    
    ```html
    <h1 id = "title"> Catch Me! </h1>
    ```
    
    although the html content stays the same, when you do the below in the js, the web page will show Got you!
    
    ```jsx
    const title = document.getElementById("title");
    title.innerTxt = "Got you!"; 
    ```
    
    if you want to grab one specific element (recommended).
    
    html code
    
    ```html
    <div class = "hello">
    	<h1>Grab Me!</h1>
    </div>
    ```
    
    JS code
    
    ```jsx
    const title = document.querySelector(".hello h1");
    ```
    
    now say you have more h1’s in div tags with class name of hello.
    
    ```html
    <div class = "hello">
    	<h1>Grab Me!</h1>
    </div>
    <div class = "hello">
    	<h1>Grab Me2!</h1>
    </div>
    <div class = "hello">
    	<h1>Grab Me3!</h1>
    </div>
    ```
    
     here, although you use the `querySelector()`, it will only return the first element that correspond to the condition. if you want to have a list of all the elements under the matching condition, you need to use `querySelectorAll()`
    
    SAME SHITS
    
    ```jsx
    title = document.quesrySelctor("#hello");
    title = document.getElementById("hello");
    ```
    
- Event
    - `addEventListener()`: literally listens whether the specified event has happened and once happened, execute the aligned method().
    - [for more](https://developer.mozilla.org/en-US/docs/Web/API/Element) web api
    - HTML code 1
        
        ```html
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="UTF-8" />
            <meta name="viewport" content="width=device-width, initial-scale=1.0" />
            <meta http-equiv="X-UA-Compatible" content="ie=edge" />
            <title>Document</title>
          </head>
          <body>
            <div class = "hello">
              <h1>Click Me!</h1>
            </div>
            <script src="src/main.js"></script>
          </body>
        </html>
        ```
        
    - JS code 1
        
        ```jsx
        const title = document.querySelector("div:first-child h1");
        
        function handleTitleClick() {
          console.log("title was clicked!");
        }
        
        title.addEventListener("click", handleTitleClick);
        ```
        
    - HTML code 2
        
        ```html
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="UTF-8" />
            <meta name="viewport" content="width=device-width, initial-scale=1.0" />
            <meta http-equiv="X-UA-Compatible" content="ie=edge" />
            <title>Document</title>
          </head>
          <body>
            <div class="hello">
              <h1>Click Me!</h1>
            </div>
            <script src="src/main.js"></script>
          </body>
        </html>
        ```
        
    - JS code 2
        
        ```jsx
        const title = document.querySelector("div:first-child h1");
        
        function handleTitleClick() {
          title.style.color = "blue";
        }
        
        function handleMouseEnter() {
          title.innerText = "mouse is here!";
        }
        
        function handleMouseLeave() {
          title.innerText = "Mouse is gone!";
        }
        
        title.addEventListener("click", handleTitleClick);
        title.addEventListener("mouseenter", handleMouseEnter);
        title.addEventListener("mouseleave", handleMouseLeave);
        ```
        
    - another way to listen to the Event
        
        ```jsx
        title.onclick = handleTitleClick;
        title.onmouseenter = handleMouseEnter;
        ```
        
        the reason why we like to use the `.addEventListener` is that we could remove the EventListener using `.removeEventListener`.
        
    - Window obj
        
        [window obj api](https://developer.mozilla.org/ko/docs/Web/API/Window)
        
        HTML code
        
        ```jsx
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="UTF-8" />
            <meta name="viewport" content="width=device-width, initial-scale=1.0" />
            <meta http-equiv="X-UA-Compatible" content="ie=edge" />
            <title>Document</title>
          </head>
          <body>
            <div class="hello">
              <h1>Click Me!</h1>
            </div>
            <script src="src/main.js"></script>
          </body>
        </html>
        ```
        
        JS code
        
        ```jsx
        function handleWindowResize() {
          document.body.style.backgroundColor = "tomato";
        }
        
        function handleWindowCopy() {
          alert("copier!");
        }
        
        function handleWindowOffline() {
          alert("SOS no WIFI!");
        }
        
        function handleWindowOnline() {
          alert("We are all good: connected to WIFI.");
        }
        
        window.addEventListener("resize", handleWindowResize);
        window.addEventListener("copy", handleWindowCopy);
        window.addEventListener("offline", handleWindowOffline);
        window.addEventListener("online", handleWindowOnline);
        ```
        
- JS’ interaction with CSS
    - changing an element’s when clicked. (js’ interaction with css)
        
        ```jsx
        const h1 = document.querySelector("div:first-child h1");
        
        function handleTitleClick() {
          //blue -> tomato -> blue -> tomato ...
          const currentColor = h1.style.color;
          let newColor;
          if (currentColor === "blue") {
            newColor = "tomato";
          } else {
            newColor = "blue";
          }
          h1.style.color = newColor;
        }
        
        h1.addEventListener("click", handleTitleClick);
        ```
        
        we are changing the style of the code in the JavaScript, which is not really a smart move. We’d rather want to do it in CSS.
        
    - giving an className to an html element (js’ interaction with css)
        
        ```jsx
        const h1 = document.querySelector("div:first-child h1");
        
        function handleTitleClick() {
          const clickedClass = "active";
          if (h1.className === clickedClass) {
            h1.className = "";
          } else {
            h1.className = clickedClass;
          }
        }
        
        h1.addEventListener("click", handleTitleClick);
        ```
        
        ```css
        body {
          background-color: beige;
        }
        
        h1 {
          color: cornflowerblue;
          transition: color 0.5s ease-in-out;
        }
        
        .active {
          color: tomato;
        }
        ```
        
        this still forcefully changes the initial class name value of the html element if there was one. In the next toggle, there will be the ultimate clean code.
        
    - doing the same job as previous toggle using the classList.
        
        ```jsx
        const h1 = document.querySelector("div:first-child h1");
        
        function handleTitleClick() {
          const clickedClass = "active";
          if (h1.classList.contains(clickedClass)) {
            h1.classList.remove(clickedClass);
          } else {
            h1.classList.add(clickedClass);
          }
        }
        
        h1.addEventListener("click", handleTitleClick);
        ```
        
        you could basically use the `classList` to remove and add the className without affecting other coexisting class names.
        
        THERE IS ONE FUNCTION THAT DOES THIS PROCESS AT ONCE.
        
        toggle() method basically implements the code below in it.
        
        ```jsx
        if (h1.classList.contains(clickedClass)) {
            h1.classList.remove(clickedClass);
          } else {
            h1.classList.add(clickedClass);
          }
        ```
        
        so,,, the code below does the same thing as the first code in this toggle.
        
        ```jsx
        const h1 = document.querySelector("div:first-child h1");
        
        function handleTitleClick() {
          h1.classList.toggle("active");
        }
        
        h1.addEventListener("click", handleTitleClick);
        ```
        
    
- Login
    - Input Values
        
        
        ```html
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="UTF-8" />
            <meta name="viewport" content="width=device-width, initial-scale=1.0" />
            <meta http-equiv="X-UA-Compatible" content="ie=edge" />
            <link rel="stylesheet" href="src/styles.css" />
            <title>Document</title>
          </head>
          <body>
            <div id="login-form">
              <input type="text" placeholder="what is your name?" />
              <button>Log In</button>
            </div>
            <script src="src/main.js"></script>
          </body>
        </html>
        ```
        
        ```jsx
        const loginInput = document.querySelector("#login-form input");
        const loginButton = document.querySelector("#login-form button");
        
        function onLoginBtnClick() {
          //value === the text content
          console.log("hello", loginInput.value);
        }
        
        loginButton.addEventListener("click", onLoginBtnClick);
        ```
        
    - Form Submission
        
        <input> 태그의 required 속성은 폼 데이터(form data)가 서버로 제출되기 전 반드시 채워져 있어야 하는 입력 필드를 명시합니다.
        
        → to trigger the validation of the input, it has to be inside the form tag. 
        
        required 속성이 제대로 동작하는 <input> 요소의 type 속성값은 다음과 같습니다.
        
        - checkbox, date, email, file, number, password, pickers, radio, search, tel, text, url
        
        ![Untitled](JavaScript%202c9f98085b324ae98e199576bbd836ed/Untitled%208.png)
        
        compared to the previous example, since the input tag is encompassed by the form tag, it is automatically being submitted without caring “click” event. This is why we do not need to consider the “click” inside the `.addEventListener();`. (Though it is in the picture above, we will delete it cause it’s not necessary).
        
    - Events
        
        The browser is programmed to refresh after the form tag submit a value by default.
        
- Clock
    - `setInterval()`
        
        `setInterval()` takes two arguments: 1. a method  you want to execute & 2. an interval by which you want to execute your method in ms. (5000 ms === 5 s).
        
        ex) `setInterval(sayHi, 5000);`
        
    - `setTimeout()`
        
        when you don’t want to execute a certain method for a certain amount of time, you could use `setTimeout()`. It takes two arguments: the method you want to execute & time you want to wait for in ms.
        
        ex) `setTimeout(sayHi, 5000);`
        
    - `padStart()` & `padEnd()`
        
        `padStart()` is a function that you can apply to a string.
        
        ex)`"1".padStart(2, "0")`
        
        → make the string the length of 2, if the string isn’t in the length of 2, put “0” in front.
        
        `padEnd()` does the same thing but adds at the end.
        
- quotes and backgrounds
    
    ![Untitled](JavaScript%202c9f98085b324ae98e199576bbd836ed/Untitled%209.png)
    
    ***background.js***
    
    ```jsx
    const images = ["0.img.jpg", "1.img.jpg", "2.img.jpg"];
    
    const chosenImage = images[Math.floor(Math.random() * images.length)];
    
    const image = document.createElement("img"); //<img>
    
    image.src = `img/${chosenImage}`; //image is now <img src="img/0.img.jpg">
    
    document.body.appendChild(image); //at the end / prepend -> at the top
    ```
    
    ***quotes.js***
    
    ```jsx
    const quotes = [
      {
        quote:
          "To live is the rarest thing in the world. Most people exist, that is all.",
        author: "Oscar Wilde"
      },
      {
        quote: "That it will never come again is what makes life so sweet.",
        author: "Emily Dickinson"
      },
      {
        quote: "It is never too late to be what you might have been.",
        author: "George Eliot"
      },
      {
        quote: "Pain is inevitable. Suffering is optional.",
        author: "Haruki Murakami"
      },
      {
        quote: "Be kind, for everyone you meet is fighting a hard battle.",
        author: "Plato"
      },
      {
        quote: "Let me live, love, and say it well in good sentences.",
        author: "Sylvia Path"
      },
      {
        quote: "Don't let your happiness depend on something you may lose.",
        author: "C.S. Lewis"
      },
      {
        quote: "Life is tough my darling, but so are you.",
        author: "Stephanie Bennett Henry"
      },
      {
        quote: "Self-awareness and self-love matter. Who we are is how we lead.",
        author: "Brene Brown"
      },
      {
        quote:
          "Amateurs sit and wait for inspiration, the rest of us just get up and go to work.",
        author: "Stephen King"
      }
    ];
    
    const quote = document.querySelector("#quote span:first-child");
    const author = document.querySelector("#quote span:last-child");
    const todaysQuote = quotes[Math.floor(Math.random() * quotes.length)];
    
    quote.innerText = todaysQuote.quote;
    author.innerText = todaysQuote.author;
    ```
    
    ***index***.***html***
    
    ```html
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="stylesheet" href="css/styles.css" />
        <title>Momentum App</title>
      </head>
      <body>
        <form class="hidden" id="login-form">
          <input
            required
            maxlength="15"
            type="text"
            placeholder="What is your name?"
          />
          <input type="submit" value="Log In" />
        </form>
        <h2 id="clock">00:00:00</h2>
        <h1 class="hidden" id="greeting"></h1>
        <div id="quote">
          <span></span>
          <span></span>
        </div>
        <script src="js/greeting.js"></script>
        <script src="js/clock.js"></script>
        <script src="js/quotes.js"></script>
        <script src="js/background.js"></script>
      </body>
    </html>
    <samp></samp>
    ```
    
- html 요소 조작하기
    - js code
        
        ```jsx
        /* html 요소 조작하기 */
        h2.textContent = "<span>운동!!!<span/>"; //여기서의 span 태그는 문자열
        h2.innerHTML = "<span>운동@@@<span>"; //innerHTML 을 활용한 span 태그는 진짜 span태그로 인식됨.
        //document.querySelector("body").innerHTML = "<span>메롱</span>";
        
        let input = document.querySelector("input");
        input.setAttribute("placeholder", "헬스 운동을 입력해주세요.");
        input.setAttribute("required", "");
        //input.removeAttribute("placeholder");
        //input.removeAttribute("required");
        ```
        
- html 요소 스타일링
    - js code
        
        ```jsx
        /* html 스타일링하기 */
        let helloItem = document.querySelector(".hello");
        helloItem.classList.add("dark");
        //helloItem.classList.add('light');
        ```
        

[Imports&Exports (Modules)](JavaScript%202c9f98085b324ae98e199576bbd836ed/Imports&Exports%20(Modules)%2024b43a7e52fb4038a17798c56acf003b.md)

- classes
    
    blueprints of objects. An example follows
    
    ```jsx
    class Human {
     constructor() {
       this.gender = 'male'
     }
     printGender(){
       console.log(this.gender);
     }
    }
    
    class Person extends Human {
      constructor() {
        super();
        this.name = 'Max';
      }
      
      printMyName() {
        console.log(this.name);
      }
    }
    
    const person = new Person();
    person.printMyName();
    person.printGender();
    ```
    
    ```
    "Max"
    "male"
    ```
    
- easier way to use constructor&functions(recommended)
    
    
    Before
    
    After
    
    ```jsx
    constructor() {
    	this.myProperty = 'value';
    }
    ```
    
    ```jsx
    myMethod() {...}
    ```
    
    ```jsx
    myProperty = 'value';
    ```
    
    ```jsx
    myMethod = () => {...}
    ```
    
    ```jsx
    class Human {
     gender = 'male'
     
     printGender= () =>{
       console.log(this.gender);//still use this keyword
     }
    }
    
    class Person extends Human {
      name = 'Max'
      
      printMyName = () => {
        console.log(this.name);
      }
    }
    
    const person = new Person();
    person.printMyName();
    person.printGender();
    ```
    
    ```
    "Max"
    "male"
    ```
    
    the example left to this text still works the same as shown in the classes toggle.(above this super toggle)
    
- Spread&Rest Operators
    
    What Spread&Rest Operators look like: … (yes, just three dots)
    
    **Spread**
    
    **Rest**
    
    Used to split up array elements OR object properties
    
    Used to merge a list of function arguments into an array
    
    ```jsx
    const newArray = [...oldArray, 1, 2];
    const newObject= {...oldObject, newProp:5}
    ```
    
    ```jsx
    function sortArgs(...args){
    		return args.sort()
    }
    ```
    
    **Spread example**
    
    ```jsx
    const numbers = [1, 2, 3];
    const newNumbers = [...numbers, 4, 5, 6];
    console.log(newNumbers);
    
    //[1, 2, 3, 4, 5, 6]
    
    const person = {
      name: 'Max'
    };
    
    const newPerson = {
      ...person,
      age: 28
    }
    
    console.log(newPerson);
    /*
    [object Object] {
      age: 28,
      name: "Max"
    }
    */
    ```
    
    **Rest Example**
    
    ```jsx
    const filter = (...args) => args.filter(el => el === 1);
    //arrow inside the filter function is built in for filter function,
    //therefore it has intrinsically nothing to do with the const filter we defined.
    console.log(filter(1, 2, 3)); // [1]
    ```
    
- Destructuring
    
    Easily extract array elements or object properties and store them in variables.
    
    **Array Destructuring**
    
    **Object Destructuring**
    
    ```jsx
    [a,b] = ['Hello', 'Max']
    console.log(a) //Hello
    console.log(b) //Max
    ```
    
    ```jsx
    {name} = {name:'Max', age:28}
    console.log(name)//Max
    console.log(age)//undefined
    ```
    
    **array destructuring example**
    
    ```jsx
    const numbers = [1, 2, 3];
    [num1, , num3] = numbers;
    console.log(num1, num3);
    /*
    1
    3
    */
    ```
    
    **object destructuring example**
    
    ```jsx
    const o = {p:42; q:true};
    const {p, q} = o;
    
    console.log(p); //42
    console.log(q); //true
    ```
    

[모던 자바스크립트 목차](JavaScript%202c9f98085b324ae98e199576bbd836ed/%E1%84%86%E1%85%A9%E1%84%83%E1%85%A5%E1%86%AB%20%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3%20%E1%84%86%E1%85%A9%E1%86%A8%E1%84%8E%E1%85%A1%20ef1766afe1fe44ec9f26c459238e65e7.md)

- what is global object?
    
    global object is a special object that is created by the JS engine before any object. On client-side environment(browser), global object === `window` object. On server-side environment(Node.js), global object === `global` object.
    
- primitive and reference data types
    
    
    ![Untitled](JavaScript%202c9f98085b324ae98e199576bbd836ed/Untitled%2010.png)
    
    ![Untitled](JavaScript%202c9f98085b324ae98e199576bbd836ed/Untitled%2011.png)
    
    ```jsx
    const person = {
      name: 'Max'
    };
    
    const secondPerson = person;
    
    person.name = 'Luke';
    console.log(secondPerson);
    /*
    [object Object] {
      name: "Luke"
    }
    */
    ```
    
    since the Person object is a reference type, person the object is stored in memory and in the constant person we store a pointer to that place in memory. as you can see above, as we change the content of the person the object, the content of secondPerson also changes because the variable is assigned directly.
    
    ```jsx
    const person = {
      name: 'Max'
    };
    
    const secondPerson = {
      ...person
    }
    
    person.name = 'Luke';
    console.log(secondPerson);
    /*
    [object Object] {
      name: "Max"
    }
    */
    ```
    
    When you define the secondPerson constant using spread Operator, however, you are copying the object not just the pointer for that. Therefore, you can get the original value of the person the object even after the content of the object got changed.
    
- var
    
    variable hoisting happens with variables declared with `var` keyword.
    
    ![Untitled](JavaScript%202c9f98085b324ae98e199576bbd836ed/Untitled%2012.png)
    
    when hoisting happens with the variables declared with the var keyword, the variables are hoisted with the default initialization: undefined. This happens before the runtime.
    
- let, const
    
    Yeah I bet you have encountered so many explanations on the difference between let v. const v. var, but it’s always good to know more about the difference and to use the right declaration keyword throughout the project. I will just add on the things I newly got to know!
    
    - const
        - The const declaration  creates block-scoped constants
        - The value of a constant can’t be changed through reassignment, and it can’t be redeclared. However if the constant is an object or array, its properties or items can be updated or removed.
        - The declaration creates a constant whose scope can be either global or local to the block in which it is declared. Global constants do not become properties of the `window` object, unlike `var` variables.
        - All the considerations about the temporal dead zone apply to both let and const. For this reason, const declaration are commonly regarded as non-hoisted.
            - delve deeper into TDZ(temporal dead zone)
                
                A let or const variable is said o be in a “temporal dead zone” (TDZ) from the start of the block until code execution reaches the line where the variable is declared and initialized. 
                
                While inside the TDZ, the variable has not been initialized with a value, and any attempt to access it will result in a `ReferenceError`. The variable is initialized with a value when execution reaches the line of code where it was declared.
                
                 This differs from var variables, which will return a value of undefined if they are accessed before they are declared. The code below demonstrates the different result when let and var are accessed in code before the line in which they are declared.
                
                ```jsx
                {
                  // TDZ starts at beginning of scope
                  console.log(bar); // undefined
                  console.log(foo); // ReferenceError
                  var bar = 1;
                  let foo = 2; // End of TDZ (for foo)
                }
                ```
                
                The term "temporal" is used because the zone depends on the order of execution (time) rather than the order in which the code is written (position). For example, the code below works because, even though the function that uses the `let` variable appears before the variable is declared, the function is *called* outside the TDZ.
                
                ```jsx
                {
                  // TDZ starts at beginning of scope
                  const func = () => console.log(letVar); // OK
                
                  // Within the TDZ letVar access throws `ReferenceError`
                
                  let letVar = 3; // End of TDZ (for letVar)
                  func(); // Called outside TDZ!
                }
                ```
                
    - let
        - The **`let`** declaration declares a block-scoped local variable, optionally initializing it to a value.
        - **`let`** allows you to declare variables that are limited to the scope of a [block](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block) statement, or expression on which it is used.
        - Just like `[const](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const#description)` the `let` does *not* create properties of the `[window](https://developer.mozilla.org/en-US/docs/Web/API/Window)` object when declared globally (in the top-most scope).
    - hoisting with let&const
        
        When the hoisting happens with the variables declared with `let` / `const` keyword, the hoisting is done without the initial declaration, so the Reference Error comes up, “ReferenceError: Cannot access ‘foo’ before initialization.”
        
        ![Untitled](JavaScript%202c9f98085b324ae98e199576bbd836ed/Untitled%2013.png)
        
    - let&const and global object
        
        What becomes window’s property:
        
        global variables&functions declared with `var`, implicit global(암묵적 전역). When referring to the properties of the global object(window), you can get rid of the window that comes before .(property). ex) window.x === x given that x is one of the global object’s properties.
        
        However, variables declared with let / const keyword are NOT the properties of the global object(window).
        
        ```jsx
        //이 예제는 브라우저 환경에서 실행하여야 한다.
        let x = 1;
        
        //let, const 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티가 아니다.
        console.log(window.x); //undefined
        console.log(x); //1
        ```
        
    
- creating objects using the Constructor (you used to do it with the Object Literal)
    
    Object Literal(객체 리터럴) creates only one single object. Therefore, whenever you need to create some objects that share similar properties, you need to create another identifier and add the similar properties to it all over again. Although it is such an easy way to create objects using the object literals, in certain situation as the aforementioned one, you may need to prefer using the constructor. 
    
    자바나 다른 언어들의 생성자와는 다르게 함수 선언문 또는 함수 표현식으로 생성자 함수를 정의해놓고 나중에 객체를 생성할 때 `new` 연산자와 함께 호출하면 된다.
    
    ```jsx
    function Circle(radius) {
    	//생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가르킨다.
    	this.radius = radius;
    	this.getDiameter = function () {
    		return 2 * this.radius;
    	};
    }
    
    	//인스턴스의 생성
    	const circle1 = new Circle(5);
    	const circle2 = new Circle(10);
    	
    	console.log(circle1.getDiameter()); //10 
    	console.log(circle2.getDiameter()); //20 
    ```
    
    - what `this` binds to in different situations
        
        this는 객체 자신의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수이다. this가 가르키는 값, 즉 this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다.
        
        | 함수 호출 방식 | this가 가르키는 값(this 바인딩) |
        | --- | --- |
        | 일반 함수로서 호출 | 전역 객체 |
        | 메서드로서 호출 | 메서드를 호출한 객체(마침표 앞의 객체) |
        | 생성자 함수로서 호출 | 생성자 함수가 (미래에) 생성할 인스턴스 |
        
        ```jsx
        function foo() {
        	console.log(this);
        }
        
        foo(); // window 
        
        const obj = { foo }; // ES6 shorthand 
        
        obj.foo(); // obj
        
        const inst = new foo(); //inst
        ```
        
    - returning instance
        
        생성자 함수의 모든 처리가 끝나면 완성된 인스턴스가 바인딩 된 this가 암묵적으로 반환된다.
        
        ```jsx
        function Circle(radius) {
        	//1. 암묵적으로 빈 객체가 생성되고 this에 바인딩된다.
        
        	//2. this에 바인딩되어 있는 인스턴스를 초기화한다.
        	this.radius = radius;
        	this.getDiameter = function () {
        		return 2 * this.radius;
        	}
        	
        	//3. 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.
        }
        
        const circle = new Circle(1);
        console.log(circle); // Circle {radius: 1, getDiameter: *f*}
        
        ```
        
        만약 this가 아닌 다른 객체를 명시적으로 반환하면 this가 반환되지 못하고 return 문에 명시가 객체가 반환된다.
        
        ```jsx
        function Circle(radius) {
        	//1. 암묵적으로 빈 객체가 생성되고 this에 바인딩된다.
        
        	//2. this에 바인딩되어 있는 인스턴스를 초기화한다.
        	this.radius = radius;
        	this.getDiameter = function () {
        		return 2 * this.radius;
        	}
        	
        	//3. 암묵적으로 this를 반환한다.
        	//명시적으로 객체를 반환하면 암묵적인 this 반환이 무시된다.
        	return {};
        }
        
        const circle = new Circle(1);
        console.log(circle); // {} 
        ```
        
        하지만 명시적으로 원시 값을 반환하면 원 값 반환은 무시되고 암묵적으로 this가 반환된다.
        
        ```jsx
        function Circle(radius) {
        	//1. 암묵적으로 빈 객체가 생성되고 this에 바인딩된다.
        
        	//2. this에 바인딩되어 있는 인스턴스를 초기화한다.
        	this.radius = radius;
        	this.getDiameter = function () {
        		return 2 * this.radius;
        	}
        	
        	//3. 암묵적으로 this를 반환한다.
        	//명시적으로 우너시값을 반환하면 원시 값 반환은 무시되고 암묵적으로 this가 반환된다.
        	return 100;
        }
        
        const circle = new Circle(1);
        console.log(circle); // Circle {radius: 1, getDiameter: *f*} 
        ```
        
        **이처럼 생성자 함수에서  명시적으로 this가 아닌 다른 값을 반환하는 것은 생성자 함수의 기본 동작을 훼손한다. 따라서 생성자 함수 내부에서 return문을 반드시 생략해야한다.**
        
    - internal method: [[call]] & [[construct]]
        
        Function is an object. Therefore, it can act like an ordinary object. Functions have all the internal slots and methods that  an ordinary object would have. Beyond that, it has special internal slots and methods unique to it. When the function is called as a normal function, [[Call]] is being called, while [[Construct]] is being called when the function’s called as a constructor with the `new` keyword.
        
    - constructor v. non-constructor
        
        자바스크립트 엔진은 함수 정의를 평가하여 함수 객체를 생성할 때 함수 정의 방식에 따라 함수를 constructor와 non-constructor로 구분한다.
        
        - constructor: 함수 선언문, 함수 표현식, 클래스(클래스도 함수다)
        - non-constructor: 메서드(ES6 메서드 축약표현), 화살표 함수
        
        ```jsx
        //일반 함수 정의: 함수 선언문, 함수 표현식
        function foo () {}
        const bar = function () {};
        //프로퍼티 x의 값으로 할당된 것은 일반 함수로 정의된 함수다. 이는 메서드로 인정하지 않는다.
        const baz = {
        	x: function () {}
        };
        
        //일반 함수로 정의된 함수만이 constructor다.
        new foo(); // -> foo {}
        new bar(); // -> bar {}
        new baz.x(); // -> x {}
        
        //화살표 함수 정의
        const arrow = () => {};
        
        new arrow(); // TypeError: arrow is not a constructor
        
        //메서드 정의: ES6의 메서드 축약 표현만 메서드로 인정한다.
        const obj = {
        	x() {}
        };
        
        new obj.x(); //TypeError: obj.x is not a constructor
        ```
        
        new 연산자를 사용하면 함께 사용된 함수는 생성자 함수로 동작한다.
        
        ```jsx
        //생성자 함수로서 정의하지 않은 함수
        function add(x, y) {
        	return x + y;
        }
        
        //생성자 함수로서 정의하지 않은 일반 함수를 new 연산자와 함께 호출
        let inst = new add();
        
        //함수가 객체를 반환하지 않았으므로 반환문이 무시되고 빈 객체가 생성되어 반환된다.
        //you can refer to the last toggle (returning instance toggle)
        console.log(inst); // {}
        
        //객체를 반환하는 일반 함수
        function createUser(name, role){
        	return {name, role};
        }
        
        inst = new createUser('Lee', 'admin');
        console.log(inst); // {name: "Lee", role: "admin"}
        ```
        
        new 연산자 없이 생성자 함수를 호출하면 일반 함수로 호출된다. (함수 객체으의 내부 메서드 [[Construct]] 가 아니라 [[Call]]이 호출된다.
        
        ```jsx
        //생성자 함수
        function Circle(radius) {
        	this.radius = radius;
        	this.getDiameter = function () {
        		return 2 * this.radius;
        	};
        }
        
        //new 연산자 없이 생성자 함수 호출하면 일반 함수로서 호출된다.
        const circle = Circle(5);
        console.log(circle); //undefined
        
        //일반 함수 내부의 this는 전역 객체 window를 가르킨다.
        console.log(radius); //5
        console.log(getDiameter()); //10
        
        circle.getDiameter();
        //TypeError: Cannot read property 'getDiameter' of undefined
        ```
        
    - new.target
        
        생성자 함수가  new 연산자 없이 호출되는 것을 방지하기 위해서 파스칼 컨벤션을 사용한다고 하더라도 실수는 언제나 발생할 수 있다. 이것을 방지하기 위해서 ES6에서는 new.target을 지원한다.
        
        **new 연산자와 함께 생성자 함수로서 호출되면 함수 내부의 new.target은 함수 자신을 가르킨다. new 연산자 없이 일반 함수로서 호출된 함수 내부의 new.target은 undefined이다.**
        
        ```jsx
        function Circle(radius) {
        	if(!new.target) {
        		// new 연산자와 함께 생성자 함수를 재귀 호출하여 생성된 인스턴스를 반환한다.
        		return new Circle(radius);
        	}
        	this.radius = radius;
        	this.getDiameter = function () {
        		return 2 * this.radius;
        	};
        }
        
        //new 연산자 없이 생성자 함수를 호출하여도 newtarget을 통해 생성자 함수로서 호출
        const circle = Circle(5);
        console.log(circle.getDiameter());
        ```
        
        new.target은 ES6 최신문법이므로 new.target을 사용할 수 없는 환경에서는 scope-safe constructor를 사용한다.
        
        ```jsx
        // Scope-safe Constructor Pattern
        function Circle(radius) {
        	//생성자 함수가 new 연산자와 함꼐 호출되면 함수의 선두에서 빈 객체를 생성하고
        	//this에 바인딩한다. 이떄 this와 Circle은 프로토타입에 의해 연결된다.
        
        	//이 함수가 new 연산자와 함꼐 호출되지 않았다면 이 시점의 this는 전역 객체 window를 가르킨다
        	//즉, this와 Circle은 프로토타입에 의해 연결되지 않는다.
        	if(!(this instanceof Circle)) {
        		return new Circle(radius);
        	}
        	
        	this.radius = raidus;
        	this.getDiameter = functon () {
        		return 2 * this.radius;
        	};
        }
        
        //new 연산자 없이 생성자 함수를 호출하여도 newtarget을 통해 생성자 함수로서 호출
        const circle = Circle(5);
        console.log(circle.getDiameter()); //10
        ```
        
    
- first-class object
    
    In [programming language design](https://en.wikipedia.org/wiki/Programming_language#Design_and_implementation), a **first-class citizen**(also **type**, **object**, **entity**, or **value**) in a given [programming language](https://en.wikipedia.org/wiki/Programming_language) is an entity which supports all the operations generally available to other entities. These operations typically include being passed as an [argument](https://en.wikipedia.org/wiki/Parameter_(computer_programming)), returned from a [function](https://en.wikipedia.org/wiki/Function_(computer_programming)), and assigned to a [variable](https://en.wikipedia.org/wiki/Variable_(computer_science)).
    
    - properties of the function object
        
        ```jsx
        function square(number) {
            return number * number;
        }
        
        console.log(Object.getOwnPropertyDescriptors(square));
        /*
        {length: {…}, name: {…}, arguments: {…}, caller: {…}, prototype: {…}}
        arguments: {value: null, writable: false, enumerable: false, configurable: false}
        caller: {value: null, writable: false, enumerable: false, configurable: false}
        length: {value: 1, writable: false, enumerable: false, configurable: true}
        name: {value: 'square', writable: false, enumerable: false, configurable: true}
        prototype: {value: {…}, writable: true, enumerable: false, configurable: false}
        [[Prototype]]: Object
        */
        
        //__proto__는 함수 자체의 프로퍼티가 아니라 Object.prototype 객체의 접근자 프로퍼티이다.
        console.log(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__"));
        //{enumerable: false, configurable: true, get: ƒ, set: ƒ}
        ```
        
- prototype
    - static properties/methods
        
        정적 프로퍼티/메서드는 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메서드를 말한다. 아래 예시에서, Person 생성자 함수가 함수 객체가 소유한 프로퍼티/메서드를 정적 프로퍼티/메서드라고 한다. 정적 프로퍼티/메서드는 생성자 함수가 생성한 인스턴스로 참조할 수 **없다**.
        
        ```jsx
        function Person(name){
        	this.name = name;
        }
        
        // prototype method
        Person.prototype.sayHello = function() {
        	console.log(`Hi! May names is ${this.name}`);
        };
        
        //static property
        Person.staticProb = 'static prop';
        //static method 
        Person.staticMethod = function () {
        	console.log('static method');
        };
        
        const me = new Person('Park');
        
        //생성자 함수에 추가한 정적 프로퍼티/메서드는 생성자 함수로 참조, 호출한다.
        Person.staticMethod(); //staticMethod
        
        //정적 프로퍼티/메서드는 생성자 함수가 생성한 인스턴스로 참조할 수 없다.
        // 인스턴슬 참조/호출할 수 있는 프로퍼티/메서드는 프로토타입 체인 상에 존재해야 한다.
        me.staticMethod(); // TypeError: me.staticMethod is not a function
        
        ```
        
    - handling properties
        - 프로퍼티 존재 확인
            - in 연산자
                
                `in` operator looks whether a certain property exist inside the object.
                
                ```jsx
                const person = {
                	name: 'Lee',
                	address: 'Seoul',
                };
                
                console.log('name' in person);   //true
                console.log('address' in person); //true
                console.log('age' in person);    //false
                ```
                
                in 연산자 대신 ES6에서 도입된 Reflect.has 메서드를 사용할 수도 있다. Reflect.has 메서드는 in 연산자와 동일하게 동작한다.
                
                ```jsx
                const person = { name : 'Lee' };
                
                console.log(Reflect.has(person, 'name'); // true
                console.log(Reflect.has(person, 'age'); // false
                ```
                
                한 가지 주의해야할 점이 있다면 위의 방법들은 확인 대상 객체(여기서는 person) 의 프로퍼티 뿐만이 아니라 확인 대상 객체가 상속받은 모든 프로토타입의 프로퍼티를 확인하므로 주의가 필요하다. 예를 들면, person 객체에는 toString 메서드가 없지만 person 객체가 속한 모든 프로토타입 중 하나인 Object.prototype의 메서드 중 하나이므로 person 객체 역시 toString을 가지고 있다고 여겨진다.
                
                ```jsx
                const person = { name : 'Park' };
                
                console.log(Reflect.has(person, 'name')); //true
                console.log(Reflect.has(person, 'toString')); //true
                console.log('name' in person); //true
                console.log('toString' in person); //true
                ```
                
            - Object.prototype.hasOwnProperty
                
                Object.prototype.hasOwnProperty 메서드를 사용해도 객체에 특정 프로퍼티가 존재하는지 확인할 수 있다.
                
                ```jsx
                const person = { name : 'Park' };
                console.log(person.hasOwnProperty('name'); //true
                console.log(person.hasOwnProperty('age'); //false
                ```
                
                리 메서드는 이름에서도 알 수 있듯이 인수로 전달받은 키가 객체 고유의 프로퍼티 키인 경우에만 true를 반환하고 상속받은 프로토타입의 프로퍼티 키인 경우 false를 반환한다.
                
                ```jsx
                console.log(person.hasOwnProperty('toString')); //false
                ```
                
        - 프로퍼티 열거
            - for…in문
                
                객체의 모든 프로퍼티를 순회하며 열거(enumeration)하려면 for…in문이 필요하다.
                
                ```jsx
                const person = {
                	name : 'Lee',
                	address : 'Seoul',
                };
                
                //for...in 문의 변수 prop에 person 객체의 프로퍼티 키가 할당된다.
                for(const key in person) {
                	console.log(key + ': ' + person[key]);
                }
                //name: Lee
                //address: Seoul
                ```
                
                for…in 문은 in 연산자처럼 순회 대상 객체의 프로퍼티 뿐만이 아니라 상속받은 프로토타입의 프로퍼티까지 열거한다. 하지만 위 예제의 경우 toString과 같은 Object.prototype의 프로퍼티가 열거되지 않는다. 그 이유는 Object.prototype.toString 의 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false이기 때문이다.  따라서 정리하자면… **for…in문은 객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중에서 프로퍼티 어트리뷰트[[Enumerable]]의 값이 true인 프로퍼티를 순회하며 열거한다.**
                
                ```jsx
                const person = {
                	name: 'Park',
                	address: 'Seoul',
                	__proto__: { age: 20 },
                };
                
                for (const ket in person) {
                	console.log(key + ': ' + person[key]);
                }
                //name: Lee
                //address: Seoul
                //age: 20
                ```
                
                자바스크립트는 객체의 프로퍼티 키로 오직 문자형과 심볼형만을 허용하는데 심볼은 “유일한 식별자”를 만들고 싶을 때 사용한다. 심볼형을 객체의 프로퍼티 키값으로 사용하고 싶다면 [ ] (대괄호) 안에 써야하고 안그러면 스트링으로 바뀐다.
                
                ```jsx
                const sym = Symbol();
                const obj = {
                	a: 1,
                	[sym]: 10,
                };
                
                for (const key in obj) {
                	console.log(key + ': ' + obj[key]);
                }
                //a: 1
                ```
                
                for…in 문은 프로퍼티 키가 심벌인 프로퍼티는 열거하지 않는다.
                
                그렇다면 상속받은 프로토타입의 프로퍼티를 열거하고 싶지 않으면 어떻게 해야할까? Object.prototype.hasOwnProperty 메소드를 사용하면 된다.
                
                ```jsx
                const person = {
                	name: 'Park',
                	address: 'Seoul', 
                	__proto__: {age:20},
                };
                
                for (const ket in person) {
                	if(!person.hasOwnProperty(key)) continue;
                	console.log(key + ': ' + person[key]);
                }
                //name: Park
                //address: Seoul
                ```
                
            - Object.keys/values/entries 메서드
                
                객체 자신의 고유 프로퍼티만 열거하기 위해서는 for…in 문을 사용하는 것보다 Object.keys/values/entries 메서드를 사용하는 것을 권장한다. 이 세 가지 메서드들은 모두 객체 자신의 열거 가능한 값들을 배열로 반환하는데…
                
                Object.keys 메서드는 객체 자신의 enumerable한 프로퍼티 키를 배열로 반환한다.
                
                ```jsx
                const person = {
                	name: 'Lee',
                	address: 'Seoul',
                	__proto__: {age : 20},
                };
                
                console.log(Object.keys(person)); // ["name", "address"]
                ```
                
                Object.values 메서드는 객체 자신의 enumerable한 프로퍼티 키를 배열로 반환한다.
                
                ```jsx
                console.log(Object.values(person)); // ["Lee", "Seoul"]
                ```
                
                Object.entries 메서드는 객체 자신의 enumerable한 프로퍼티 키와 값의 쌍의 배열을 배열에 담아 반환한다. 
                
                ```jsx
                console.log(Object.entries(person)); //[["name", "Lee"], ["address, "Seoul"]]
                ```
                
            
- built-in objects
    - 원시값과 래퍼객체
        
        문자열, 숫자, 불리언, 심벌 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 래퍼 객체라고한다. 원시값인 문자열, 숫자, 불리언, 심벌 값의 경우 이들 원시값에 대해 마치 객체처럼 마침표 표기법(또는 대괄호 표기법)으로 접근하면 자바스크립트 엔진이 일시적으로 원시값을 연관된 객체로 변환해준다. 원시값을 객체처럼 사용하면 자바스크립트 엔진은 암묵적으로 연관된 객체를 생성하여 생성된 객체로 프로퍼티에 접근하거나 메서드를 호출하고 다시 원시값으로 되돌린다.
        
        ```jsx
        const str = 'hello';
        
        //원시값인 str이 프로퍼티를 가진 것처럼 행동한다.
        console.log(str.length); // 5
        console.log(str.toUpperCase()); // HEllO
        ```
        
        ```jsx
        const str  = 'hello';
        
        // 식별자 str은 암묵적으로 생성된 래퍼 객체를 가르킨다
        // 식별자 str의 값 'hello'는 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된다.
        // 래퍼 객체에 name 프로퍼티가 동적 추가된다.
        str.name = 'Lee';
        
        // 식별자 str은 다시 원래의 문자열, 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된
        // 원시값을 가진다. 이때 이전에 생성된 래퍼 객체는 가비지 컬렉터의 대상이 된다.
        
        // 식별자 str은 이전에 생성된 래퍼 객체와는 다른 래퍼 객체를 가르키기 때문에
        // 새로운 래퍼객체 안에는 name 프로퍼티가 없다.
        console.log(str.name); //undefined
        
        // 식별자 str은 다시 워래의 문자열을 가지고 두 번째로 생성된 래퍼 객체도 가비지 컬렉터
        // 의 대상이 된다.
        console.log(typeof str, str); // string hello
        ```
        
        숫자도 똑같다.
        
        ```jsx
        const num = 1.5;
        
        console.log(num.toFixed()); //2
        
        console.log(typeof num, num); // number 1.5
        ```
        
        불리언도 할 수는 있는데 불리언의 함수를 부르는 일은 잘 없기 때문에 패스, 심벌은 나중에 알아보는걸로. 이렇게 문자열, 숫자, 불리언, 심벌은 암묵적으로 생성되는 래퍼 객체에 의해 마치 객체처럼 사용할 수 있으며, 표준 빌트인 객체인 String, Number, Boolean, Symbol의 프로토타입 메서드 또는 프로퍼티를 참조할 수 있다. 따라서 String, Number, Boolean, Symbol 생성자 함수를 new 연산자와 함께 호출하여 문자열, 숫자, 불리언 인스턴스를 생성할 필요가 없으며 권장하지도 않는다.  
        
    - 전역 객체
        
        global object is the special object that is created before any other objects are created (before the runtime).
        
        전역 객체는 자바스크립트 환경에 따라 지칭하는 이름이 제각각이다. 브라우저 환경에서는 window(또는 self, this, frames)가 전역 객체를 가르키지만 Node.js 환경에서는 global이 전역 객체를 가르킨다.
        
        **전역 객체는 표준 빌트인 객체(Object, String, Number, Function, Array 등)와 환경에 따른 호스트 객체(클라이언트 Web API 또는 Node.js의 호스트 API), 그리고 var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다.**
        
        전역 객체는 몇 가지 프로퍼티와 메서드를 가지고 있다. 전역 객체의 프로퍼티와 메서드는 전여 객체를 가리키는 식별자, 즉 window 나 global 을 생략하여 참조/호출할 수 있으므로 전역 변수와 전역 함수처럼 사용할 수 있다. 대표적인 프로퍼티, 함수들을 보자.
        
        - 빌트인 전역 프로퍼티
            
            **Infinity**
            
            ```jsx
            console.log(window Infinity === Infinity); //true
            console.log(3/0) // Infinity
            console.log(-3/0) // -Infinity
            console.log(typeof Infinity); // number
            ```
            
            **NaN**
            
            ```jsx
            console.log(window.Nan); //NaN
            console.log(Number('xyz')); //NaN
            console.log(1 * 'string'); //NaN
            console.log(typeof NaN); //number
            ```
            
            **undefined**
            
            undefined 프로퍼티는 원시 타입 undefined를 값으로 갖는다.
            
            ```jsx
            console.log(window.undefined);
            
            var foo;
            console.log(foo); // undefined
            console.log(typeof undefined); //undefined
            ```
            
        - 빌트인 전역 함수
            - **eval**
                
                ```jsx
                // 표현식인 문
                eval('1 + 2;'); // -> 3
                // 표현식이 아닌 문
                eval('var x = 5;'); // -> undefined
                
                console.log(x); //5
                
                // 객체 리터럴은 반드시 괄호로 둘러싼다
                const o = eval('({ a:1 })');
                console.log(o); // {a: 1}
                
                //함수 리터럴은 반드시 괄호로 둘러싼다
                const f = eval('(function() {return 1;})');
                console.log(f()); //1
                
                // 인수로 전달받은 문자열 코드가 여러 개의 문으로 이루어져 있다면 모든 문을 실행한
                // 다음, 마지막 결과값을 반환한다.
                eval('1 + 2; 3+4;'); // -> 7
                ```
                
                eval 함수는 자신이 호출된 위치에 해당하는 기존의 스코프를 런타임에 동적으로 수정한다.
                
                ```jsx
                const x = 1;
                
                function foo() {
                		//eval 함수는 런타임에 foo함수의 스코프를 동적으로 수정한다.
                		eval('var x = 2;');
                		console.log(x); //2
                }
                
                foo();
                console.log(x); //1
                ```
                
                eval 함수를 통해 사용자로부터 입략받은 콘텐츠를 실행하는 것은 보안에 매우 취약하다. 또한 eval 함수를 통해 실행되는 코드는 자바스크립트 엔진에 의해 최적화가 수행되지 않으므로 일반적인 코드 실행에 비해 처리 속도가 느다. **따라서 eval 함수의 사용은 금지해야 한다.**
                
            - **isFinite**
                
                ```jsx
                isFinite(0) // true
                isFinite(2e64) //true
                isFinite('10'); //true
                isFinite(null); // -> true: null -> 0
                
                //인수가 무한수 또는 NaN으로 평가되는 값이라면 false를 반환
                isFinite(Infinity); // false
                isFinite(-Infinity); // false
                isFinite(NaN) // false
                isFinite('Hello'); // false
                ```
                
            
            **isNan**
            
            - **parseFloat**
                
                전달받은 문자열을 실수로 해석해서 반환
                
                ```jsx
                parseFloat('3.14'); // 3.14
                
                //공백이 있으면 맨 앞에것만
                parseFloat('34 45 546'); //34
                parseFloat('20 years later'); //20
                
                //공백이 있을 때의 맨 앞에것이 숫자가 아니면 NaN
                parseFloat('He was 40'); // ->NaN
                
                //앞뒤 공백 무시
                parseFloat(' 60 '); // 60
                ```
                
            - **parseInt**
                
                전달받은 문자열을 정수로 해석해서 반환
                
                ```jsx
                parseInt('10'); // 10
                parseInt('10.123'); // 10
                
                //전달받은 인수가 무자열이 아니면 문자열로 변환한 다음, 정수로 해석하여 반환
                parseInt(10); // 10
                parseInt(10.123); // 10 
                
                //몇진수로 해석해라 설정할 수 있음
                parseInt('10'); // 10
                parseInt('10', 2); // 10
                parseInt('10', 4); // 10
                parseInt('10', 8); // 10
                parseInt('10', 16); // 10
                
                //공백이 있으면 맨 앞에것만
                parseInt('34 45 546'); //34
                parseInt('20 years later'); //20
                
                //공백이 있을 때의 맨 앞에것이 숫자가 아니면 NaN
                parseInt('He was 40'); // ->NaN
                
                //앞뒤 공백 무시
                parseInt(' 60 '); // 60
                ```
                
            - **encodeURI / decodeURI**
                
                encodeURI  함수는 완전한 URI(uniform resource identifier)를 문자열로 전달받아 이스케이프 처리를 위해 인코딩한다. encodeURI 함수는 매개변수로 전달된 문자열을 완전한 URI전체라고 간주한다. 따라서 쿼리 스트링 구분자로 사용되는 =, ?, &은 인코딩하지 않는다.
                
                ![Untitled](JavaScript%202c9f98085b324ae98e199576bbd836ed/Untitled%2014.png)
                
                ```jsx
                //완전한 URI
                const uri = 'http://example/com?박제욱&job=programmer&teacher';
                console.log(encodeURI(uri)); 
                //http://example/com?%EB%B0%95%EC%A0%9C%EC%9A%B1&job=programmer&teacher
                ```
                
                decodeURI 함수는 인코딩된 URI를 인수로 전달받아 이스케이프 처리 이전으로 디코딩한다.
                
                ```jsx
                const enc = encodeURI(uri);
                console.log(enc); //'trrp://example/com?%EB%B0%95%EC%A0%9C%EC%9A%B1&job=programmer&teacher'
                const dec = decodeURI(enc);
                console.log(dec); //'trrp://example/com?박제욱&job=programmer&teacher'
                ```
                
            - **encodeURIComponent / decodeURIComponent**
                
                encoedURIComponent 함수는 URI 구성 요소를 인수로 전달받아 인코딩한다.
                
                encodedURIComponent는 매개변수로 전달된 문자열을 URI의 구성요소인 쿼리 스트링이라고 간주한다. 따라서 쿼리 스트링 구분자로 사용되는 =, ?, &도 인코딩한다.
                
                ```jsx
                const uriComp = 'name=이웅모$job=programmer&teacher'
                
                let encoded = encodeURIComponent(uriComp);
                console.log(encoded); // 'name%3D%EC%9D%B4%EC%9B%85%EB%AA%A8%24job%3Dprogrammer%26teacher'
                let decoded = decodeURIComponent(encoded);
                console.log(decoded); // name=이웅모$job=programmer&teacher
                
                encoded = encodeURI(uriComp);
                console.log(encoded);
                decoded = decodeURI(encoded); // 'name=%EC%9D%B4%EC%9B%85%EB%AA%A8$job=programmer&teacher'
                console.log(decoded); // 'name=이웅모$job=programmer&teacher'
                ```
                
            
        - 암묵적 전역
            
            ```jsx
            console.log(x); // undefined
            //y는 window 객체의 프로퍼티일 뿐이므로 호이스팅이 발생하지 않음
            console.log(y); // ReferenceError: y is not defined
            
            var x = 10; //전역 변수
             
            function foo () {
            	//선언하지 않은 식별자에 값을 할당
            	y = 20;
            }
            foo();
            
            console.log(x + y); //30
            
            delete y;
            console.log(window.y) // undefined
            ```
            
            y는 변수 선언 없이 단지 전역 객체의 프로퍼티로 추가되었을 뿐이기 때문에 y는 변수가 아니다. y는 변수가 아니므로 변수 호이스팅이 발생하지 않는다 . 또한 전역변수같은 경우는 window 객체의 프로퍼티이긴해도 delete를 사용해서 지울 수 없었는데, y같은 경우 그냥 프로퍼티에 불과하기 때문에  delete로 지워도 된다.
            
        
- this
    
    
    | 함수 호출 방식 | this 바인딩 |
    | --- | --- |
    | 일반 함수 호출 | 전역 객체 |
    | 메서드 호출 | 메서드를 호출한 객체 |
    | 생성자 함수 호출 | 생성자 함수가 (미래에) 생성할 인스턴스 |
    | Function.prototype.apply/call/bind 메서드에 의한 간접 호출 | Function.prototype.apply/call/bind 메서드에 첫번째 인수로 전달한 객체 |
    - 일반 함수 호출
        
        when the callback function is called as a normal function, inside the callback function, this would be binded. 어떠한 함수라도 일반 함수로 호출되면 this에 전역객체가 바인딩된다.
        
        ```jsx
        var value = 1;
        
        const obj = {
        	value:100;
        	foo() {
        		console.log("foo's this: ", this); // {value: 100, foo: f}
        		setTimeout(function ()
        			console.log("callback's this: ", this)// window
        			console.log("callback's this.value", this.value)//1
        		}, 100);
        	}
        };
        
        obj.foo();
        ```
        
        이처럼 일반 함수로 호출된 모든 함수 (중첩 함수, 콜백 함수 포함) 내부의 this에는 전역 객체가 바인딩된다. 메서드 내부의 중첩하수나 콜백함수의 this 반인딩을 메서드의 this 바인딩과 일치시키기 위한 방법은 여러가지가 있다.
        
        ```jsx
        var value = 1;
        
        const obj = {
        	value: 100;
        	foo() {
        		console.log("foo's this", this);
        		//콜백함수 내부에서 this 대신 that을 참조한다.
        		const that = this; 
        		setTimeout(function () {
        			console.log(that.value); //100
        		}, 100);
        	}
        };
        
        obj.foo();
        		
        ```
        
        ```jsx
        var value = 1;
        
        const obj = {
        	value: 100;
        	foo() {
        		//콜백 함수에 명시적으로 this를 바인딩한다.
        		setTimeout(function () {
        			console.log(this.value); //100
        		}.bind(this), 100);
        	}
        };
        
        obj.foo();
        ```
        
        ```jsx
        var value = 1;
        
        const obj = {
        	value: 100;
        	foo() {
        		//화살표 함수 내부의 this는 상위 스코프의 this를 가르킨다.
        		setTimeout(() => console.log(this.value), 100); // 100
        	}
        };
        
        obj.foo();
        ```
        
    - 메서드 호출
        
        메서드 내부의 this에는 메서드를 호출한 객체, 즉 메서드를 호출할 때 메서드 이름 앞의 마침표(.) 연산자 앞에 기술한 객체가 바인딩된다.
        
        ```jsx
        const person =  {
        	name: 'Lee';
        	getName() {
        		// 메서드 내부의 this는 메서드를 호출한 객체에 바인딩된다.
        		return this.name;
        	}
        };
        
        // 메서드 getName 호출한 객체는 person이다.
        console.log(person.getName()); //Lee
        ```
        
        메서드는 그저 프로퍼티에 바인딩된 함수에 불과하다. 이 말인 즉슨 person 객체의 getName 프로퍼티가 가리키는 함수 객체는 person 객체에 포함된 것이 아니라 독립적으로 존재하는 별도의 객체라는 것이다. 따라서 getName 프로퍼티가 가리키는 함수 객체, 즉 getName 메서드는 다른 객체의 메서드가 될 수도 있고 일반 변수에 할당하여 일반 함수로 호출될 수도 있다.
        
        ```jsx
        const anotherPerson = {
        	name: "Kim";
        };
        
        anotherPerson.getName = person.getName;
        
        console.log(antherPerson.getName()); //Kim
        
        const getName = person.getName;
        
        console.log(getName()); // ' '
        //일반 함수로 호출된 getName 함수 내부의 this.name은 브라우저 환경에서 window.namㄷ
        //브라우저 상에서 window.name은 브라우저 창의 이름을 나타내는 빌트인 프로퍼티로써
        // 기본값은 ' '이다. Node.js 환경에서는 this.name이 undefined이다.
        ```
        
        ```jsx
        function Person(name) {
        	this.name = name;
        }
        
        Person.prototype.getName = function  () {
        	return this.name;
        }
        
        const me = new Person("Lee");
        
        console.log(me.getName()); // Lee
        
        Person.prototype.name = "Park";
        
        console.log(Person.prototype.getName()); // Park
        ```
        
    - 생성자 함수 호출
        
        생성자 함수 내부의 this에는 미래에 생성할 인스턴스가 반인딩된다.
        
        ```jsx
        function Military (name) {
            this.name = name;
        }
        
        const army = new Military("army');
        console.log(army) /* Military {name: 'army'}
        												name: "army"
        												[[Prototype]]: Object */
        const navy = Military("navy");
        console.log(navy);//undefined
        // 일반 함수로 호출된 Circle 내부의 this는 전역 객체를 가리킨다.
        console.log(window.name); // navy
        ```
        
    - Function.prototype.apply/call/bind 메서드에 의한 간접 호출
        
        apply, call, bind 메서드는 Function.prototype의 메서드다. 즉, 이들 메서드는 모든 함수가 상속받아 사용 할 수 있다. apply와 call의 메서드는 함수를 호출하면서 첫 번째 인수로 전달한 특정 객체를 호출한 함수의 this에 바인딩 한다.
        
        ```jsx
        function getThisBinding() {
        	return this;
        }
        
        const thisArg = { a:1 };
        
        console.log(getThisBinding.apply(thisArg)); // {a: 1}
        console.log(getThisBiding.call(thisArg)); // {a: 1}
        ```
        
        apply 메서드는 호출할 함수의 인수를 배열로 묶어 전달한다. Call 메서드는 호출할 함수의 인수를 쉽표로 구분한 리스트 형식으로 전달한다. 이처럼 apply와 call 멧드는 호출할 함수에 인수를 전달하는 방식만 다르고 this로 사용할 객체를 전달하면서 함수를 호출하는 것은 동일하다.
        
        ```jsx
        function getThisBinding() {
        	console.log(arguments);
        	return this;
        }
        
        const thisArg = {a: 1};
        
        console.log(getThisBinding.apply(thisArg, [1, 2, 3]));
        // Arguments(3) [1, 2, 3, callee: f, Symbol(Symbol.iterator): f]
        // {a: 1}
        
        //call 메서드는 호출할 함수의 인수를 쉽표로 수분한 리스트 형식으로 전달한다.
        console.log(getThisBinding.call(thisArg, 1, 2, 3));
        // Arguments(3) [1, 2, 3, callee: f, Symbol(Symbol.iterator): f]
        // {a: 1}
        ```
        
        apply 와 call메서드의 대표적인 용도는 arguments 객체와 같은 유사 배열 객체에 배열 메서드를 사용하는 경우다. arguments 객체는 배열이 아니기 떄문에 Array.prototype.slice 같은 배열의 메서드를 사용할 수 없으나 apply 와 call 메서드를 이용하면 가능하다.
        
        ```jsx
        function convertArgsToArray() {
            console.log(arguments);
            const arr = Array.prototype.slice.call(arguments);
            console.log(arr);
            return arr;
        }
        
        convertArgsToArray(1, 2, 3); // [1, 2, 3]
        ```
        
        Function .prototype.bind 메서드는 apply와 call 메서드와 달리 함수를 호출하지 않는다. 다만 첫 번째 인수로 전달한 값으로 this 바인딩이 교체된 함수를 새롭게 생성해 반환한다.
        
        ```jsx
        function getThisBinding() {
            return this;
        }
        
        const thisArg = {a:1};
        
        //getThisBinding 함수를 새롭게 생성해 반환한다.
        console.log(getThisBinding.bind(thisArg)); // getThisBinding
        //bind 메서드는 함수를 호출하지는 않으므로 명시적으로 호출해야한다.
        console.log(getThisBinding.bind(thisArg)()); //{a: 1}
        ```
        
        bind 메서드는 메서드의 this와 메서드 내부의 중첩 함수 또는 콜백 함수의 this가 불일치하는 문제를 해결하기 위해 사용된다.
        
        ```jsx
        const person = {
            name: 'Lee',
            foo(callback) {
                setTimeout(callback, 100);
            }
        };
        
        person.foo(function() {
            console.log(`Hi! my name is ${this.name}.`); // Hi! my name is .
        });
        ```
        
        이 예제에서 person.foo의 콜백 함수는 외부 함수 person.foo를 돕는 헬퍼 함수 역할을 하기 때문에 외부 함수 person.foo 내부의 this와 콜백 함수 내부의 this가 상이하면 문맥상 문제가 발생한다. → bind 메서드를 사용하여 this를 일치시킬 수 있다.
        
        ```jsx
        const mankind = {
            name: 'Lee',
            foo(callback) {
                setTimeout(callback.bind(this), 100);
            }
        };
        
        mankind.foo(function() {
            console.log(`Hi! My name is ${this.name}.`);
        }); // Hi! My name is Lee.
        ```
        
    
- execution context
    - types of src codes
        
        소스코드(executable codes)를 4가지 타입으로 구분하는 이유는 소스코드의 타입에 따라 실행 컨텍스트를 생성하는 과정과 관리 내용이 다르기 때문이다.
        
        1. 전역 코드
            
            전역 코드는 전역 변수를 관리하기 위해 최상위 스코프인 전역 스코프를 생성해야 한다. 그리고 var 키워드로 선언된 전역 변수와 선언문으로 정의된 전역 함수를 전역 객체의 프로퍼티와 메서드로 바인딩하고 참조하기 위해 전역객체와 연결되어야 한다. 
            
        2. 함수 코드
            
            함수 코드는 지역 스코프를 생성하고 지역 변수, 매개변수, arguments 객체를 관리해야 한다. 그리고 생성한 지역 스코프를 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결해야 한다.
            
        3. eval 코드
            
            eval 코드는 strict mode(엄격 모드)에서 자신만의 독자적인 스코프를 생성한다.
            
        4. 모듈 코드 
            
            모듈 코드는 모듈별로 독립적인 모듈 스코프를 생성한다.
            
    - evaluation and executions of the src codes
        
        자바스크립트 엔진은 소스코드를 2개의 과정, 즉 “소스코드의 평가”와 “소스코드의 실행” 과정으로 나누어 처리한다.
        
        소스코드 평가 과정에서는 실행 컨텍스트를 생성하고 변수, 함수 등의 선언문만 먼저 실행하여 생성된 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프(environment record in lexical environment)에 등록한다.
        
        소스코드 평가 과정이 끝나면 비로소 **선언문을 제외한 소스코드가 순차적으로 실행되기 시작한다. 즉, 런타임이 시작된다.** 이때 소스코드 실행에 필요한 정보, 즉 변수나 함수의 참조를 실행 컨텍스트가 관리하는 스코프에서 검색해서 취득한다. 그리고 변수 값의 변경 등 소스코드의 실행 결과는 다시 실행 컨텍스트가 관리하는 스코프에 등록된다.
        
        ![Untitled](JavaScript%202c9f98085b324ae98e199576bbd836ed/Untitled%2015.png)
        
        Let me provide you an example of how the execution context works.
        
        say the following source code is to be evaluated and executed.
        
        ```jsx
        var x;
        x = 1;
        ```
        
        **During the evaluation:** executes 선언문 var x; first. the identifier x is put to the scope managed by the execution context and initialized as undefined.
        
        **During the execution:** to allocate a value to the variable x, we have to see if variable x has ever been initialized. → see if the scope managed by the execution context has the variable x. if the variable x was initialized successfully in the scope during the evaluation, then the corresponding value goes in as the value of the key in the scope managed by the execution context as well.
        
        ![Untitled](JavaScript%202c9f98085b324ae98e199576bbd836ed/Untitled%2016.png)
        
    - the roles of execution context
        
        Let’s look at another code example
        
        ```jsx
        // 전역 변수 선언
        const x = 1;
        const y = 2;
        
        // 함수 정의
        function foo(a) {
        	//지역 변수 선언
        	const x = 10;
        	const y = 20;
        	//메서드 호출
        	console.log(a + x + y); // 130
        }
        
        // 함수 호출
        foo(100);
        
        // 메서드 호출
        console.log(x + y); //3
        ```
        
        - elaboration on the evaluation & execution of the code above
            1. **전역 코드 평가**
                
                소스코드 평가 과정에서는 선언문만 먼저 실행한다. 따라서 전역 코드의 변수 선언문과 함수 선언문이 먼저 실행 되고, 그 결과 생성된 전역 변수와 전역 함수가 실행 컨스트가 관리하는 전역 스코프에 등록된다. 이때  var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 객체의 프로퍼티와 메서드가 된다 .
                
            2. **전역 코드 실행**
                
                전역 코드 평가 과정이 끝나면 런타임이 본격적으로 시작된다. 이때 전역 변수에 값이 할당되고 함수가 호출된다. 함수가 호출되면 순차적으로 실행되던 전역 코드 실행을 일시 중단 하고 코드 실행 순서를 변경하여 함수 내부로 진입한다.
                
            3. **함수 코드 평가**
                
                함수 호출에 의해 코드 실행 순서가 변경되어 함수 내부로 진입하면 함수 내부의 문들을 실행하기에 앞서 함수 코드 평가 과정을 거치면 함수 코드를 실행하기 위해 준비를 한다. 이떄 매개변수와 지역 변수 선언문이 먼저 실행되고, 그 결과 생성된 매개변수와 지역 변수가 실행 컨텍스트기 관리하는 지역 스코프에 등록된다. 또한 내부에서 지역 변수처럼 사용할 수 있는 arguments 객체가 생성되어 지역 스코프에 등록되고 this바인딩도 결정된다.
                
            4. **함수 코드 실행**
                
                함수 코드 평가 과정이 끝나면 런타임이 시작되어 함수 코드가 순차적으로 실행되기 시작한다. 이때 매개변수와 지역 변수에 값이 할당되고 console.log 메서드가 호출된다.
                
                console.log를 호출하기 위해 먼저 식변자인 console을 스코프 체인을 통해 검색한다. 이를 위해 함수 코드의 지역 스코프는 상위 스코프인 전역 스코프와 연결되어야 한다. 하지만 console 식별자는 스코프 체인에 등록되어있지 않고전역 객체에 프로퍼티로 존재한다. 이는 전역 객체의 프로퍼티가 마치 전역 변수처럼 전역 변수처럼 전역 스코프를 통해 검색 가능해야 한다는 것을 의미한다.
                
                다음은 log 프로퍼티를 console 객체의 프로토타입 체인을 통해 검색한다. 그후 console.log 메서드에 인수로 전달된 표현식 a + x + y 가 평가된다. a, x, t 식별자는 스코프 체인을 통해 검색된다. console.log 메서드의 실행이 종료되면 함수 코드 실행 과정이 종료되고 함수 호출 이전으로 되돌아가 저역 코드 실행을 계속한다.
                
                comment
                
                이 모든 것을 관리하는 것이 바로 실행 컨텍스트다. **실행 컨텍스트는 소스코드를 실행하는 데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.** 좀 더 구체적으로 말해, 실행 컨텍스트는 식별자(변수, 함수, 클래스 등의 이름)를 등록하고 솬리하는 스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘으로, 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다. 식별자와 스코프는 실행 컨텍스트의 **렉시컬 환경**으로 관리하고 코드 실행 순서는 **실행 컨텍스트 스택**으로 관리한다.
                
    
    [실행 컨텍스트 스택 execution context stack](JavaScript%202c9f98085b324ae98e199576bbd836ed/%E1%84%89%E1%85%B5%E1%86%AF%E1%84%92%E1%85%A2%E1%86%BC%20%E1%84%8F%E1%85%A5%E1%86%AB%E1%84%90%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20%E1%84%89%E1%85%B3%E1%84%90%E1%85%A2%E1%86%A8%20execution%20context%20stack%20bd41e97eec98459e8174cc75ac99c57d.md)
    
    [렉시컬 환경 lexical environment ](JavaScript%202c9f98085b324ae98e199576bbd836ed/%E1%84%85%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B5%E1%84%8F%E1%85%A5%E1%86%AF%20%E1%84%92%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A7%E1%86%BC%20lexical%20environment%2000e5f620494149b493e1cc7cdc5165cb.md)
    
    [Execution Context and Block-level scope](JavaScript%202c9f98085b324ae98e199576bbd836ed/Execution%20Context%20and%20Block-level%20scope%20ca51f7d99960403bb71c01052d7c25cc.md)
    
    [클로저 Closure](JavaScript%202c9f98085b324ae98e199576bbd836ed/%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A5%20Closure%2038182ecdbd27428bba3aa3978882d25c.md)
    
    [Lexical Environments of the for loop](JavaScript%202c9f98085b324ae98e199576bbd836ed/Lexical%20Environments%20of%20the%20for%20loop%203fd7e2b033ba46a6baaa291b9e379d38.md)