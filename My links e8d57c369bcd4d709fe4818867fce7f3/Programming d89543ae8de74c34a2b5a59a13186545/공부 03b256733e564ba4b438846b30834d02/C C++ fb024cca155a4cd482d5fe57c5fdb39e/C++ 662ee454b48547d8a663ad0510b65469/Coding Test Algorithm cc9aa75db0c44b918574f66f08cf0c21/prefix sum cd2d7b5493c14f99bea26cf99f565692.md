# prefix sum

- 쉽게 풀기 위해서는 index 1부터 배열을 넣는다.
- 1번째 요소는 1번째까지 합한거, 2번째 요소는 2번째까지 합한거, 3번째 요소는 3번째까지 합한거…

승철이는 뇌를 잃어버렸다. 학교에 갔더니 선생님이 자연수로 이루어진 N개의 카드를 주며 M개의 질문을 던진다. 그 질문은 나열한 카드 중 A번째부터 B번째까지의 합을 구하는 것이다. 뇌를 잃어버렸기 때문에 승철이는 이 문제를 풀 수없다.문제를 풀 수 있는 프로그램을 작성해보자.

입력

수의개수, 합을 구해야 하는 개수 M, 그 이후 N개의 수가 주어진다. 수는 100 이하의 자연수, 그 이후 M개의 줄에는 합을 구해야 하는 구간 A,B가 주어진다.

출력

M개의 줄에 A부터 B까지의 합을 구하라.

범위

1≤N≤100,000

1≤M≤100,000

1≤A≤B≤N

예제 입력

8 3

1 2 3 4 5 6 7 8

1 4

1 5

3 5

예제 출력

10

15

12

- 위의 설명에서 N과M의 최댓값이 100000이라고 했으므로 만약 이중 for문을 썼을 시에 최악의 경우 시간복잡도가 O(1억)이 된다.
- 일단 위의 예제같은 경우 주어진 배열이 문제가 진행되는 동안 바뀌지 않는, 쉽게 말해 정적배열의 문제다.정적배열 문제의 경우 누적합으로 구현할 수가 있다. (동적 배열이면 팬윅트리를 써야 함).

```cpp
#include<bits/stdc++.h>
using namespace std;
int M, N, s, e;
int a[1000004];

void getSum(int idxS, int idxE){
  cout << a[idxE] - a[idxS-1] << "\n";
}

int main(){
  ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
  cin >> N;
  cin >> M;
  for(int i=1; i<=M; i++){
    cin >> a[i];
    a[i] = a[i] + a[i-1];
  }
  for(int i=1; i<N; i++){
    cin >> s >> e;
    getSum(s, e);
  }
  return 0;
}
```