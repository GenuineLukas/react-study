# C++

- need to know
    - 이 정돈 외우자
        
        10! = 3628800
        
        2^10 = 1024
        
        3^10 = 59049
        
        int 는 4 바이트로 대략 20억까지 표현 가능
        
        long long은 8바이트짜리 정수
        
        double은 8바이트 실수
        
        포인터의 크기는 OS가 32bit라면 4바이트, 64bit라면 8바이트로 고정되어 있다.
        
    - 연산 우선순위
        - long double (highest)
        - double
        - float
        - unsigned long long
        - long long
        - unsigned long
        - long
        - unsigned int
        - int (lowest)
    - 문자를 숫자로, 숫자를 문자로
        
        A ~ Z 는 65~90, a~z는 97~122 (ins ASCII code) 알파벳은 26개다.
        
    - std::string::npos 문자열에서 특정 값을 찾지 못했을 때 반환되는 값
    - vetor의 size()라는 메서드는 unsigned int를 반환한다. v.size() -10를 했는데 결과값이 음수가되길 기대하고 있다면 엄청나게 큰 unsigned int일 것이다.
    - 메모리와 포인터
        
        메모리 셀 한 칸 = 1byte
        
        변수의 메모리 주소란 변수가 사용하는 메모리 주소의 첫번째를 가르킨다. 변수에 값의 재할당이 일어나도 주소는 변하지 않는 것을 확인할 수 있다.
        
        ```cpp
        #include<bits/stdc++.h>;
        using namespace std;
        
        int i;
        int main() {
            cout << &i << "\n"; //0x404194
            i=0;
            cout << &i << "\n"; //0x404194
            return 0;
        }
        ```
        
        **포인터**
        
        메모리의 주소를 담는 타입이 포인터이다. 포인터는 메모리 동적할당, 데이터를 복사하지 않고 함수 매개변수로 사용, 클래스 및 구조체를 연결할 때 사용된다.
        
        int* 든 double*이든 결국 포인터는 주소값을 담는 것이므로 크기는 X64 체제에서는 8바이트, X32 체제에서는 4바이트로 동일하다.
        
        **역참조 연산자**
        
        포인터 식별자에 *(asterisk) 를 붙여 사용하면 역참조가 된다.
        
        ```cpp
        #include<bits/stdc++.h>;
        using namespace;
        
        int main(){
        	string name = "lukas";
        	string *b = &name;
        	cout << *b << "\n"; //lukas
        }
        ```
        
        Array to Pointer decay
        
        ```cpp
        int a[N];
        int *c = a;
        ```
        
        위와 같이 int[]와 int는 다른 타입인데도 불구하고 배열의이름이 마치 주소값처럼 행동하는이유는 Array to Pointer dacay라는 배열이 포인터로 부식되는 현상을 말한다. 이는 배열의 이름을 포인터에 할당 하면서 배열의 크기 정보 N이 없어지고 첫번째 요소의 주소가 바인딩 되는 현상을 의미한다. 참고로 vector는 안되고 array만 된다.
        
        ```cpp
        #include<bits/stdc++.h>
        using namespace std; 
        
        int a[3] = {1, 2, 3}; 
        int main(){
        	int * c = a;
        	cout << c << "\n"; 
        	cout << &a[0] << "\n"; 
        	cout << c + 1 << "\n"; 
        	cout << &a[1] << "\n"; 
        	return 0;
        }
        /*
        0x472010
        0x472010
        0x472014
        0x472014
        */
        ```
        
    - 프로세스 메모리 구조와 정적할당 & 동적할당
        
        운영채제는 프로세스에 메모리를 할당하는데 다음 구조를 기반으로 할당한다.
        
        ![Untitled](C++%20662ee454b48547d8a663ad0510b65469/Untitled.png)
        
        - 스택: 지역변수, 매개변수, 함수가 저장되고 컴파일 시에 크기가 결정된다. 그러나 함수가 함수를 호출하는 등에 따라 런타임 시 크기가 변경된다. [동적인 특징]
        - 힙: 힙은 동적 할당할 때 사용되며 런타임 시 크기가 결정된다. [동적]
        - 데이터 영역: BSS 영역과 Data 영역으로나뉘고 정적할당에 관한 부분을 담당한다. [정적]
        - 코드 영역: 소스코드들어감. [정적]
        
        정적할당 
        
        정적할당은 컴파일단계에서 메모리를 할당하는것을 말한다
        
        BSS segment와 Data segment / text segment로 나뉘어서저장된다.
        
        - BSS segment는 전역변수, static, const로 선언되어있는 변수 중 0으로 초기화 또는 초기화가 어떠한 값으로도 되어 있지않은 변수들이 이 메모리 영역에 할당된다.
            
            ```cpp
            #include<bits/stdc++.h>
            using namespace std; 
            int a;
            int b = 0;
            const int c = 0;
            int main(){
            	static int d;
            	static int e = 0; 
            	return 0;
            }
            ```
            
        - Data segment는 전역변수, static, const로 선언되어있는 변수 중 0이 아닌 값으로 초기화된 변수가 이 메모리 영역에 할당된다.
            
            ```cpp
            #include<bits/stdc++.h>
            using namespace std; 
            int a = 1;
            const int b = 2;
            int main(){
            	static int c = 3;
            	return 0; 
            }
            ```
            
        
        동적 할당
        
        동적할당은 런타임 단계에서 메모리를 할당받는 것이며 Stack과 Heap으로 나눠진다.
        
        - Stack은 지역변수, 매개변수, 실행되는 함수에 의해 늘어나거나 줄어드는 메모리 영역이다. 함수가호출될 때마다 호출될 때의 환경 등 특정 정보가 계속해서 stack에 저장된다. 또한, 재귀함수가 호출된다고 했을 때 새로운 스택 프레임이 매번 사용되기 때문에 함수 내의 변수 집합이 해당 함수의다른 인스턴스 변수를 방해하지 않는다.
        - Heap은 동적으로 할당되는 변수들을 담는다. malloc(), free() 함수를 통해 관리할수 있으면 동적으로 관리되는자료구조의경우 Heap영역을 사용한다. 예를 들어 vector는 내부적으로 heap영역을 사용한다.
    - std::endll과 \n의 차이
        1. **std::endl**:
            - **`std::endl`**은 줄 바꿈 문자를 출력하고, 출력 버퍼를 비워줍니다.
            - 즉, 출력 버퍼를 비우는 작업을 추가로 수행하기 때문에, 출력이 즉시 화면에 나타납니다.
        2. **"\n"**:
            - **`"\n"`**은 단순히 줄 바꿈 문자를 출력하는 역할을 합니다.
            - 출력 버퍼를 비우지 않고, 단순히 새 줄로 이동합니다.
        
        따라서 **`std::endl`**을 사용하면 줄 바꿈과 함께 출력 버퍼를 비우기 때문에, 출력 결과가 즉시 나타나지만, **`"\n"`**을 사용하면 줄 바꿈만 수행되고, 출력 버퍼를 비우지 않기 때문에 출력이 조금 더 느릴 수 있습니다.
        
        결론적으로, 일반적으로는 출력 버퍼를 비우는 작업이 필요하지 않은 경우 **`"\n"`**을 사용하는 것이 성능상 이점이 있습니다.
        
    - 이터레이터와 포인터의 차이
        
        c++에서 이터레이터는 컨테이너에 저장된 데이터에 접근하고 조작하는 데 사용되는 객체이다. 이터레이터는 컨테이너의 요소를 반복적으로 방문하거나 특정 위치에 접근할 수 있는 방법을 제공한다.
        
        간단히 말해, 이터레이터는 배열이나 리스트 같은 데이터 구조에 대한 “포인터” 역할을 한다. 이터레이터를 사용하면 컨테이너의 요소를 순회하거나 특정 요소에 접근할 수 있다. 또한 이터레이터를 사용하여 데이터를 추가, 삭제, 수정하는 등의 작업을 수행할 수도 있다.
        
        **이터레이터와 포인터의 차이점**
        
        1. 추상화 수준:
            - 이터레이터: 이터레이터는 컨테이너의 내부 구조를 숨기고 일관된 방식으로 요소에 접근할 수 있도록 추상화된 인터페이스를 제공한다. 이터레이터는 보통 begin()과 end()함수를 통해 컨테이너의 처음과 끝을 가리키며, 요소에 접근하거나 순회할 수 있다.
            - 포인터 : 포인터는 직접적으로 메모리 주소를 다루는데, 데이터에 대한 접근을 보다 저수준의 방식으로 제공한다. 포인터는 컨테이너의 내부 구조를 알아야 하며, 요소에 대한 접근 방법이 컨테이너의 종류에 따라 달라질 수 있다.
        2. 타입 안정성:
            - 이터레이터: 이터레이터는 컴파일러가 타입을 검사하므로 타입 안전성이 보장된다. 예를 들어, ‘std::vector<int>’에 대한 이터레이터는 ‘int’ 형 요소에 대해서만 작동하며, 잘못된 형변환을 방지한다.
            - 포인터: 포인터는 보다 낮은 수준의 추상화를 제공하므로 올바르지 않은 형변환을 허용할 수 있으며, 잘못된 메모리 주소를 가리킬 수도 있다.
        3. 범위:
            - 이터레이터: 이터레이터는 순회할 범위를 명시적으로 지정한다. 따라서 컨테이너의 시작과 끝을 나타내는 이터레이터가 필요하다.
            - 포인터: 포인터는 단일 메모리 위치를 가리키기 때문에 순회할 범위를 명시적으로 지정하지 않는다. 따라서 시작 포인터와 끝 포인터 사이의 요소를 순회할 때 주의가 필요하다.
        
        이러한 차이로 인해 이터레이터는 컨테이너의 순회나 조작을 추상화하고 안전하게 해주는 반면, 포인터는 보다 저수준의 메모리 주소를 다루며 유연성이 더 크다. 종종 이터레이터는 포인터보다 안전하고 사용하기 쉽지만, 특정 상황에서는 포인터가 더 직관적이고 유용할 수 있다.
        
    - 배열 초기화 (엘레멘트들 채우기!)
        
        fill()은 모든 값으로 초기화할 수 있고, memset()은 -1, 0으로만 초기화 할 수 있다. fill()만 쓰면되지 왜 굳이 memset()까지 알아야 하냐고 묻는다면 0, -1로 초기화하는 경우 fill()보다 memset()이 더 빠르기 때문이다.
        
        ```cpp
        #include <bits/stdc++.h>
        using namespace std;
        int a[10];
        int b[10][10];
        
        int main(){
            fill(&a[0], &a[10], 100);
            for(int i=0; i<sizeof(a)/sizeof(a[0]); i++){
                cout << a[i] << " ";
            }
            cout << "\n";
        
            fill(&b[0][0], &b[9][10], 2);
            for(int i=0; i<sizeof(b)/sizeof(b[0]); i++){
                for(int j=0; j<sizeof(b[0])/sizeof(int); j++){
                    cout << b[i][j] << " ";
                }
                cout << "\n";
            }
            return 0;
        }
        /*
        100 100 100 100 100 100 100 100 100 100 
        2 2 2 2 2 2 2 2 2 2 
        2 2 2 2 2 2 2 2 2 2 
        2 2 2 2 2 2 2 2 2 2 
        2 2 2 2 2 2 2 2 2 2 
        2 2 2 2 2 2 2 2 2 2 
        2 2 2 2 2 2 2 2 2 2 
        2 2 2 2 2 2 2 2 2 2 
        2 2 2 2 2 2 2 2 2 2 
        2 2 2 2 2 2 2 2 2 2 
        2 2 2 2 2 2 2 2 2 2
         */
        ```
        
        ### memset
        
        memset()은 바이트 단위로 초기화를 하며 0, -1, char형의 하나의 문자 등으로 초기화를 할 때만 사용한다.
        
        ```cpp
        void * memset(void* ptr, int value, size_t num);
        ```
        
        예시
        
        ```cpp
        int a[1004];
        int a2[1004][1004];
        int main(){
        	memset(a, -1, sizeof(a));
        	memset(a2, 0, sizeof(a2));
        	for(int i=0; i<10; i++) cout << a[i] << " ";
        	return 0;
        }
        ```
        
    - 얕은 복사 vs 깊은 복사
        
        얕은 복사는 메모리주소값을 복사한 것이라 복사한 배열을 수정하면 원본 배열이 수정되는 복사방법이며 깊은 복사는 새로운 메모리공간을 확보해 완전히 복사해 복사한 배열을 수정하면 원본 배열은 수정되지 않는 복사방법을 의미한다.
        
        ### memcpy()
        
        Array끼리 복사할 때 쓴다. **깊은 복사다.**
        
        ```cpp
        void *memcpy(void* destination, const void* source, size_t num);
        ex)
        int v[3] = {1, 2, 3};
        int ret;
        memcpy(ret, v, sizeof(v));
        ```
        
    - ios_base::sync_with_stdio(0); cin.tie(0);를 왜 쓰는가
        
        시간초과를 방지하기위해서 이 줄들을 추가해준다.
        
        ```cpp
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        ```
        
        1. `ios_base::sync_with_stdio(false);`
            
            이 구문은 c의 stdio와 cpp의 iostream을 동기화 시켜주는 역할을 하는데 이 때 iostream과 stdio의 버퍼를 모두 사용하기 때문에 딜레이가 발생한다. 따라서 위 코드를 작성해줌으로써 동기화를 비활성화 시켜준다. 그러면 C++만의 독립적인 버퍼가 생성이 되어 c의 버퍼와 병행하여 사용할 수 없게 되지만, 사용하는 버퍼의 수가 줄어들었기 때문에 실행 속도는 빨라지게 된다. 하지만 동기화된  C++ 버퍼의경우 thread-safe하기 때문에 모든 I/O의 순서가 예상한것과 정확히 일치함을 보장할 수 있지만 위 코드를 추가하면서 동기화가 비활성화됐기에 멀티스레드 환경에서는 출력순서를 보장할 수 없다. 그리고 버퍼가 분리되었기 때문에 cin과 C 의 scanf, gets, getchar 그리고 cout과 C의 printf, puts, putchar등을 같이사용하면 오류가 발생한다.
            
        2. `cin.tie(null)`
            
            default로 cin과 cout은 tie 되어있다.
            
            tie 한다는 것은 두개의 stream이 sync 되어 있기 때문에 한 스트림에서다른 스트림이 작업 요청을 하게 되면, 작업했던 내용을 flush한다는 의미이다.
            
            ### ⚡flush?
            
            buffer에 쌓아둔 데이터를 모두 내보내는(가져오는) 것을 말한다.
            
            기본적으로 tie 되어 있는 스트림들은 한 스트림이 다른 스트림에서 각 IO 작업을 진행하기 전에 자동으로 버퍼를 비워줌을 보장해준다.
            
            ```cpp
            cout<< "당신은 몇살이십니까? : ";
            cin>>age;
            ```
            
            위와 같은 코드가 있을 때 cin과 tie가 묶여있는 경우 나이를 입력하기 전에 "당신은 몇 살이십니까?"가 먼저 출력될 것이다. 하지만 cin.tie(null);코드를 추가한다면 cin과 cout의 tie가 풀리게 되면서 "당신은 몇 살이십니까?"가 출력되기 전에 나이를 입력받는 경우가 발생할 수있다.
            
    - 지역변수 보다는 전역변수를, 변수명을 간결하게.
        
        지역변수는 stack에 할당이되고 예측할 수 없는 쓰레기값이 할당이된다. 전역변수는 bss segment 또는 data segment에 들어가면서 값을 최기화 하지 않은 경우 0으로 초기화가 된다.
        
        또한, 지역변수로 선언하게 되면 stack에 쌓이는데 이 때 OS에서 성능상의 이유로 stack영역에 메모리 제한을 걸어버린다.그렇게 때문에 많은 배열을 선언하지 못한다. (보통 지역변수 int형 배열은 25만까지 가능하다고 알려져 있다.)
        
        전역변수로 tree를 10,000,000개 설정한 코드는 잘 구동이된다.
        
        ```cpp
        #include <bits/stdc++.h>
        using namespace std;
        int tree[10000000]; //working fine
        int main(){
        		cin >> a >> b;
        }
        ```
        
        그러나 지역변수로 선언한 코드는 그 아래의 로직이 구동되지 않는다.
        
        ```cpp
        #include <bits/stdc++.h>
        using namespace std;
        int a, b;
        int main(){
        	int tree[10000000]; //process exited after 0.2841 seconds with return value 3221225725
        	cin >> a >> b;
        }
        ```
        
    - 문자열 크기선언
        
        예를 들어 100개짜리 문자를 입력받는다. 또한 이걸 string이 아니라 char[]로 한다면 char[101]로 선언해야 한다. C++, C에서 문자는 null로 종료되는 것이 원칙이므로 마지막에 무조건 널문자인 ‘\0’에 해당하는 바이트가 붙는다.
        
        ```cpp
        char str[100];
        char str[101];
        ```
        
    - 참조에러
        
        queue나 stack에서 top이나 pop연산을할 때 항상 size를 체크해야 한다. 아래코드처럼 구축.
        
        ```cpp
        if(q.size() && q.top == value)
        ```
        
        만약 해당 자료구조에 아무것도없는데해당 자료구조 내의 요소를 참조하려고 할 경우 참조에러(reference error)가 발생할 수있다.
        
    - endl 보다는 “\n” 을 써라
        
        endl를 쓰는거 보다 \n을 쓰는게 속도측면에서 좋다. endl은 ‘\n’+버퍼플러시라고 생각하면 된다. 출력 싱크를 보다 정확하게 만들어준다.
        
        - 버퍼플러시: 임시 저장 영역에서 컴퓨터의 영구 매ㅔ모리로 데이터를 전송하는 것을 말한다.
        - 파일을 변경하면 한 컴퓨터 화면에서 볼 수 있는 변경 사항이 일시적으로버퍼에 저장되고 사용자의 작업에 의해 HD로 플러시될지, 소멸될지가 정해진다.
        - 예) 워드문서를 열어 임시 파일을 생성, 저장하지 않고 닫으면 자동으로 소멸.
        - 저장하게 되면 해당 문서에 대한 변경 사항이 버퍼에서 HD로 플러시된다.
            
            ```cpp
            #include <bits/stdc++.h>
            using namespace std;
            
            int main(){
              //버퍼플러시전
              for(int i=1; i<=5; ++i){
                cout << i << "\n";
                this_thread::sleep_for(chrono::seconds(1));
              }
              cout << endl;
              
              //버퍼 플러시 후 
              for(int i=1;i<=5;++i){
                cout << i << "\n" << flush;
                this_thread::sleep_for(chrono::seconds(1));
              }
              cout << endl;
            
            //버퍼 플러시 후 : 위와 동일한 코드 
              for (int i = 1; i <= 5; ++i){
                cout << i << endl;
                this_thread::sleep_for(chrono::seconds(1));
              }
              cout << endl;
              return 0;
            }
            /*
            1
            2
            3
            4
            5
            
            1
            2
            3
            4
            5
            
            1
            2
            3
            4
            5
            */
            ```
            
            “\n” << flush 와 endl은 같다고 보면 된다. <<”\n”;의 겨ㅇ우 한개씩 1, 2, 3, 4, 5가 나와야하는데  ‘어떤 경우에는’ 한번에 출력될 수도 있다. 플러시는 이를 무조건 순차적으로 출력되게 해준다.왜냐하면 콘솔창으로 바로 “출력을 플러쉬”해주는 역할을한다.
            
    - 따닥따닥 붙어있는 것을 어떻게 입력받나?
        
        *왠만하면 cin으로 입력받고 cout으로 출력하자.
        
        인풋
        
        ```cpp
        4 4
        1000
        0000
        0111
        0000
        ```
        
        1. string으로 변환
            
            문자열 s를 받아 문자열을 문자로 분해해서 타입변환을 통해 숫자를 int타입 배열인 a[i][j]에 넣는다.
            
            ```cpp
            #include <bits/stdc++.h>
            using namespace std;
            int n, m, a[10][10];
            string s;
            int main(){
              cin >> n >> m;
              for(int i=0; i<n; i++){
                cin >> s;
                for(int j=0;j<m;j++){
                  a[i][j] = s[j] - '0';
                }
              }
              for(int i=0; i<n; i++){
                for(int j=0; j<m; j++){
                  cout << a[i][j];
                }
                cout << '\n';
              }
              return 0;
            }
            
            /* 
            44 
            1000 
            0000 
            0111 
            0000 
            1000 
            0000 
            0111 
            0000
            */
            ```
            
        2. scanf사용
            
            ```cpp
            #include <bits/stdc++.h>
            using namespace std;
            
            int a[10][10], n, m;
            int main(){
              cin >> n >> m;
              for(int i=0; i<n; i++){
                for(int j=0; j<m; j++){
                  scanf("%1d", &a[i][j]);
                }
              }
              return 0;
            }
            ```
            
            ** scanf는 char 타입을 입력할 때는 조금 주의해야 한다.
            
            띄어쓰기를 %c앞에 넣어서 입력을 받아야 한다. 숫자인 d로 입력을 받게 되면 이런 현상이 일어나지 않지만 c로 받게 되면 특수문자, 엔터를 문자로 취급해서 입력을 받기 때문에 이렇게 신경을 써야 한다.
            
            ```cpp
            #include <bits/stdc++.h>
            using namespace std;
            char a[10][10];
            int main(){
              for(int i=0; i<2; i++){
                for(int j=0; j<4; j++){
                  scanf(" %c", &a[i][j]);
                }
              }
              for(int i=0; i<2; i++){
                for(int j=0;j<4;j++){
                  printf("%c", a[i][j]);
                }
                printf("\n");
              }
              return 0;
            }
            ```
            
        3. char타입 & cin
            
            char타입으로 2차원 배열을 정의했을 때는 다음코드처럼 cin으로 그냥 받을 수 있다.
            
            ```cpp
            #include<bits/stdc++.h>>
            using namespace std;
            char a[54][54];
            int main(){
              for(int i=0; i<2; i++){
                for(int j=0; j<4; j++){
                  cin >> a[i][j];
                }
              }
              for(int i=0; i<2;i++){
                for(int j=0; j<4; j++){
                  cout << a[i][j] << " ";
                }
                cout << "\n";
              }
              return 0;
            }
            ```
            
    - 문제에서 입력의 끝을 정하지 않은 경우
        
        아래와 같이 코드를 구축하면 된다.
        
        ```tsx
        while(scanf("%d", &n) != EOF)
        
        while(cin >> n) 
        ```
        
        scanf
        
        ```tsx
        #inlcude <bits/stdc++.h>
        using namespace std;
        
        int n;
        int main(){
        	while (scanf("%d", &n)= EOF) {
        		cout << 1 << '\n';
        	}
        }
        ```
        
        cin
        
        ```tsx
        #include <bits/stdc++.h>
        using namespace std;
        
        int n;
        int main(){
        	while(cin >> n){
        		cout << 1 << '\n';m   dwser 
        	}
        }
        ```
        
    - 입력이 2차원 배열로 주어지면 어떻게 하나?
        
        ```cpp
        #include <bits/stdc++.h>
        using namespace std;
        
        vector<vector<int>> v = {{0, 0, 1}, {1, 0, 1}, {0, 1, 0}};
        int main() {
          int n = v.size();
          int m = v[0].size();
          for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
              cout << v[i][j] << " ";
            }
            cout << '\n';
          }
          return 0;
        }
        ```
        
    - 그래프 이론
        
        보통 u:from v:to
        
        v로부터 나가는 간선이 세 개다 → outdegree가 3개다
        
        v로 들어오는 간선이 세 개다 → indegree가 3개다
        
        - 가중치: 정점과 정점 사이에 드는 비용
    - 트리 이론
        
        트리는 자식노드와 부모노드로 이루어진 계층적인 구조를 가지며 무방향 그래프의 일종이자 사이클이 없는 자료구조를 의미한다.
        
        - Vetrtex - 1 = Edge
        - 이진트리: 각 노드의 자식의 개수가 2개 이하로 정해진 트리
        - 균형 이진 트리: 모든 노드의 왼쪽 하위트리와 오른쪽 하위트리의 차이가 1 이하인 트리.
        - 이진 탐색 트리: 오른쪽 하위 트리에는 “노드의 값보다 큰 값”이 있는 노드만 포함되고 왼쪽 하위트리에는 “노드의 값보다 작은값”이 들어있는 트리를 말한다.
        - 최악의 BST 상황에서는 linear한 형태가 나올 수 있는데 이를 노드를 회전시키는 등의 방식으로 구현하여 언제나 균형잡히게 만든 AVL tree나 Red Black tree가 있다. 예를 들어 map 자료구조의 경우 삽입, 삭제, 수정의 시간 복잡도가 O(logN)을 보장 받는데 이는 내부적으로 레드 블랙 트리로 구현되어 있기 때문이다.
        
        ![Untitled](C++%20662ee454b48547d8a663ad0510b65469/Untitled%201.png)
        
    - 인접 행렬
        
        **인접: 연결되어 있다
        
        - 인접 행렬: 그래프에서 정점과 간선의 관계를 나타내는 bool타입의 정사각형 행렬
            - c++에서 캐싱하는 결대로 이중 for룹을 i부터 돌리는게 더 빠르다.
        
        ```cpp
        for(int i=0; i<V; i++){
        	for(int j=0; j<V; j++){
        		if(a[i][j]){
        			//출력하는 로직
        			cout << i << "부터" << j << "까지 경로가 있습니다.\n"
        			//해당 정점으로부터 탐색하는 로직
        			bfs(i);
        			dfs(i);
        		}
        	}
        }
        ```
        
        0번부터 방문안한 노드를 찾고 해당 노드부터 방문, 연결된 노드를 이어서 방문해서 출력하는 재귀함수
        
        ```cpp
        #include <bits/stdc++.h>
        using namespace std;
        
        const int V = 10;
        bool a[V][V], visited[V]; 
        
        void go(int from){
            visited[from] = 1;
            cout << from << "\n";
            for(int i=0; i<V; i++){
                if(visited[i])continue;
                if(a[from][i]){
                    go(i);
                }
            }
        }
        
        int main(){
            a[1][2]=1;a[3][4]=1;a[1][3]=1;
            a[2][1]=1;a[4][3]=1;a[3][1]=1;
            
            for(int i=0; i<V; i++){
                for(int j=0; j<V; j++){
                    if(a[i][j] && visited[i] == 0){
                        go(i);
                    }
                }
            }
        }
        ```
        
    - 인접 리스트
        - vector로 구현
        - 0번부터 방문안한 노드를 찾고 해당 노드부터 방문, 연결된 노드를 이어서 방문해서 출력하는 재귀함수
        
        ```cpp
        #include <bits/stdc++.h>
        using namespace std;
        const int V = 10;
        vector<int> adj[V];
        int visited[V];
        
        void go(int idx){
            cout << idx << "\n";
            visited[idx] = 1;
            for(int there : adj[idx]){
                if(visited[there]) continue;
                go(there);
            }
            return;
        }
        
        int main(){
            adj[0].push_back(1);
            adj[0].push_back(2);
            adj[0].push_back(3);
            
            adj[1].push_back(0);
            adj[1].push_back(2);
            
            adj[2].push_back(0);
            adj[2].push_back(1);
            
            adj[3].push_back(0);  
            for(int i=0; i<V; i++){
                if(adj[i].size() && visited[i] == 0) go(i);
            }
        }
            
        ```
        
    - 인접행렬 vs 인접리스트
        
        
        |  | 인접행렬 | 인접리스트 |
        | --- | --- | --- |
        | 공간 복잡도 | O(v^2) | O(V+E) |
        | 시간 복잡도(간선 한개 찾기) | O(1) | O(V) 모든 간선과 이어져 있을 때 |
        | 시간 복잡도(간선 모두 찾기) | O(V^2) | O(V+E) |
        
        **그래프가 희소할 때는 인접리스트, 조밀 할 때는 인접행렬이 좋다.**
        
        그래프가 조밀할 떄는 인접행렬이 인접 리스트보다 좋다. 어짜피 다 연결되어이기 때문에 메모리적 효율성은 동일해지고 정점i에서 정점j까지의 간선이 있는 확인하는 속도가 더 빠르기 때문에 인접행렬이 더 빠르다.
        
        ![Untitled](C++%20662ee454b48547d8a663ad0510b65469/Untitled%202.png)
        
        **둘 중 무엇을 쓸까?**
        
        대부분 인접리스트를 쓰면 됨. 문제에서 sparse한 그래프가 많이 나옴.
        
        다만, 문제 또는 코딩 인터뷰에서 인접행렬로 주어진다면 그대로 인접행렬로 푸는 것이 좋다.
        
    - 맵과 방향벡터
        
        문제에서 맵의 형태로 주어지면 진짜 맵 그대로 푸렁야지 인접 행령이나 리스트의 형태로 바꾸어서 풀면 안된다.
        
        크게 상하좌우, 많으면 대각선으로 갈 수 있는 것도 있음.
        
        상하좌우+대각선 예
        
        ```cpp
        #include <bits/stdc++.h>
        using namespace std;
        
        //상부터
        const int dx[] = {0, 1, 1, 1, 0, -1, -1, -1};
        const int dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};
        
        int main(){
            int y=0, x=0;
            for(int i=0; i<8; i++){
                int ny = y + dy[i];
                int nx = x + dx[i];
                cout << "(" << nx << ", " << ny <<")\n";
            }
            return 0;
        }
        ```
        
        맵이 3X3으로 주어지고 (0, 0)은 무조건 1. (0,0)부터 4방향을 기준으로 한칸씩 탐색하면서 방문했던 곳은 재방문하지 않고 좌표를 출력하는 코드.
        
        ```cpp
        #include <bits/stdc++.h>
        using namespace std;
        
        const int n=3;
        int a[3][3], visited[3][3];
        
        const int dx[]={0, 1, 0, -1};
        const int dy[]={-1, 0, 1, 0};
        
        void go(int y, int x){
            visited[y][x] = 1;
            cout << "(" << y << ", " << x << ")\n";
            for(int i=0; i<4; i++){
                int ny = y+dy[i];
                int nx = x+dx[i];
                if(ny < 0 || ny >=n||nx < 0||nx >=n)continue;
                if(visited[ny][nx]) continue;
                if(a[ny][nx] == 0) continue;
                go(ny, nx);
            }
            return;
        }
        
        int main(){
            a[0][0]=1;a[1][0]=1;a[0][2]=1;
            a[2][1]=1;a[2][2]=1;a[1][2]=1;
            go(0, 0);
        }
        
        ```
        
    - bfs
        
        ```cpp
        #include <bits/stdc++.h>
        using namespace std;
        vector<int> adj[100];
        int visited[100];
        int nodeList[] = {10, 12, 14, 16, 18, 20, 22, 24};
        void bfs(int here){
            queue<int> q;
            visited[here] = 1;
            q.push(here);
            while(q.size()){
                int here = q.front(); q.pop();
                for(int there : adj[here]){
                    if(visited[there]) continue;
                    visited[there] = visited[here] + 1;
                    q.push(there);
                }
            }
        }
        int main(){
            adj[10].push_back(12);
            adj[10].push_back(14);
            adj[10].push_back(16);
            
            adj[12].push_back(18);
            adj[12].push_back(20);
            
            adj[20].push_back(22);
            adj[20].push_back(24);
            bfs(10);
            for(int i : nodeList){
                cout << i << " : " << visited[i] << '\n';
            }
            cout << "10번으로부터 24번까지 최단거리는 : " << visited[24]-1 << "\n";
            return 0;
        }
        
        ```
        
        승원이는 당근을 좋아해서 당근마켓에 엔지니어로 취업했다. 당근을 매우 좋아하기 때문에 차도 당근차를 샀다. 이 다근차는 한칸 움직일 때마다 당근을 내뿜으면서 간다. 즉 한칸 움직일 때 당근한개가 소모된다는 것이다. 승원이는 오늘도 아침 9시에 일어나 당근 마켓으로 출근하고자 한다. 승원이는 최단거리로 당근마켓으로 향한다고 할 때 당근 몇 개를 소모해야 당근마켓으로 갈 수 있는지 알아보자. 이 때 승원이는 육지로만 갈 수 있으며 바다로는 못 간다. 맵의 1은 육지며 0은 바다를 가리킨다. 승원이는 상하좌우로만 갈 수 있다.
        
        입력: 맵의 세로길이 N과 가로길이 M이 주어지고 이어서 N*M의 맵이 주어진다. 그 다음 줄에 승원이의 위치 (y,x)와 당근마켓의 위치(y, x)가 주어진다.
        
        출력: 당근을 몇 개 소모해야 하는지 출력
        
        1≤N≤100
        
        1≤M≤100
        
        5 5
        
        0 0
        
        4 4
        
        1 0 1 0 1
        
        1 1 1 0 1
        
        0 0 1 1 1
        
        0 0 1 1 1
        
        0 0 1 1 1
        
        → 9
        
        ```cpp
        #include <bits/stdc++.h>
        using namespace std;
        
        int a[104][104];
        int visited [104][104];
        int n, m;
        int ty, tx;
        int oy, ox;
        int x, y;
        
        int dy[] = {-1, 0, 1, 0};
        int dx[] = {0, 1, 0, -1};
        
        void bfs(int sy, int sx){
            queue<pair<int, int>> q;
            visited[sy][sx] = 1;
            q.push({sy, sx});
            while(q.size()){
                tie(y, x) = q.front(); q.pop();
                for(int i=0; i<4; i++){
                    int ny = y+dy[i];
                    int nx = x+dx[i];
                    if(ny < 0 || nx < 0 || ny >= n || nx >= m || a[ny][nx] == 0) continue;
                    if(visited[ny][nx]) continue;
                    visited[ny][nx] = visited[y][x] + 1;
                    q.push({ny, nx});
                }
            }
        }
        
        int main(){
            cin >> n >> m >> oy >> ox >> ty >> tx;
            for(int i=0; i<n;i++){
                for(int j=0; j<m; j++){
                    cin >> a[i][j];
                }
            }
            bfs(oy, ox);
            cout << visited[ty][tx] << "\n";
            return 0;
        } 
        ```
        
    - brute force
        
        ![Computer Science-3.jpg](C++%20662ee454b48547d8a663ad0510b65469/Computer_Science-3.jpg)
        
        ```cpp
        #include <bits/stdc++.h>
        using namespace std;
        
        int n = 10, mod=11,ret, cnt;
        vector<int> v= {24, 35, 38, 40, 49, 59, 60, 67, 83, 98};
        
        void go(int idx, int sum){
            if(idx == n){
                ret = max(ret, sum%mod);
                cnt++;
                return;
            }
            go(idx+1, sum+v[idx]);
            go(idx+1, sum); 
        }
        
        int main(){
            go(0, 0);
            cout<<ret<<"\n"; //10
            cout<<cnt<<"\n"; //1024
            return 0;
        }
        ```
        
    - backtracking
        
        홀철이는 3*3 맵에서 {0, 0} 지점에서 길을 잃어버렸다. 긍정왕 홍철이는 길을 잃어버린 김에 구걸을 하면서 돈을 모으면서 여행을 가려고 한다. 목적지는 [2, 2}이며 방문한 정점을 다시 방문할 수 없고 해당 맵에 구걸로 얻을 수 있는 돈들이 있다 홍철이는 4방향(상하좌우)로 움직일 수 있다. {2,2} 간다고 했을 때 이 돈들을 모으는 모든 경우의 수를 출력하여라.
        
        ```cpp
        #include <bits/stdc++.h>
        using namespace std;
        const int n = 3;
        int a[3][3] = {
            {10, 20, 21},
            {70, 90, 12},
            {80, 110, 120}
        },  cnt;
        int visited[3][3];
        const int dy[] = {-1, 0, 1, 0};
        const int dx[] = {0, 1, 0, -1};
        vector<int> v;
        
        void print(){
            for(int i : v) cout << i << " ";
            cout << '\n';
        }
        
        void go(int y, int x){
            if(y == n-1 && x == n-1){
                print();
                cnt++;
                return;
            }
            for(int i=0; i<4; i++){
                int ny = y + dy[i];
                int nx = x + dx[i];
                if(ny<0 || ny>=n || nx<0 || nx>=n) continue;
                if(visited[ny][nx])continue;
                visited[ny][nx] = 1;
                v.push_back(a[ny][nx]);
                
                go(ny, nx);
                
                visited[ny][nx] = 0;
                v.pop_back();
            }
        }
        
        int main() {
            visited[0][0] = 1;
            v.push_back(a[0][0]);
            go(0, 0);
            cout << "count: " << cnt << "\n";
            return 0;
        }
        /*
        10 20 21 12 120 
        10 20 21 12 90 110 120 
        10 20 21 12 90 70 80 110 120 
        10 20 90 12 120 
        10 20 90 110 120 
        10 20 90 70 80 110 120 
        10 70 90 20 21 12 120 
        10 70 90 12 120 
        10 70 90 110 120 
        10 70 80 110 90 20 21 12 120 
        10 70 80 110 90 12 120 
        10 70 80 110 120 
        count: 12
        */
        ```
        
    - 원복
        
        밑줄친 부분들이 중요한 부분
        
        ```cpp
        #include <bits/stdc++.h>
        using namespace std;
        const int n = 3;
        int a[3][3] = {
            {10, 20, 21},
            {70, 90, 12},
            {80, 110, 120}
        };
        int visited[3][3];
        const int dy[] = {-1, 0, 1, 0};
        const int dx[] = {0, 1, 0, -1};
        vector<int> v;
        
        void print(){
            for(int i : v) cout << i << " ";
            cout << '\n';
        }
        
        void go(int y, int x){
            if(y==n-1 && x==n-1){ //기저사례
                print();
                return;
            }
            visited[y][x] = 1;
            for(int i=0; i<4; i++){
                int ny = y + dy[i];
                int nx = x + dx[i];
                if(ny<0 || ny>=n || nx<0 || nx>=n) continue;
                if(visited[ny][nx]) continue;
                v.push_back(a[ny][nx]);
                go(ny, nx);
                visited[ny][nx] = 0;
                v.pop_back();
            }
        }
        
        int main(){
            visited[0][0] = 1;
            v.push_back(a[0][0]);
            go(0, 0);
            return 0;
        }
        ```
        
        밑줄친 부분들이 중요한 부분
        
        ```cpp
        void go(int idx){
        	if(visited[idx]) continue;
        	for(
        }
        ```
        
    - map 의 first는 key고 second는 value다.
    
    [C++ Data Structures](C++%20662ee454b48547d8a663ad0510b65469/C++%20Data%20Structures%2058d75dc8bf454d7aa0f0da499372410f.md)
    
    [수학](C++%20662ee454b48547d8a663ad0510b65469/%E1%84%89%E1%85%AE%E1%84%92%E1%85%A1%E1%86%A8%20fa5f64e6150d472fbec04717d1c267b2.md)
    
    [코딩테스트 필수로직](C++%20662ee454b48547d8a663ad0510b65469/%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%89%E1%85%AE%E1%84%85%E1%85%A9%E1%84%8C%E1%85%B5%E1%86%A8%20d55ddba3f62f4f9aa9436ab68cf11129.md)
    
- string
    
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    int main() {
        string a = "love is";
        a += " pain!";
        a.pop_back();
        cout << a << " : " << a.size() << "\n";
        cout << char(* a.begin()) << '\n';
        cout << char(* (a.end() - 1)) << '\n';
        // string& insert (size_t pos, const string& str);
        a.insert(0, "test ");
        cout << a << " : " << a.size() << "\n";
        // string& erase (size_t pos = 0, size_t len = npos);
        a.erase(0, 5);
        cout << a << " : " << a.size() << "\n";
        // size_t find (const string& str, size_t pos = 0);
        auto it = a.find("love");
        if (it != string::npos){
            cout << "포함되어 있다." << '\n'; }
        cout << it << '\n';
        cout << string::npos << '\n';
        // string substr (size_t pos = 0, size_t len = npos) const;
        cout << a.substr(5, 2) << '\n'; return 0;
    }
    /*
     love is pain : 12
    l
    n
    test love is pain : 17
    love is pain : 12
    포함되어 있다.
    0
    18446744073709551615
    is 
     */
    
    #include<bits/stdc++.h>
    using namespace std;
    int main() {
        string a = "It's hard to have a sore leg";
        reverse(a.begin(), a.end()); //gel eros a evah ot drah s'tI
        cout << a << "\n";
    
        return 0;
    }
    ```
    
- split() 구현
    
    
    외우자
    
    ```cpp
    using namespace std;
    
    vector<string> split(string input, string delimiter){
    	vector<string> ret;
    	long long pos;
    	string token = "";
    	while((pos = input.find(delimiter)) != string::npos){
    		token = input.substr(0, pos);
    		ret.push_back(token);
    		ret.erase(0, pos + delimiter.length());
    	}
    	ret.push_back(input);
    	return ret;
    }
    
    int main(){
    	string s = "lukas is truly a genius"; string d = " ";
    	vector<string> a = split(s,d);
    	for(string b : a) cout << b << "\n"; 
    }
    ```
    
    위 코드는 계속 erase를 해주기 때문에 더 빠른 split을 생각해보면
    
    ```cpp
    vector<string> split(string input, string delimiter){
      vector<string> result;
      auto start = 0;
      auto end = input.find(delimiter);
      while (end != string::npos){
        result.push_back(input.substr(0, end - start));
        start = end + delimiter.size();
        end = input.find(delimiter, start);
      }
      result.push_back(input.substr(start));
      return result;
    }
    ```
    
    `s.find(찾을 문자열, 시작 위치, 찾을 문자열의 길이)`
    
    블랭크는(varying length of blank) 다 지우는 거
    
    ```cpp
    vector<string> split(string input, string delimiter) {
        vector<string> ret;
        size_t pos;
        while ((pos = input.find(delimiter)) != string::npos) {
            string token = input.substr(0, pos);
            if (!token.empty()) {  // Only add non-empty tokens
                ret.push_back(token);
            }
            input.erase(0, pos + delimiter.length());
        }
        if (!input.empty()) {  // Add the remaining token
            ret.push_back(input);
        }
        return ret;
    }
    ```
    
- pair, tuple
    
    pair: first와 second라는 멤버변수를 가지는 클래스. 두가지 값을 담아야 할 때 쓴다.
    
    tuple: 세가지 이상의값을 담을 때 쓰는 클래스
    
    ```cpp
    #include <bits/stdc++.h>
    using namespace std; 
    pair<int, int> pi;
    tuple<int, int, int> tl;
    int a, b, c;
    int main() {
      pi = {1, 2};
      tl = make_tuple(1, 2, 3);
      tie(a, b) = pi;
      cout << a << " : " << b << "\n";
      tie(a, b, c) = tl;
      cout << a << " : " << b << " : " << c << "\n";
      return 0;
    }
    
    #include<bits/stdc++.h>
    using namespace std; pair<int, int> pi; tuple<int, int, int> ti; int a, b, c;
    int main(){
    pi = {1, 2};
        a = pi.first;
        b = pi.second;
        cout << a << " : " << b << "\n";
        ti = make_tuple(1, 2, 3);
        a = get<0>(ti);
        b = get<1>(ti);
        c = get<2>(ti);
        cout << a << " : " << b << " : "<< c << "\n";
    return 0; }
    /*
    1:2 1:2:3
    */
    ```
    
- sort()
    
    ```cpp
    #include <bits/stdc++.h>
    using namespace std; 
    
    vector<int> a;
    int b[5];
    int main(){
      for(int i=5; i>=1; i--) b[i-1] = i;
      for(int i = 5; i>= 1; i--) a.push_back(i);
      
      for(int i : a) cout << i << " "; //5 4 3 2 1
    
      // [first iterator, last iterator)
      //the third parameter: greater<T>()/less<T>()
      sort(b, b+5, less<int>());
      sort(a.begin(), a.end(), less<int>());
      for(int i: b) cout << i<< ' '; // 1 2 3 4 5 
      cout << '\n';
      for(int i : a) cout << i<< ' '; // 1 2 3 4 5
      cout << '\n';
    
      sort(b, b + 5, greater<int>());
      for (int i : b) cout << i << ' '; // 5 4 3 2 1
      cout << "\n";
      sort(a.begin(), a.end(), greater<int>());
      for (int i : a) cout << i << ' '; // 5 4 3 2 1
      cout<<"\n";
    
      return 0;
    }
    ```
    
    pair를 기반으로 만들어진 vector의 경우 따로 설정하지 않으면 first, second 순으로 차례차례 오름차순 정렬 된다.
    
    ```cpp
    #include <bits/stdc++.h>
    using namespace std; 
    
    vector<pair<int, int>> v;
    
    int main(){
      for(int i = 10; i >= 1; i--){
        v.push_back({i, 10-i});
      }
      sort(v.begin(), v.end());
      for(auto i : v) cout << i.first << ":" << i.second <<'\n';
      return 0;
    }
    
    /*
    1:9
    2:8
    3:7
    4:6
    5:5
    6:4
    7:3
    8:2
    9:1
    10:0
    */
    ```
    
    만약 first는 내림차순, seond는 오름차순 정렬하고 싶다면? 바로 커스텀 비교하수 cmp를 만들어 매개변수로 넣으면 된다.
    
    ```cpp
    #include <bits/stdc++.h>
    using namespace std; 
    
    vector<pair<int, int>> v;
    
    bool cmp(pair<int, int> a, pair<int, int> b){
      return a.first > b.first;
    }
    
    int main(){
      for(int i = 10; i >= 1; i--){
        v.push_back({i, 10-i});
      }
      sort(v.begin(), v.end(), cmp);
      for(auto i : v) cout << i.first << ":" << i.second <<'\n';
      return 0;
    }
    
    /*
    10:0
    9:1
    8:2
    7:3
    6:4
    5:5
    4:6
    3:7
    2:8
    1:9
    */
    ```
    
- 중복된 요소를 제거하는 방법
    1. map을 사용
    
    ```cpp
    #include <bits/stdc++.h>
    using namespace std; 
    
    map<int, int> mp;
    int main(){
      vector<int> v{1, 1, 2, 3, 3, 2};
      for(int i : v){
        if(mp[i]){
          continue;
        }else{
          mp[i] = 1;
        }
      }
      vector<int> ret;
      for(auto i : mp){
        ret.push_back(i.first);
      }
      for(int it : ret) cout << it << "\n";
      return 0;
    }
    /*
    1
    2
    3
    */
    ```
    
    1. unique() 
    - unique는 범위안의 있는 요소 중 앞에서부터 서로를 비교해가며 중복되는 요소를 제거하고 나머지 요소들은 삭제하지 않고 그대로 두는 함수이다. O(n)의 시간복잡도.
    - 중복되지 않은 요소로 채운 후, 그 다음 이터레이터를 반환한다.
    - 앞에서부터 중복되지 않게 채운 후, **나머지 요소들은 그대로 둔다**. 나머지 요소들을 그대로 둔다는게 중요하다.
    - every possible array에 대해 맨 처음을 중복되지 않는 요소들로 채우려면 sort() 함수와 함께 써야 한다.
    
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    vector<int> v;
    int main() {
      for(int i = 1; i<=5; i++){
        v.push_back(i);
        v.push_back(i);
      }
      for(int it : v) cout << it << ' '; //1 1 2 2 3 3 4 4 5 5 
      cout << "\n"; 
      
      auto it = unique(v.begin(), v.end());
      cout << it - v.begin() <<'\n'; //5
    
      for(int i : v) cout << i << " "; //1 2 3 4 5 3 4 4 5 5 
      cout << "\n";
      return 0;
    }
    ```
    
    unique() 앞에서부터 이웃한 두 수를 비교하면서 로직을 전개하기 때문에 sort()를 먼저 시켜준 배열에다가 써야 예쁘다.
    
    unique()를 했을 때 원본 배열의 앞에서부터 채우고, 채우지 않은 부분들(뒤에 애들)의 경우 건드리지 않기 때문에 erase()와 sort()를 적절히 사용하여서 예쁜 배열을 만드는 것이 중요하다.
    
    ```java
    vector<int> v = {1, 1, 2, 2, 4, 3, 3, 5, 6, 7, 8, 9};
    v.sort() //{1, 1, 2, 2, 3, 3, 4, 5, 6, 7, 8, 9}
    auto it = v.unique(v.begin(), v.end()); //{1, 2, 3, 4, 5, 6, 7, 8, 9, 7, 8, 9}
    v.erase(it, v.end()); //{1, 2, 3, 4, 5, 6, 7, 8, 9}
    
    //줄여서 한번에
    v.erase(unique(v.begin(), v.end()), v.end()); //{1, 2, 3, 4, 5, 6, 7, 8, 9}
    ```
    
- lower_bound, upper_bound
    
    정렬된 배열에서 어떤 값이 나오는 첫번쨰 지점 또는 초과하는 지점의 위치를 찾으려면?
    
    lower_bound() 와 upper_bound() 해당 자료형으로부터 이터레이터를 반환하므로 직접적인 숫자를 얻고 싶다면 v.begin()을 뺴주어야 한다.
    
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    typedef long long ll;
    int main() {
      vector<int> a {1, 2, 3, 3,  3, 4};
      /*
      lower_bound:해당 값의 시작점
      upper_bound:해당 값의 초과점
      */
      cout << lower_bound(a.begin(), a.end(), 3) - a.begin() << "\n"; //2
      cout << upper_bound(a.begin(), a.end(), 3) - a.begin() << "\n"; //5
    
      //checking the memory location
      cout << &*lower_bound(a.begin(), a.end(), 3) << "\n"; //0x7fe9ca004088
      cout << &*a.begin()<< "\n"; //0x7fe9ca004080
      cout << &*(a.begin() + 1)<<"\n"; //0x7fe9ca004084
    
      return 0;
    }
    ```
    
    만약 해당 요소가 없을 경우 그 근방 지점을 반환한다.
    
    ```cpp
    #include <bits/stdc++.h>
    using namespace std; vector<int> v;
    int main(){
    for(int i = 2; i <= 5; i++)v.push_back(i);
    v.push_back(7);
    // 2 3 4 5 7
    cout << upper_bound(v.begin(), v.end(), 6) - v.begin() << "\n"; // 2 3 4 5 7
    // 0 1 2 3 4 에서 근방지점인 4번째 (7보다 6이 더 작으므로)
    cout << lower_bound(v.begin(), v.end(), 6) - v.begin() << "\n"; // 2 3 4 5 7
    // 0 1 2 3 4 에서 근방지점인 4번째 (7보다 6이 더 작으므로)
    cout << upper_bound(v.begin(), v.end(), 9) - v.begin() << "\n"; // 2 3 4 5 7
    // 0 1 2 3 4 에서 근방지점인 5번째(7보다 9가 더 크므로)
    cout << lower_bound(v.begin(), v.end(), 9) - v.begin() << "\n"; // 2 3 4 5 7
    // 0 1 2 3 4 에서 근방지점인 5번째(7보다 9가 더 크므로)
    cout << upper_bound(v.begin(), v.end(), 0) - v.begin() << "\n"; // 2 3 4 5 7
    // 0 1 2 3 4 에서 근방지점인 0번째(0보다 2가 더 크므로)
    cout << lower_bound(v.begin(), v.end(), 0) - v.begin() << "\n"; // 2 3 4 5 7
    // 0 1 2 3 4 에서 근방지점인 0번째(0보다 2가 더 크므로)
    }
    /* 4 4 5 5 0 0 */
    ```
    
- 꿀팁
    - 한 함수 안에서 같은 함수가 N번 호출되면 시간복잡도는 대부분 O(N^n)
        - 예) 시간 복잡도가 3^n인 코드
        
        ```cpp
        #include<bits/stdc++.h>
        using namespace std;
        int N, cnt;
        void solve(int N){
          cnt++;
          cout << cnt << '\n';
          if(N == 0) return;
          for(int i=0; i<3; i++){
            solve(N-1);
          }
          return;
        }
        
        int main(){
          cin >> N;
          solve(N);
          return 0;
        }
        ```
        

[Coding Test | Algorithm](C++%20662ee454b48547d8a663ad0510b65469/Coding%20Test%20Algorithm%20cc9aa75db0c44b918574f66f08cf0c21.md)

[Coding Test | LeetCode](C++%20662ee454b48547d8a663ad0510b65469/Coding%20Test%20LeetCode%204d41aafa2b2a45538b8558ac408d04d9.md)

[SDE](C++%20662ee454b48547d8a663ad0510b65469/SDE%20dbabd6a0590042c184d07d3091369cfe.md)

- accumulate: 세번째 인자: initial value of the sum
    
    the sum of all the elements in a vector
    
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    typedef long long ll;
    int main() {
      vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
      int sum = accumulate(v.begin(), v.end(), 0);
      cout << sum << "\n"; //55
      return 0;
    }
    ```
    
- max_element(): return type → iterator → 그래서 v.begin()을 빼주어야함

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int main() {
  vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  int a = *max_element(v.begin(), v.end());
  auto b = max_element(v.begin(), v.end());
  cout << a << "\n"; //10
  cout << (int)(b-v.begin()) << "\n"; //9
}
```

- min_element(): return type → iterator
    
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    typedef long long ll;
    int main() {
      vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
      int a = *min_element(v.begin(), v.end());
      auto b = min_element(v.begin(), v.end());
      cout << a << "\n"; //1
      cout << (int)(b-v.begin()) << "\n"; //0
    }
    ```
    

- 2차원 배열수정
    
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    
    vector<vector<int>> v2(10, vector<int>(10, 0));
    
    void go(vector<vector<int>> &v){
      v[0][0] = 100;
    }
    int main(){
      go(v2);
      cout << v2[0][0] << "\n"; //100
      return 0;
    }
    ```
    
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    
    int a[3][3] = {{1, 2, 3}, {1, 2, 3}, {1, 2, 3}};
    void go(int a[][3]){
    	a[2][2] = 100;
    }
    void go2(int a[3][3]){
    	a[2][2] = 1000;
    }
    int main(){
    	go(a); cout << a[2][2] << '\n';
    	go2(a); cout << a[2][2] << '\n';
    }
    /*
    100
    1000
    */
    ```
    

[값에 의한 호출과 참조에 의한 호출](C++%20662ee454b48547d8a663ad0510b65469/%E1%84%80%E1%85%A1%E1%86%B9%E1%84%8B%E1%85%A6%20%E1%84%8B%E1%85%B4%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%92%E1%85%A9%E1%84%8E%E1%85%AE%E1%86%AF%E1%84%80%E1%85%AA%20%E1%84%8E%E1%85%A1%E1%86%B7%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%A6%20%E1%84%8B%E1%85%B4%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%92%E1%85%A9%E1%84%8E%E1%85%AE%E1%86%AF%2094f27ec1ff0e48259082006bf4464d7d.md)

- fibonacci
    
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    
    int fibonacci(int n){
    	if(n==0 || n==1) return 1;
    	return fobonacci(n-1) + fibnacci(n-2);
    }
    ```
    
    **재귀함수
    
    1. 반드시 기저사례를 써야한다. ex) `if(n==1 || n==0) return 1;`
    2. 사이클이 있다면 쓰면 안된다. ex) f(a)가 f(b)를 호출한 뒤 f(b)가 다시 f(a)를 호출하는 것
    3. 반복문으로 될 거 같으면 반복문으로. (함수 호출에 대한 코스트가 크다).

```cpp
//0에만 1을 세울 수 있음
//0의 좌표
//2의 좌표 
#include <bits/stdc++.h>
using namespace std;
int m, n, cnt, finalCnt, ret;
int a[10][10];
int visited[10][10];
vector<pair<int, int>> zeros;

int dy[] = {-1, 0, 1, 0};
int dx[] = {0, 1, 0, -1};

void go(int y, int x){
    cnt++;
    visited[y][x] = 1;
    for(int i=0; i<4; i++){
        int ny = y+dy[i];
        int nx = x+dx[i];
        if(ny<0 || ny>=m || nx<0 || nx>=n || a[ny][nx] == 1 || a[ny][nx] == 2)continue;
        if(visited[ny][nx])continue;
        go(ny, nx);
    }
}

vector<vector<pair<int, int>>> choose(int n){
    vector<vector<pair<int, int>>> ret;
    for(int i=0; i<n; i++){
        for(int j=0; j<i; j++){
            for(int k=0; k<j; k++){
                vector<pair<int, int>> v;
                v.push_back(zeros[i]);
                v.push_back(zeros[j]);
                v.push_back(zeros[k]);
                ret.push_back(v);
            }
        }
    }
    return ret;
}

int main(){
    cin >> m >> n;
    for(int i=0; i<m; i++){
        for(int j=0; j<n; j++){
            cin >> a[i][j];
            if(a[i][j] == 0){
                zeros.push_back(pair<int,int>(i, j));
            }
        }
    }
    vector<vector<pair<int, int>>> v = choose(zeros.size());
    for(int i=0; i<v.size(); i++){
        //세 개씩 들은 벡터들 순회
        finalCnt=0;
        int destinationArray[10][10];
        fill(&visited[0][0], &visited[0][0] + 10*10, 0);
        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){                destinationArray[i][j] = a[i][j];
            }
        }
        //3개 벽 세우기
        for(int j=0; j<3; j++){
            destinationArray[v[i][j].first][v[i][j].second] = 1;
        }
        //2에서 보내기
        for(int k=0; k<m; k++){
            for(int l=0; l<n; l++){
                if(destinationArray[k][l]==2 && visited[k][l] == 0){
                    cnt=0;
                    go(k, l);
                    finalCnt += cnt;
                }
            }
        }
        ret = max(finalCnt, ret);
    }
    cout << ret << "\n";
    return 0;
}
```