# Python for Data Analysis - NumPy

NumPy is very fast as it relies on C.

- NumPy Arrays
    
    Vectors are 1-D arrays and matrices are 2-D (matrices still can have only one row or column) 
    
    **Q. yo what’s the difference between Python list and NumPy array?**
    
    1. they both use square brackets.
    2. both data types are mutable.
    3. both can be indexed and can be used for slicing operations.
    
    Now what’s different
    
    1. List cannot directly handle mathematical operations while array can.
    2. An array consumes less memory than a list (because a list can contain various types of data while array can’t).
    3. using an array is faster than a list ( it takes up less spaces and NumPy is originally designed for the numeral operations, therefore the tasks are broken into small segments and then get processed in in parallel).
    4. A list is easier to modify.
    5. A list can consist of different data size.
    6. A list can store different data types.
    
    ```python
    import numpy as np
    
    my_list = [1, 2, 3, 4]
    arr = np.array(my_list)
    print(arr) #prints [1 2 3 4]
    ```
    
    <arange()  method>
    
- `arange(stop)`: Values are generated within the half-open interval `[0, stop)` (in other words, the interval including *start* but excluding *stop*).
- `arange(start, stop)`: Values are generated within the half-open interval `[start, stop)`.
- `arange(start, stop, step)` Values are generated within the half-open interval `[start, stop)`, with spacing between values given by `step`.
    
    ```python
    import numpy as np
    
    print(np.arange(0, 10)) #prints [0 1 2 3 4 5 6 7 8 9]
    print(np.arange(0, 11, 2)) #prints [ 0  2  4  6  8 10]
    # the 2 at the last is the step size.
    ```
    
    <zeros and ones>
    
    zeros() and ones() methods, the **built-in methods in NumPy,** generates matrix as indicated in the parenthesis of the methods. when generating int x int matrices, you should put **a tuple of the dimension** you want as the parameters.
    
    ```python
    import numpy as np
    
    print(np.zeros(3)) #[0. 0. 0.]
    # what goes in the zeros() method is the tuple 
    # of the dimensions
    print(np.zeros((3, 3))) #(3, 3) is the aformentioned tuple struture.
    '''
    [[0. 0. 0.]
     [0. 0. 0.]
     [0. 0. 0.]]
    '''
    print(np.ones((3,2)))
    '''
    [[1. 1.]
     [1. 1.]
     [1. 1.]]
    '''
    ```
    
    <linspace() method>
    
    numpy.linspace(*start*, *stop*, *num=50*, *endpoint=True*, *retstep=False*, *dtype=None*, *axis=0*)
    
    linspace() method returns evenly spaced numbers over a specified interval.
    
    ```python
    ###linspace()
    print(np.linspace(0, 5, 10))
    '''
    [0.         0.55555556 1.11111111 1.66666667 2.22222222 2.77777778
     3.33333333 3.88888889 4.44444444 5.        ]
    '''
    print(np.linspace(0, 10, 30))
    '''
    [ 0.          0.34482759  0.68965517  1.03448276  1.37931034  1.72413793
      2.06896552  2.4137931   2.75862069  3.10344828  3.44827586  3.79310345
      4.13793103  4.48275862  4.82758621  5.17241379  5.51724138  5.86206897
      6.20689655  6.55172414  6.89655172  7.24137931  7.5862069   7.93103448
      8.27586207  8.62068966  8.96551724  9.31034483  9.65517241 10.        ]
    '''
    ```
    
    <eye() method>
    Return a 2-D array with ones on the diagonal and zeros elsewhere.
    
    when a matrix is multiplied by the matrix generated by the eye() method (this matrix is a diagonal matrix with the ones on the diagonal) the result is the matrix itself as long as the dimensions of the two are the same.
    
    ```python
    print(np.eye(4))
    '''
    [[1. 0. 0. 0.]
     [0. 1. 0. 0.]
     [0. 0. 1. 0.]
     [0. 0. 0. 1.]]
    '''
    ```
    
    <random.rand(), random.randn(), and random.randint() methods>
    
    random.rand() creates an array of the given shape and populate it with random samples from a uniform distribution over `[0, 1)`
    
    random.randn() returns a sample (or samples) from the “standard normal” distribution.
    
    random.randint() takes start point, end point, and the number of elements. **the start&end points are inclusive.**
    
    ```python
    ##random.rand
    ##for the methods in the random, we do not put the tuple of dimension,
    ##we just do so by rand(num, num)
    print(np.random.rand(5)) # prints [0.44117693 0.01703257 0.02885863 0.84663857 0.84035285]
    print(np.random.rand(2,3))
    '''
    [[0.95076603 0.44629493 0.90702728]
     [0.22794143 0.57196879 0.86324009]]
    '''
    
    ##random.randn (standard normal distribution)
    print(np.random.randn(3)) #prints [ 0.56023379 -1.37725046  1.6913579 ]
    print(np.random.randn(2,2)) 
    '''
    [[ 0.94219906  0.91769874]
     [ 1.47663204 -0.37825864]]
    '''
    
    # randint
    # rand.random.randint(start, end, number_of_elements)
    print(np.random.randint(0, 100, 10)) # prints [ 1 28 77 26 75 95 27 47 33 20]
    ```
    
    <reshape() method>
    
    reshape() method basically reshapes a matrix.
    
    ```python
    # reshape
    arr = np.arange(25)
    # if the number of the elements in matrix and the number of elements 
    # in the array that's reshaped, t generates an error.
    new_arr = arr.reshape(5, 5) 
    print(new_arr)
    '''
    [[ 0  1  2  3  4]
     [ 5  6  7  8  9]
     [10 11 12 13 14]
     [15 16 17 18 19]
     [20 21 22 23 24]]
     '''
    ```
    
    < max(), min(), argmax(), and argmin() methods>
    
    ```python
    # max(), min(), argmax(), argmin()
    # argmax() and argmin() methods returns the index values of the max and min elements.
    rand_arr = np.random.randint(0, 25, 25)
    print(rand_arr) #[ 5  3 14  1 16 10  4 23  5 20  2 24 11  2
    #12  6  8 11 14  3 10  1 23 22 1]
    print(rand_arr.max()) #24
    print(rand_arr.min()) #1
    print(rand_arr.argmax())#11
    print(rand_arr.argmin())#3
    ```
    
    <shape and dtype method> 
    
     keep in mind that the these methods are not used with the parenthesis.
    
    ```python
    # shape method
    # returns the shape of matrix.
    # keep in mind that the this method is not used with the parenthesis.
    arr = np.arange(0, 6)
    print(arr.shape) # (6,)
    arr = arr.reshape(3, 2)
    print(arr.shape) # (3, 2)
    
    #data type: dtype
    # keep in mind that the this method is not used with the parenthesis.
    print(arr.dtype) # int64
    ```
    
    <broadcasting an array>
    
    so basically when you broadcasts arrays and save it to another variable, it still affects  the original arr. the reason why NumPy does this is because to use memory more efficiently. To avoid this, you can use copy() method to copy the original array and make changes to it. That way, the original arr will not change.
    
    ```python
    #
    in python, you can broadcast an array.
    arr = np.arange(0,10) #[0 1 2 3 4 5 6 7 8 9]
    arr[0:5] = 100 #[100 100 100 100 100   5   6   7   8   9]
    
    #########
    import numpy as np
    
    arr = np.arange(0, 10)
    print(arr) # [0 1 2 3 4 5 6 7 8 9]
    
    arr[0:5] = 100
    print(arr) # [100 100 100 100 100   5   6   7   8   9]
    
    slice_of_arr = arr[0:6] 
    print(slice_of_arr)
    #when you do this, you are refering to the whole array.
    slice_of_arr[:] = 99
    print(slice_of_arr) # [99 99 99 99 99 99]
    print(arr) # you can see this affects the original arr as well.
               # what it prints: [99 99 99 99 99 99  6  7  8  9]
    ###############
    import numpy as np
    
    arr = np.arange(0, 10)
    print(arr) # [0 1 2 3 4 5 6 7 8 9]
    
    arr_copy = arr.copy()
    print(arr_copy) # [0 1 2 3 4 5 6 7 8 9]
    arr_copy[0:5] = 100
    print(arr_copy) #[100 100 100 100 100   5   6   7   8   9]
    print(arr)  # [0 1 2 3 4 5 6 7 8 9]
                # the original array didn't get affected.
    ```
    
    <matrix indexing>
    
    ```python
    import numpy as np
    
    matrix = np.array([[1,2,3,], [4, 5, 6], [7, 8, 9]])
    print(matrix)
    '''
    [[1 2 3]
     [4 5 6]
     [7 8 9]]
    '''
    print(matrix[2, 1]) # 8
    print(matrix[1:,:2]) 
    '''
    [[4 5]
     [7 8]]
    '''
    ##################
    import numpy as np
    
    arr_2d = np.arange(0, 50).reshape(5, 10)
    print(arr_2d)
    print(arr_2d[1:4,5:8])
    '''
    [[15 16 17]
     [25 26 27]
     [35 36 37]]
    '''
    ######VERY IMPORTANT#######
    import numpy as np
    
    mat = np.arange(0, 16).reshape(4, 4)
    print(mat)
    ##I want to grap [[1
    #                  5
    #                  9]]
    print(mat[0:3, 1]) #prints [1 5 9]
    print(mat[0:3, 1:2]) #you have to n:n+1 to get it vertically
    '''
    [[1]
     [5]
     [9]]
    '''
    ```
    
    <conditional selection>
    
    you can use the name of the array as the index of the array as a boolean value.
    
    ```python
    import numpy as np
    
    bool_arr = np.arange(0, 10)
    print(bool_arr[bool_arr > 5]) # [6 7 8 9]
    ```
    
- [NumPy Operations](https://numpy.org/doc/stable/reference/routines.math.html)
    
    <NumPy Operations>
    
    - Array with Array
    - Array with Scalars
    - Universal Array Functions
    
    ```python
    import numpy as np
    
    arr = np.arange(0,11)
    print(arr) #[ 0  1  2  3  4  5  6  7  8  9 10]
    print(arr+arr) #[ 0  2  4  6  8 10 12 14 16 18 20]
    print(arr-arr) #[0 0 0 0 0 0 0 0 0 0 0]
    print(arr*arr) #[  0   1   4   9  16  25  36  49  64  81 100]
    
    #scalar means "just a single number"
    ##scalar operation
    print(arr-100)#[-100  -99  -98  -97  -96  -95  -94  -93  -92  -91  -90]
    
    #when the invalid operation occur in numpy, 
    #it will still process it, but give you a warning.
    print(arr/arr)
    '''
    index.py:14: RuntimeWarning: invalid value encountered in true_divide
      print(arr/arr)
    [nan  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.]
    '''
    print(1/arr)
    '''
    index.py:21: RuntimeWarning: divide by zero encountered in true_divide
      print(1/arr)
    [       inf 1.         0.5        0.33333333 0.25       0.2
     0.16666667 0.14285714 0.125      0.11111111 0.1       ]
    '''
    print(arr ** 2) #[  0   1   4   9  16  25  36  49  64  81 100]
    
    ##universal array function()
    print(np.exp(arr))
    '''
    [1.00000000e+00 2.71828183e+00 7.38905610e+00 2.00855369e+01
     5.45981500e+01 1.48413159e+02 4.03428793e+02 1.09663316e+03
     2.98095799e+03 8.10308393e+03 2.20264658e+04]
    '''
    print(np.max(arr))
    print(np.min(arr))
    print(np.sin(arr))
    print(np.cos(arr))
    print(np.log(arr))
    '''
    [ 0.          0.84147098  0.90929743  0.14112001 -0.7568025  -0.95892427
     -0.2794155   0.6569866   0.98935825  0.41211849 -0.54402111]
    [ 1.          0.54030231 -0.41614684 -0.9899925  -0.65364362  0.28366219
      0.96017029  0.75390225 -0.14550003 -0.91113026 -0.83907153]
    index.py:41: RuntimeWarning: divide by zero encountered in log
      print(np.log(arr))
    [      -inf 0.         0.69314718 1.09861229 1.38629436 1.60943791
     1.79175947 1.94591015 2.07944154 2.19722458 2.30258509]
    '''
    ```