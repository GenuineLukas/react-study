# python grammar

- String and List
    
    In Python, String and List are working very similarly because they are both the sequence of elements.
    
    <String>
    
    ```python
    s = 'abcd'
    #slicing
    s[:0] # returns every element in the string
    s[:3] # retruns every element upto the indicated index(NOT inclusive)
    s[0:3] # returns the same thing as s[:3], since only the leftside index is inclusive.
    ```
    
    <List>
    
    A list in python is made up with the square brackets, unlike Java.
    
    ```python
    my_list = ['a', 'b', 'c']
    #you can append the element to a list by using append() method.
    my_list.append('d') # my_list is now ['a', 'b', 'c', 'd']
    
    #same for sclicing as it works in the String !!!!!!!
    
    #you can nest a list in a list 
    nest = [1, 2, [3, 4]]
    nest[2] #returns [3,4]
    nest[2][1] #returns 4
    nested_list = [1, 2, 3, [4, 5, ['target']]]
    nested_list[3][2][0] #returns 'target' if you eliminate [0], then returns ['target']
    
    #you can add and multiply the lists
    list1 = [1, 2, 3]
    list2 = [4, 5, 6]
    print(list1)
    print(list1 + list2) #prints [1, 2, 3, 4, 5, 6]
    print(list1*3) #prints [1, 2, 3, 1, 2, 3, 1, 2, 3]
    
    #you can get the length of the list by using len() method.
    #getting lenth of a list is basically counting the number of the elements in it
    list = [1,2,3]
    list.append(4)
    print(len(list))
    
    #you can change a different data structure to a list by using list() method.
    >>> s1 = set([1,2,3])
    >>> l1 = list(s1)
    >>> l1
    [1, 2, 3]
    >>> l1[0]
    1
    ```
    
- Dictionary and Tuple
    
    <Dictionary>
    
    A dictionary in python works as a key&value pair just like hash table in java.
    
    ```python
    #A dictionary is made up with the curly bracket.
    dict = {'key1': 'value1', 'key2': 'value2'}
    
    #dictionary uses keys instead of indices.
    my_value = dict['key1'] # returns 'value1'
    
    #you can nest a dict in dict
    dictionary = {'key1':{'innerkey':[1,2,3,4]}}
    my_list = dictionary['key1']['innnerkey']
    ```
    
    <Tuple>
    
    a  tuple is almost the same as a list, except for the fact that it is **immutable.** 
    
    it generates errors when you try to mutate or eliminate elements in the tuple.
    
    *immutable: you cannot change any item stored in the data structure (here, tuple)
    
    tuple is made up with **parentheses.**
    
    ```python
    # tuples can be defined without paranthesis as well.
    # if only one element exist in the tuple, you should put , at the end.
    tuple1 = (1,)
    tuple = 1,
    if(tuple1 == tuple):
        print('these tuples are the same.') #prints these tuples are the same.
    
    # slciing works the same as it works in strings or lists.
    
    # you can add and multipy tuples.
    t1 = (1,2,3)
    t2 = 3,
    print(t1 + t2) #prints (1, 2, 3, 3)
    print(t1*3) #prints (1, 2, 3, 1, 2, 3, 1, 2, 3)
    
    #you can get the length of the tuples by using len() method.
    t3 = t1 + t2
    print(len(t3)) #prints 4
    
    #you can change a different data structure to a list by using tuple() method.
    >>> t1 = tuple(s1)
    >>> t1
    (1, 2, 3)
    >>> t1[0]
    1
    ```
    
- Set
    
    A set is a data structure that hinders an element from existing more than once in it.
    
    Basically, you can think of a set as a set you learned in your probability class.
    
    A set does NOT allow duplicates and it does not guarantee a sequence among elements 
    
    ```python
    #set can be generated by using set() method or just a curly bracket
    s1 = {1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,100}
    print(s1) #prints {1, 2, 3, 4, 5, 6, 7, 8, 100}
    s2 = set([1,2,2,2,3,3,56])
    print(s2) #prints {56, 1, 2, 3} -> DOES NOT guarantee the iputted sequence.
    #What happens given a string in set() method.
    s3 = set("Hello")
    print(s3)# prints{'l', 'e', 'o', 'H'} 
    
    #intersection(교집합) of the sets
    s1 = {1, 2, 3, 4, 5, 6}
    s2 = {3, 4, 5, 6, 7, 8, 9}
    #getting the intersection by using & operator.
    print(s1&s2) #prints {3, 4, 5, 6}
    #getting the intersection by using intersection() method.
    print(s1.intersection(s2)) #prints {3, 4, 5, 6}
    
    #union(합집합)
    s1 = {1, 2, 3, 4, 5, 6}
    s2 = {3, 4, 5, 6, 7, 8, 9}
    #getting the intersection by using | operator.
    print(s1|s2) #prints {1, 2, 3, 4, 5, 6, 7, 8, 9}
    #getting the intersection by using union() method.
    print(s1.union(s2)) #prints {1, 2, 3, 4, 5, 6, 7, 8, 9}
    
    #difference(차집합)
    s1 = {1, 2, 3, 4, 5, 6}
    s2 = {3, 4, 5, 6, 7, 8, 9}
    #getting the diffrence by using - operator.
    print(s1 - s2) #prints {1, 2}
    print(s2 - s1) #prints {8, 9, 7}
    #getting the difference by using difference() method.
    print(s1.difference(s2)) #prints {1, 2}
    print(s2.difference(s1)) #prints {8, 9, 7}
    
    ###### 값 추가 #####
    #1. ADDING JUST ONE VALUE (add())
    s1 = {1, 2, 3, 4, 5, 6}
    s1.add(7)
    print(s1) #{1, 2, 3, 4, 5, 6, 7}
    #2. ADDING MULTIPLE VALUES (update())
    s1 = {1, 2, 3, 4, 5, 6}
    s1.add(7)
    print(s1) #{1, 2, 3, 4, 5, 6, 7}
    s1.update({7, 8, 9, 10})
    print(s1) #{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    s2 = {10, 11, 12}
    s1.update(s2)
    print(s1) #{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
    s1.update([13, 14, 15])
    print(s1) #{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}
    
    #3. REMOVING A CERTAIN VALUE (remove())
    s1 = {1, 2, 3, 4, 5}
    s1.remove(3) 
    print(s1) #{1, 2, 4, 5}
    ```
    
- and and or
    
    ```python
    print(3>2 and 2<1) #prints False
    print(3>2 and 2>1) #prints True
    print(4>2 or 2<1)#prints True
    print(4>2 or 2>1)#prints True
    print(4<2 or 2<1)#prints False
    ```
    
- if, elif, and else
    
    these are very straightforward. Please read again if you do not understand for the sake of continued learning.
    
    ```python
    # if-elif statement example
     
    letter = "A"
     
    if letter == "B":
       print("letter is B")
     
    elif letter == "C":
       print("letter is C")
     
    elif num == "A":
       print("letter is A")
     
    else:
       print("letter isn't A, B or C")
    #prints letter is A
    ```
    
- for, while, and the **list comprehension**
    
    ```python
    seq = [1,2,3,4,5]
    
    for item in seq:
        print(item) #prints 1
                        #   2
                        #   3
                        #   4
                        #   5
        
    i = 1
    while( i<5 ):
        print('i is {}.'.format(i))
        i+=1
                        #i is 1
                        #i is 2
                        #i is 3
                        #i is 4
    
    ##range
    for x in range(0, 5):
        print(x)    #prints 0
                        #   1
                        #   2
                        #   3
                        #   4
        
    list(range(0,10)) #returns [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    
    x = [1,2,3,4]
    out = [] #an empty list for now 
    for item in x: 
        out.append(item**2)
    print(out) #prints [1, 4, 9, 16]
    
    ##LIST COMPREHENSION
    out = [item**2 for item in x]
    print(out) #prints [1, 4, 9, 16]
    ```
    
- function (map(), lambda expression…)
    
    to make a function in Python, you need to use “def” keyword.
    
    ```python
    def my_function(name = 'default name'):
        print("Hello {}".format(name))
        
    my_function("Lukas") # prints Hello Lukas 
    my_function() #prints Hello default name
    
    #A function that uses a return statement.
    def square(number):
        return number**2
    print(square(2)) #prints 4
    print(square(4)) #prints 16
    ```
    
    <map() method>
    
    map() method is used to change a number of values into another form values
    
    by default, the structure  is as follows
    
    map (변환 함수, 순회 가능한 데이터)
    
    ```python
    def square(number):
        return number**2
    
    nums = [1, 2, 3, 4, 5, 6]
    new_nums = list(map(square, nums))
    print(new_nums) #prints [1, 4, 9, 16, 25, 36]
    
    #HOWEVER, since we need to creat a whole new function to be able to use
    #the map() method, it is better to use it with the lambda expression.
    ```
    
    <lambda expression>
    
    the structure of the lambda expression is as follows
    
    **lambda** 매개변수 : 표현식
    
    ```python
    nums = [1,2,3,4,5]
    ## when we do not cast map() method to list, we get...
    ## <map object at 0x7f7681618390>
    updated_nums = list(map(lambda item: item*2, nums))
    print(updated_nums) #prints [2, 4, 6, 8, 10]
    ```
    
    <filter() method>
    
    filter() method is used to filter out all the elements that happen to be false for the converting method that we use in it.
    
    ```python
    nums = [1,2,3,4,5]
    ## when we do not cast filter() method to list, we get...
    ## <filter object at 0x7f76816183d0>
    even_nums = list(filter(lambda x: x%2 == 0, nums))
    print(even_nums) #prints [2, 4]
    ```
    
    - useful methods (lower(), upper(), split(), etc.)
        
        ```python
        str = 'This is a STRING #for the test purpose'
        print(str.lower())
        print(str.upper())
        
        #split() method of the string
        #split the string and return a list that contains the elments
        #of the splitted string.
        print(str.split())
        print(str.split('#'))
        print(str.split('#')[0])
        
        '''
        result
        
        this is a string #for the test purpose
        THIS IS A STRING #FOR THE TEST PURPOSE
        ['This', 'is', 'a', 'STRING', '#for', 'the', 'test', 'purpose']
        ['This is a STRING ', 'for the test purpose']
        This is a STRING
        '''
        
        #keys(), values(), items() in dictionary
        dict = {'key1': 'item1', 'key2':'item2', 'key3':'item3'}
        
        print(dict.keys())
        print(dict.values())
        print(dict.items())
        
        '''
        dict_keys(['key1', 'key2', 'key3'])
        dict_values(['item1', 'item2', 'item3'])
        dict_items([('key1', 'item1'), ('key2', 'item2'), ('key3', 'item3')])
        '''
        
        #in
        x = [1, 2, 3, 4]
        
        if('new' in x):
            print("the keyword is in the list.")
        else:
            print("the keyword is not in list.")
         # prints the keyword is not in the list.
        
        #pop()
        #pop() method pops the last item of a list.
        #when pop is used with an index, 
        #it eliminates the element with the certain index.
        #if it is stored to a variable
        #the variable will be the eliminated value.
        x = [1, 2, 3, 4]
        
        print(x) #[1,2,3,4]
        x.pop()
        print(x)#[1,2,3]
        
        list = [1,2,3,4,5,6,7,8]
        a = list.pop(5)
        print(list) #[1,2,3,4,5,7,8]
        print(a) #6
        ```
        
- asterisk(*) in python
    1. **Asterisk as a unpacking purpose**
        
        ```python
        #asterisk as a unpacking tool
        
        def a(args):
            print(*args)
            
            
        tuple = (1, 2, 3)
        a(tuple) # 1 2 3 
        list = [1, 2, 3, 4]
        a(list) # 1 2 3 4
        nested_list = [1, 2, [1, 2, 3], 3, 4]
        a(nested_list) #1 2 [1, 2, 3] 3 4
        dictionary = {"key1":1, "key2":2, "key3":3}
        a(dictionary) #key1 key2 key3
        for key in sorted(dictionary):
            a(key)
            """
            k e y 1
            k e y 2
            k e y 3
            """
        arr = np.array(list)
        a(arr) #1 2 3 4
        ```
        
    2. **as an operator / list extender**
        1. * is for simple multiplication, ** is for the power of 2.
        2. extender
        
        ```python
        print(tuple*3)#(1, 2, 3, 1, 2, 3, 1, 2, 3)
        print(list*3)#[1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]
        ```
        
    3. **variable argument & keyword argument**
        
        this is used when we do not know the exact amount of variables we will take in a certain method(). 
        
        - you cannot use multiple variable arguments in one method().
        
        *args and *kwargs
        
        1. *args
            - when the method() is called, the multiple parameters are dealt as a tuple structure.
            
            ```python
            ##basic structures of args
            def <method name>(<parameter>, <parameter>, ..., *<vriable argument>):
            	<statement to be executed>
            
            #example
            def print_n_times(n, *values):
            	# you can deal with values as if it was list.
            	for i in range(n):
            		for value in values:
            			print(value)
            		print()
            
            print_n_times(3, "Hi", "I'm", "Lukas")
            '''
            Hi
            I'm
            Lukas
            
            Hi
            I'm
            Lukas
            
            Hi
            I'm
            Lukas
            '''
            ```
            
        2. **kwargs (keyword argument)
            - normally when the method() is called, the parameter will be in “key = value” format.
            - return value of the kwargs is in dictionary
                - ex)
                
                ```python
                def introduce_your_name(**kwargs):
                    for key, value in kwargs.items():
                        if 'me' in kwargs.keys():
                            print("Hello, Lukas!")
                        else: print("{0} is {1}".format(key, value))
                 
                introduce_your_name(me = 'Lukas') #Hello, Lukas!
                introduce_your_name(myName = 'Gnunee') #myName is Gnunee
                
                def definition(**kwargs): 
                    print(kwargs.items()) 
                    print(kwargs)
                
                definition(key = "k", main = "m")
                '''
                dict_items([('key', 'k'), ('main', 'm')])
                {'key': 'k', 'main': 'm'}
                '''
                ```
                
            
        
- good-to-know methods()
    - zip() method
        
        zip() method allows you to input multiples iterables(lists, tuples, dicts, sets, etc.) returns an iterator of tuples with the i-th element of each. the index of the returned iterator of tuples is determined by the length of the shortest(of the length) parameter. To avoid this, however, you could import zip_longest() method from the itertools and get the index of the returned iterator determined by the longest parameter as well.
        
        ```python
        prices = [10000, 20000, 15000]
        car_sizes = ["small", "large", "medium"]
        colors = ["red", "blue"]
        print(list(zip(prices, car_sizes))) #[(10000, 'small'), (20000, 'large'), (15000, 'medium')]
        print(list(zip(prices, car_sizes, colors)))#[(10000, 'small', 'red'), (20000, 'large', 'blue')]
        
        from itertools import zip_longest
        print(list(zip_longest(prices, car_sizes, colors)))#[(10000, 'small', 'red'), (20000, 'large', 'blue'), (15000, 'medium', None)]
        ```